
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model LlmCall
 * 
 */
export type LlmCall = $Result.DefaultSelection<Prisma.$LlmCallPayload>
/**
 * Model LlmMessage
 * 
 */
export type LlmMessage = $Result.DefaultSelection<Prisma.$LlmMessagePayload>
/**
 * Model Resume
 * 
 */
export type Resume = $Result.DefaultSelection<Prisma.$ResumePayload>
/**
 * Model ExtractedResume
 * 
 */
export type ExtractedResume = $Result.DefaultSelection<Prisma.$ExtractedResumePayload>
/**
 * Model ExtractedJobDescription
 * 
 */
export type ExtractedJobDescription = $Result.DefaultSelection<Prisma.$ExtractedJobDescriptionPayload>
/**
 * Model SummarizedResume
 * 
 */
export type SummarizedResume = $Result.DefaultSelection<Prisma.$SummarizedResumePayload>
/**
 * Model SummarizedJobDescription
 * 
 */
export type SummarizedJobDescription = $Result.DefaultSelection<Prisma.$SummarizedJobDescriptionPayload>
/**
 * Model GeneratedRoast
 * 
 */
export type GeneratedRoast = $Result.DefaultSelection<Prisma.$GeneratedRoastPayload>
/**
 * Model GeneratedCoverLetter
 * 
 */
export type GeneratedCoverLetter = $Result.DefaultSelection<Prisma.$GeneratedCoverLetterPayload>
/**
 * Model GeneratedResume
 * 
 */
export type GeneratedResume = $Result.DefaultSelection<Prisma.$GeneratedResumePayload>
/**
 * Model GeneratedInterviewPrep
 * 
 */
export type GeneratedInterviewPrep = $Result.DefaultSelection<Prisma.$GeneratedInterviewPrepPayload>
/**
 * Model InterviewEvaluation
 * 
 */
export type InterviewEvaluation = $Result.DefaultSelection<Prisma.$InterviewEvaluationPayload>
/**
 * Model SharedAnalysis
 * 
 */
export type SharedAnalysis = $Result.DefaultSelection<Prisma.$SharedAnalysisPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Announcement
 * 
 */
export type Announcement = $Result.DefaultSelection<Prisma.$AnnouncementPayload>
/**
 * Model Chatbot
 * 
 */
export type Chatbot = $Result.DefaultSelection<Prisma.$ChatbotPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationMessage
 * 
 */
export type ConversationMessage = $Result.DefaultSelection<Prisma.$ConversationMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SubscriptionTier: {
  FREE: 'FREE',
  PLUS: 'PLUS',
  PREMIUM: 'PREMIUM'
};

export type SubscriptionTier = (typeof SubscriptionTier)[keyof typeof SubscriptionTier]


export const LlmCallStatus: {
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  TIMEOUT: 'TIMEOUT'
};

export type LlmCallStatus = (typeof LlmCallStatus)[keyof typeof LlmCallStatus]


export const MessageRole: {
  system: 'system',
  user: 'user',
  assistant: 'assistant'
};

export type MessageRole = (typeof MessageRole)[keyof typeof MessageRole]


export const InvoiceStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const AnnouncementType: {
  COMING_SOON: 'COMING_SOON',
  IN_PROGRESS: 'IN_PROGRESS',
  BETA: 'BETA',
  NEW: 'NEW',
  MAINTENANCE: 'MAINTENANCE',
  UPDATE: 'UPDATE'
};

export type AnnouncementType = (typeof AnnouncementType)[keyof typeof AnnouncementType]


export const VerificationTokenType: {
  EMAIL_VERIFICATION: 'EMAIL_VERIFICATION',
  PASSWORD_RESET: 'PASSWORD_RESET'
};

export type VerificationTokenType = (typeof VerificationTokenType)[keyof typeof VerificationTokenType]

}

export type SubscriptionTier = $Enums.SubscriptionTier

export const SubscriptionTier: typeof $Enums.SubscriptionTier

export type LlmCallStatus = $Enums.LlmCallStatus

export const LlmCallStatus: typeof $Enums.LlmCallStatus

export type MessageRole = $Enums.MessageRole

export const MessageRole: typeof $Enums.MessageRole

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type AnnouncementType = $Enums.AnnouncementType

export const AnnouncementType: typeof $Enums.AnnouncementType

export type VerificationTokenType = $Enums.VerificationTokenType

export const VerificationTokenType: typeof $Enums.VerificationTokenType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.llmCall`: Exposes CRUD operations for the **LlmCall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LlmCalls
    * const llmCalls = await prisma.llmCall.findMany()
    * ```
    */
  get llmCall(): Prisma.LlmCallDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.llmMessage`: Exposes CRUD operations for the **LlmMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LlmMessages
    * const llmMessages = await prisma.llmMessage.findMany()
    * ```
    */
  get llmMessage(): Prisma.LlmMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.resume`: Exposes CRUD operations for the **Resume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resumes
    * const resumes = await prisma.resume.findMany()
    * ```
    */
  get resume(): Prisma.ResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extractedResume`: Exposes CRUD operations for the **ExtractedResume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtractedResumes
    * const extractedResumes = await prisma.extractedResume.findMany()
    * ```
    */
  get extractedResume(): Prisma.ExtractedResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extractedJobDescription`: Exposes CRUD operations for the **ExtractedJobDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtractedJobDescriptions
    * const extractedJobDescriptions = await prisma.extractedJobDescription.findMany()
    * ```
    */
  get extractedJobDescription(): Prisma.ExtractedJobDescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summarizedResume`: Exposes CRUD operations for the **SummarizedResume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummarizedResumes
    * const summarizedResumes = await prisma.summarizedResume.findMany()
    * ```
    */
  get summarizedResume(): Prisma.SummarizedResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.summarizedJobDescription`: Exposes CRUD operations for the **SummarizedJobDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SummarizedJobDescriptions
    * const summarizedJobDescriptions = await prisma.summarizedJobDescription.findMany()
    * ```
    */
  get summarizedJobDescription(): Prisma.SummarizedJobDescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedRoast`: Exposes CRUD operations for the **GeneratedRoast** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedRoasts
    * const generatedRoasts = await prisma.generatedRoast.findMany()
    * ```
    */
  get generatedRoast(): Prisma.GeneratedRoastDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedCoverLetter`: Exposes CRUD operations for the **GeneratedCoverLetter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedCoverLetters
    * const generatedCoverLetters = await prisma.generatedCoverLetter.findMany()
    * ```
    */
  get generatedCoverLetter(): Prisma.GeneratedCoverLetterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedResume`: Exposes CRUD operations for the **GeneratedResume** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedResumes
    * const generatedResumes = await prisma.generatedResume.findMany()
    * ```
    */
  get generatedResume(): Prisma.GeneratedResumeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.generatedInterviewPrep`: Exposes CRUD operations for the **GeneratedInterviewPrep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GeneratedInterviewPreps
    * const generatedInterviewPreps = await prisma.generatedInterviewPrep.findMany()
    * ```
    */
  get generatedInterviewPrep(): Prisma.GeneratedInterviewPrepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interviewEvaluation`: Exposes CRUD operations for the **InterviewEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewEvaluations
    * const interviewEvaluations = await prisma.interviewEvaluation.findMany()
    * ```
    */
  get interviewEvaluation(): Prisma.InterviewEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sharedAnalysis`: Exposes CRUD operations for the **SharedAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedAnalyses
    * const sharedAnalyses = await prisma.sharedAnalysis.findMany()
    * ```
    */
  get sharedAnalysis(): Prisma.SharedAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Announcements
    * const announcements = await prisma.announcement.findMany()
    * ```
    */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatbot`: Exposes CRUD operations for the **Chatbot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatbots
    * const chatbots = await prisma.chatbot.findMany()
    * ```
    */
  get chatbot(): Prisma.ChatbotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationMessage`: Exposes CRUD operations for the **ConversationMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationMessages
    * const conversationMessages = await prisma.conversationMessage.findMany()
    * ```
    */
  get conversationMessage(): Prisma.ConversationMessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    LlmCall: 'LlmCall',
    LlmMessage: 'LlmMessage',
    Resume: 'Resume',
    ExtractedResume: 'ExtractedResume',
    ExtractedJobDescription: 'ExtractedJobDescription',
    SummarizedResume: 'SummarizedResume',
    SummarizedJobDescription: 'SummarizedJobDescription',
    GeneratedRoast: 'GeneratedRoast',
    GeneratedCoverLetter: 'GeneratedCoverLetter',
    GeneratedResume: 'GeneratedResume',
    GeneratedInterviewPrep: 'GeneratedInterviewPrep',
    InterviewEvaluation: 'InterviewEvaluation',
    SharedAnalysis: 'SharedAnalysis',
    Invoice: 'Invoice',
    Announcement: 'Announcement',
    Chatbot: 'Chatbot',
    Conversation: 'Conversation',
    ConversationMessage: 'ConversationMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "verificationToken" | "llmCall" | "llmMessage" | "resume" | "extractedResume" | "extractedJobDescription" | "summarizedResume" | "summarizedJobDescription" | "generatedRoast" | "generatedCoverLetter" | "generatedResume" | "generatedInterviewPrep" | "interviewEvaluation" | "sharedAnalysis" | "invoice" | "announcement" | "chatbot" | "conversation" | "conversationMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      LlmCall: {
        payload: Prisma.$LlmCallPayload<ExtArgs>
        fields: Prisma.LlmCallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LlmCallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LlmCallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>
          }
          findFirst: {
            args: Prisma.LlmCallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LlmCallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>
          }
          findMany: {
            args: Prisma.LlmCallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>[]
          }
          create: {
            args: Prisma.LlmCallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>
          }
          createMany: {
            args: Prisma.LlmCallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LlmCallCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>[]
          }
          delete: {
            args: Prisma.LlmCallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>
          }
          update: {
            args: Prisma.LlmCallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>
          }
          deleteMany: {
            args: Prisma.LlmCallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LlmCallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LlmCallUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>[]
          }
          upsert: {
            args: Prisma.LlmCallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmCallPayload>
          }
          aggregate: {
            args: Prisma.LlmCallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLlmCall>
          }
          groupBy: {
            args: Prisma.LlmCallGroupByArgs<ExtArgs>
            result: $Utils.Optional<LlmCallGroupByOutputType>[]
          }
          count: {
            args: Prisma.LlmCallCountArgs<ExtArgs>
            result: $Utils.Optional<LlmCallCountAggregateOutputType> | number
          }
        }
      }
      LlmMessage: {
        payload: Prisma.$LlmMessagePayload<ExtArgs>
        fields: Prisma.LlmMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LlmMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LlmMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>
          }
          findFirst: {
            args: Prisma.LlmMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LlmMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>
          }
          findMany: {
            args: Prisma.LlmMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>[]
          }
          create: {
            args: Prisma.LlmMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>
          }
          createMany: {
            args: Prisma.LlmMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LlmMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>[]
          }
          delete: {
            args: Prisma.LlmMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>
          }
          update: {
            args: Prisma.LlmMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>
          }
          deleteMany: {
            args: Prisma.LlmMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LlmMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LlmMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>[]
          }
          upsert: {
            args: Prisma.LlmMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LlmMessagePayload>
          }
          aggregate: {
            args: Prisma.LlmMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLlmMessage>
          }
          groupBy: {
            args: Prisma.LlmMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LlmMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LlmMessageCountArgs<ExtArgs>
            result: $Utils.Optional<LlmMessageCountAggregateOutputType> | number
          }
        }
      }
      Resume: {
        payload: Prisma.$ResumePayload<ExtArgs>
        fields: Prisma.ResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findFirst: {
            args: Prisma.ResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          findMany: {
            args: Prisma.ResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          create: {
            args: Prisma.ResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          createMany: {
            args: Prisma.ResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          delete: {
            args: Prisma.ResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          update: {
            args: Prisma.ResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          deleteMany: {
            args: Prisma.ResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>[]
          }
          upsert: {
            args: Prisma.ResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResumePayload>
          }
          aggregate: {
            args: Prisma.ResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResume>
          }
          groupBy: {
            args: Prisma.ResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResumeCountArgs<ExtArgs>
            result: $Utils.Optional<ResumeCountAggregateOutputType> | number
          }
        }
      }
      ExtractedResume: {
        payload: Prisma.$ExtractedResumePayload<ExtArgs>
        fields: Prisma.ExtractedResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtractedResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtractedResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>
          }
          findFirst: {
            args: Prisma.ExtractedResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtractedResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>
          }
          findMany: {
            args: Prisma.ExtractedResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>[]
          }
          create: {
            args: Prisma.ExtractedResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>
          }
          createMany: {
            args: Prisma.ExtractedResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtractedResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>[]
          }
          delete: {
            args: Prisma.ExtractedResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>
          }
          update: {
            args: Prisma.ExtractedResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>
          }
          deleteMany: {
            args: Prisma.ExtractedResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExtractedResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExtractedResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>[]
          }
          upsert: {
            args: Prisma.ExtractedResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedResumePayload>
          }
          aggregate: {
            args: Prisma.ExtractedResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtractedResume>
          }
          groupBy: {
            args: Prisma.ExtractedResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtractedResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtractedResumeCountArgs<ExtArgs>
            result: $Utils.Optional<ExtractedResumeCountAggregateOutputType> | number
          }
        }
      }
      ExtractedJobDescription: {
        payload: Prisma.$ExtractedJobDescriptionPayload<ExtArgs>
        fields: Prisma.ExtractedJobDescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtractedJobDescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtractedJobDescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>
          }
          findFirst: {
            args: Prisma.ExtractedJobDescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtractedJobDescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>
          }
          findMany: {
            args: Prisma.ExtractedJobDescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>[]
          }
          create: {
            args: Prisma.ExtractedJobDescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>
          }
          createMany: {
            args: Prisma.ExtractedJobDescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtractedJobDescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>[]
          }
          delete: {
            args: Prisma.ExtractedJobDescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>
          }
          update: {
            args: Prisma.ExtractedJobDescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.ExtractedJobDescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExtractedJobDescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExtractedJobDescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>[]
          }
          upsert: {
            args: Prisma.ExtractedJobDescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtractedJobDescriptionPayload>
          }
          aggregate: {
            args: Prisma.ExtractedJobDescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtractedJobDescription>
          }
          groupBy: {
            args: Prisma.ExtractedJobDescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtractedJobDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtractedJobDescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ExtractedJobDescriptionCountAggregateOutputType> | number
          }
        }
      }
      SummarizedResume: {
        payload: Prisma.$SummarizedResumePayload<ExtArgs>
        fields: Prisma.SummarizedResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummarizedResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummarizedResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>
          }
          findFirst: {
            args: Prisma.SummarizedResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummarizedResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>
          }
          findMany: {
            args: Prisma.SummarizedResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>[]
          }
          create: {
            args: Prisma.SummarizedResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>
          }
          createMany: {
            args: Prisma.SummarizedResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummarizedResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>[]
          }
          delete: {
            args: Prisma.SummarizedResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>
          }
          update: {
            args: Prisma.SummarizedResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>
          }
          deleteMany: {
            args: Prisma.SummarizedResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummarizedResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummarizedResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>[]
          }
          upsert: {
            args: Prisma.SummarizedResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedResumePayload>
          }
          aggregate: {
            args: Prisma.SummarizedResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummarizedResume>
          }
          groupBy: {
            args: Prisma.SummarizedResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummarizedResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummarizedResumeCountArgs<ExtArgs>
            result: $Utils.Optional<SummarizedResumeCountAggregateOutputType> | number
          }
        }
      }
      SummarizedJobDescription: {
        payload: Prisma.$SummarizedJobDescriptionPayload<ExtArgs>
        fields: Prisma.SummarizedJobDescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SummarizedJobDescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SummarizedJobDescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>
          }
          findFirst: {
            args: Prisma.SummarizedJobDescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SummarizedJobDescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>
          }
          findMany: {
            args: Prisma.SummarizedJobDescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>[]
          }
          create: {
            args: Prisma.SummarizedJobDescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>
          }
          createMany: {
            args: Prisma.SummarizedJobDescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SummarizedJobDescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>[]
          }
          delete: {
            args: Prisma.SummarizedJobDescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>
          }
          update: {
            args: Prisma.SummarizedJobDescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.SummarizedJobDescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SummarizedJobDescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SummarizedJobDescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>[]
          }
          upsert: {
            args: Prisma.SummarizedJobDescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SummarizedJobDescriptionPayload>
          }
          aggregate: {
            args: Prisma.SummarizedJobDescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSummarizedJobDescription>
          }
          groupBy: {
            args: Prisma.SummarizedJobDescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SummarizedJobDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SummarizedJobDescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SummarizedJobDescriptionCountAggregateOutputType> | number
          }
        }
      }
      GeneratedRoast: {
        payload: Prisma.$GeneratedRoastPayload<ExtArgs>
        fields: Prisma.GeneratedRoastFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedRoastFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedRoastFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>
          }
          findFirst: {
            args: Prisma.GeneratedRoastFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedRoastFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>
          }
          findMany: {
            args: Prisma.GeneratedRoastFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>[]
          }
          create: {
            args: Prisma.GeneratedRoastCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>
          }
          createMany: {
            args: Prisma.GeneratedRoastCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedRoastCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>[]
          }
          delete: {
            args: Prisma.GeneratedRoastDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>
          }
          update: {
            args: Prisma.GeneratedRoastUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>
          }
          deleteMany: {
            args: Prisma.GeneratedRoastDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedRoastUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneratedRoastUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>[]
          }
          upsert: {
            args: Prisma.GeneratedRoastUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedRoastPayload>
          }
          aggregate: {
            args: Prisma.GeneratedRoastAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedRoast>
          }
          groupBy: {
            args: Prisma.GeneratedRoastGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedRoastGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedRoastCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedRoastCountAggregateOutputType> | number
          }
        }
      }
      GeneratedCoverLetter: {
        payload: Prisma.$GeneratedCoverLetterPayload<ExtArgs>
        fields: Prisma.GeneratedCoverLetterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedCoverLetterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedCoverLetterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>
          }
          findFirst: {
            args: Prisma.GeneratedCoverLetterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedCoverLetterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>
          }
          findMany: {
            args: Prisma.GeneratedCoverLetterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>[]
          }
          create: {
            args: Prisma.GeneratedCoverLetterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>
          }
          createMany: {
            args: Prisma.GeneratedCoverLetterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedCoverLetterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>[]
          }
          delete: {
            args: Prisma.GeneratedCoverLetterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>
          }
          update: {
            args: Prisma.GeneratedCoverLetterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>
          }
          deleteMany: {
            args: Prisma.GeneratedCoverLetterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedCoverLetterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneratedCoverLetterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>[]
          }
          upsert: {
            args: Prisma.GeneratedCoverLetterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedCoverLetterPayload>
          }
          aggregate: {
            args: Prisma.GeneratedCoverLetterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedCoverLetter>
          }
          groupBy: {
            args: Prisma.GeneratedCoverLetterGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedCoverLetterGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedCoverLetterCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedCoverLetterCountAggregateOutputType> | number
          }
        }
      }
      GeneratedResume: {
        payload: Prisma.$GeneratedResumePayload<ExtArgs>
        fields: Prisma.GeneratedResumeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedResumeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedResumeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>
          }
          findFirst: {
            args: Prisma.GeneratedResumeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedResumeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>
          }
          findMany: {
            args: Prisma.GeneratedResumeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>[]
          }
          create: {
            args: Prisma.GeneratedResumeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>
          }
          createMany: {
            args: Prisma.GeneratedResumeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedResumeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>[]
          }
          delete: {
            args: Prisma.GeneratedResumeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>
          }
          update: {
            args: Prisma.GeneratedResumeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>
          }
          deleteMany: {
            args: Prisma.GeneratedResumeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedResumeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneratedResumeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>[]
          }
          upsert: {
            args: Prisma.GeneratedResumeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedResumePayload>
          }
          aggregate: {
            args: Prisma.GeneratedResumeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedResume>
          }
          groupBy: {
            args: Prisma.GeneratedResumeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedResumeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedResumeCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedResumeCountAggregateOutputType> | number
          }
        }
      }
      GeneratedInterviewPrep: {
        payload: Prisma.$GeneratedInterviewPrepPayload<ExtArgs>
        fields: Prisma.GeneratedInterviewPrepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneratedInterviewPrepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneratedInterviewPrepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>
          }
          findFirst: {
            args: Prisma.GeneratedInterviewPrepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneratedInterviewPrepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>
          }
          findMany: {
            args: Prisma.GeneratedInterviewPrepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>[]
          }
          create: {
            args: Prisma.GeneratedInterviewPrepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>
          }
          createMany: {
            args: Prisma.GeneratedInterviewPrepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneratedInterviewPrepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>[]
          }
          delete: {
            args: Prisma.GeneratedInterviewPrepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>
          }
          update: {
            args: Prisma.GeneratedInterviewPrepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>
          }
          deleteMany: {
            args: Prisma.GeneratedInterviewPrepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneratedInterviewPrepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneratedInterviewPrepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>[]
          }
          upsert: {
            args: Prisma.GeneratedInterviewPrepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneratedInterviewPrepPayload>
          }
          aggregate: {
            args: Prisma.GeneratedInterviewPrepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGeneratedInterviewPrep>
          }
          groupBy: {
            args: Prisma.GeneratedInterviewPrepGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneratedInterviewPrepGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneratedInterviewPrepCountArgs<ExtArgs>
            result: $Utils.Optional<GeneratedInterviewPrepCountAggregateOutputType> | number
          }
        }
      }
      InterviewEvaluation: {
        payload: Prisma.$InterviewEvaluationPayload<ExtArgs>
        fields: Prisma.InterviewEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          findFirst: {
            args: Prisma.InterviewEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          findMany: {
            args: Prisma.InterviewEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>[]
          }
          create: {
            args: Prisma.InterviewEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          createMany: {
            args: Prisma.InterviewEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>[]
          }
          delete: {
            args: Prisma.InterviewEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          update: {
            args: Prisma.InterviewEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.InterviewEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterviewEvaluationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>[]
          }
          upsert: {
            args: Prisma.InterviewEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewEvaluationPayload>
          }
          aggregate: {
            args: Prisma.InterviewEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewEvaluation>
          }
          groupBy: {
            args: Prisma.InterviewEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewEvaluationCountAggregateOutputType> | number
          }
        }
      }
      SharedAnalysis: {
        payload: Prisma.$SharedAnalysisPayload<ExtArgs>
        fields: Prisma.SharedAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>
          }
          findFirst: {
            args: Prisma.SharedAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>
          }
          findMany: {
            args: Prisma.SharedAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>[]
          }
          create: {
            args: Prisma.SharedAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>
          }
          createMany: {
            args: Prisma.SharedAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>[]
          }
          delete: {
            args: Prisma.SharedAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>
          }
          update: {
            args: Prisma.SharedAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.SharedAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SharedAnalysisUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>[]
          }
          upsert: {
            args: Prisma.SharedAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedAnalysisPayload>
          }
          aggregate: {
            args: Prisma.SharedAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedAnalysis>
          }
          groupBy: {
            args: Prisma.SharedAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<SharedAnalysisCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>
        fields: Prisma.AnnouncementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
          }
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>
          }
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnouncement>
          }
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>
            result: $Utils.Optional<AnnouncementCountAggregateOutputType> | number
          }
        }
      }
      Chatbot: {
        payload: Prisma.$ChatbotPayload<ExtArgs>
        fields: Prisma.ChatbotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatbotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatbotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>
          }
          findFirst: {
            args: Prisma.ChatbotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatbotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>
          }
          findMany: {
            args: Prisma.ChatbotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>[]
          }
          create: {
            args: Prisma.ChatbotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>
          }
          createMany: {
            args: Prisma.ChatbotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatbotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>[]
          }
          delete: {
            args: Prisma.ChatbotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>
          }
          update: {
            args: Prisma.ChatbotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>
          }
          deleteMany: {
            args: Prisma.ChatbotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatbotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatbotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>[]
          }
          upsert: {
            args: Prisma.ChatbotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatbotPayload>
          }
          aggregate: {
            args: Prisma.ChatbotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatbot>
          }
          groupBy: {
            args: Prisma.ChatbotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatbotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatbotCountArgs<ExtArgs>
            result: $Utils.Optional<ChatbotCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationMessage: {
        payload: Prisma.$ConversationMessagePayload<ExtArgs>
        fields: Prisma.ConversationMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          findFirst: {
            args: Prisma.ConversationMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          findMany: {
            args: Prisma.ConversationMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          create: {
            args: Prisma.ConversationMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          createMany: {
            args: Prisma.ConversationMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          delete: {
            args: Prisma.ConversationMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          update: {
            args: Prisma.ConversationMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          deleteMany: {
            args: Prisma.ConversationMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>[]
          }
          upsert: {
            args: Prisma.ConversationMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationMessagePayload>
          }
          aggregate: {
            args: Prisma.ConversationMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationMessage>
          }
          groupBy: {
            args: Prisma.ConversationMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    llmCall?: LlmCallOmit
    llmMessage?: LlmMessageOmit
    resume?: ResumeOmit
    extractedResume?: ExtractedResumeOmit
    extractedJobDescription?: ExtractedJobDescriptionOmit
    summarizedResume?: SummarizedResumeOmit
    summarizedJobDescription?: SummarizedJobDescriptionOmit
    generatedRoast?: GeneratedRoastOmit
    generatedCoverLetter?: GeneratedCoverLetterOmit
    generatedResume?: GeneratedResumeOmit
    generatedInterviewPrep?: GeneratedInterviewPrepOmit
    interviewEvaluation?: InterviewEvaluationOmit
    sharedAnalysis?: SharedAnalysisOmit
    invoice?: InvoiceOmit
    announcement?: AnnouncementOmit
    chatbot?: ChatbotOmit
    conversation?: ConversationOmit
    conversationMessage?: ConversationMessageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    llmCalls: number
    resumes: number
    generatedRoasts: number
    generatedCoverLetters: number
    generatedResumes: number
    generatedInterviewPreps: number
    interviewEvaluations: number
    sharedAnalyses: number
    invoices: number
    chatbot: number
    verificationTokens: number
    conversations: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    llmCalls?: boolean | UserCountOutputTypeCountLlmCallsArgs
    resumes?: boolean | UserCountOutputTypeCountResumesArgs
    generatedRoasts?: boolean | UserCountOutputTypeCountGeneratedRoastsArgs
    generatedCoverLetters?: boolean | UserCountOutputTypeCountGeneratedCoverLettersArgs
    generatedResumes?: boolean | UserCountOutputTypeCountGeneratedResumesArgs
    generatedInterviewPreps?: boolean | UserCountOutputTypeCountGeneratedInterviewPrepsArgs
    interviewEvaluations?: boolean | UserCountOutputTypeCountInterviewEvaluationsArgs
    sharedAnalyses?: boolean | UserCountOutputTypeCountSharedAnalysesArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    chatbot?: boolean | UserCountOutputTypeCountChatbotArgs
    verificationTokens?: boolean | UserCountOutputTypeCountVerificationTokensArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedRoastWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedCoverLetterWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResumeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGeneratedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedInterviewPrepWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterviewEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewEvaluationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAnalysisWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatbotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type LlmCallCountOutputType
   */

  export type LlmCallCountOutputType = {
    messages: number
  }

  export type LlmCallCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | LlmCallCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * LlmCallCountOutputType without action
   */
  export type LlmCallCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCallCountOutputType
     */
    select?: LlmCallCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LlmCallCountOutputType without action
   */
  export type LlmCallCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmMessageWhereInput
  }


  /**
   * Count Type ResumeCountOutputType
   */

  export type ResumeCountOutputType = {
    llmCalls: number
    extractedResumes: number
    generatedRoasts: number
    generatedCoverLetters: number
  }

  export type ResumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | ResumeCountOutputTypeCountLlmCallsArgs
    extractedResumes?: boolean | ResumeCountOutputTypeCountExtractedResumesArgs
    generatedRoasts?: boolean | ResumeCountOutputTypeCountGeneratedRoastsArgs
    generatedCoverLetters?: boolean | ResumeCountOutputTypeCountGeneratedCoverLettersArgs
  }

  // Custom InputTypes
  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResumeCountOutputType
     */
    select?: ResumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountExtractedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtractedResumeWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountGeneratedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedRoastWhereInput
  }

  /**
   * ResumeCountOutputType without action
   */
  export type ResumeCountOutputTypeCountGeneratedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedCoverLetterWhereInput
  }


  /**
   * Count Type ExtractedResumeCountOutputType
   */

  export type ExtractedResumeCountOutputType = {
    llmCalls: number
    summarizedResumes: number
    generatedRoasts: number
    generatedCoverLetters: number
    generatedResumes: number
    generatedInterviewPreps: number
  }

  export type ExtractedResumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | ExtractedResumeCountOutputTypeCountLlmCallsArgs
    summarizedResumes?: boolean | ExtractedResumeCountOutputTypeCountSummarizedResumesArgs
    generatedRoasts?: boolean | ExtractedResumeCountOutputTypeCountGeneratedRoastsArgs
    generatedCoverLetters?: boolean | ExtractedResumeCountOutputTypeCountGeneratedCoverLettersArgs
    generatedResumes?: boolean | ExtractedResumeCountOutputTypeCountGeneratedResumesArgs
    generatedInterviewPreps?: boolean | ExtractedResumeCountOutputTypeCountGeneratedInterviewPrepsArgs
  }

  // Custom InputTypes
  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResumeCountOutputType
     */
    select?: ExtractedResumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }

  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeCountSummarizedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummarizedResumeWhereInput
  }

  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeCountGeneratedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedRoastWhereInput
  }

  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeCountGeneratedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedCoverLetterWhereInput
  }

  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeCountGeneratedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResumeWhereInput
  }

  /**
   * ExtractedResumeCountOutputType without action
   */
  export type ExtractedResumeCountOutputTypeCountGeneratedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedInterviewPrepWhereInput
  }


  /**
   * Count Type ExtractedJobDescriptionCountOutputType
   */

  export type ExtractedJobDescriptionCountOutputType = {
    llmCalls: number
    summarizedJobDescriptions: number
    generatedRoasts: number
    generatedCoverLetters: number
    generatedResumes: number
    generatedInterviewPreps: number
  }

  export type ExtractedJobDescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | ExtractedJobDescriptionCountOutputTypeCountLlmCallsArgs
    summarizedJobDescriptions?: boolean | ExtractedJobDescriptionCountOutputTypeCountSummarizedJobDescriptionsArgs
    generatedRoasts?: boolean | ExtractedJobDescriptionCountOutputTypeCountGeneratedRoastsArgs
    generatedCoverLetters?: boolean | ExtractedJobDescriptionCountOutputTypeCountGeneratedCoverLettersArgs
    generatedResumes?: boolean | ExtractedJobDescriptionCountOutputTypeCountGeneratedResumesArgs
    generatedInterviewPreps?: boolean | ExtractedJobDescriptionCountOutputTypeCountGeneratedInterviewPrepsArgs
  }

  // Custom InputTypes
  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescriptionCountOutputType
     */
    select?: ExtractedJobDescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }

  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeCountSummarizedJobDescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummarizedJobDescriptionWhereInput
  }

  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeCountGeneratedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedRoastWhereInput
  }

  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeCountGeneratedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedCoverLetterWhereInput
  }

  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeCountGeneratedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResumeWhereInput
  }

  /**
   * ExtractedJobDescriptionCountOutputType without action
   */
  export type ExtractedJobDescriptionCountOutputTypeCountGeneratedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedInterviewPrepWhereInput
  }


  /**
   * Count Type GeneratedRoastCountOutputType
   */

  export type GeneratedRoastCountOutputType = {
    llmCalls: number
    sharedAnalyses: number
    generatedCoverLetters: number
    generatedResumes: number
    generatedInterviewPreps: number
  }

  export type GeneratedRoastCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | GeneratedRoastCountOutputTypeCountLlmCallsArgs
    sharedAnalyses?: boolean | GeneratedRoastCountOutputTypeCountSharedAnalysesArgs
    generatedCoverLetters?: boolean | GeneratedRoastCountOutputTypeCountGeneratedCoverLettersArgs
    generatedResumes?: boolean | GeneratedRoastCountOutputTypeCountGeneratedResumesArgs
    generatedInterviewPreps?: boolean | GeneratedRoastCountOutputTypeCountGeneratedInterviewPrepsArgs
  }

  // Custom InputTypes
  /**
   * GeneratedRoastCountOutputType without action
   */
  export type GeneratedRoastCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoastCountOutputType
     */
    select?: GeneratedRoastCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneratedRoastCountOutputType without action
   */
  export type GeneratedRoastCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }

  /**
   * GeneratedRoastCountOutputType without action
   */
  export type GeneratedRoastCountOutputTypeCountSharedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAnalysisWhereInput
  }

  /**
   * GeneratedRoastCountOutputType without action
   */
  export type GeneratedRoastCountOutputTypeCountGeneratedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedCoverLetterWhereInput
  }

  /**
   * GeneratedRoastCountOutputType without action
   */
  export type GeneratedRoastCountOutputTypeCountGeneratedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResumeWhereInput
  }

  /**
   * GeneratedRoastCountOutputType without action
   */
  export type GeneratedRoastCountOutputTypeCountGeneratedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedInterviewPrepWhereInput
  }


  /**
   * Count Type GeneratedCoverLetterCountOutputType
   */

  export type GeneratedCoverLetterCountOutputType = {
    llmCalls: number
  }

  export type GeneratedCoverLetterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | GeneratedCoverLetterCountOutputTypeCountLlmCallsArgs
  }

  // Custom InputTypes
  /**
   * GeneratedCoverLetterCountOutputType without action
   */
  export type GeneratedCoverLetterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetterCountOutputType
     */
    select?: GeneratedCoverLetterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneratedCoverLetterCountOutputType without action
   */
  export type GeneratedCoverLetterCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }


  /**
   * Count Type GeneratedResumeCountOutputType
   */

  export type GeneratedResumeCountOutputType = {
    llmCalls: number
  }

  export type GeneratedResumeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | GeneratedResumeCountOutputTypeCountLlmCallsArgs
  }

  // Custom InputTypes
  /**
   * GeneratedResumeCountOutputType without action
   */
  export type GeneratedResumeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResumeCountOutputType
     */
    select?: GeneratedResumeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneratedResumeCountOutputType without action
   */
  export type GeneratedResumeCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }


  /**
   * Count Type GeneratedInterviewPrepCountOutputType
   */

  export type GeneratedInterviewPrepCountOutputType = {
    llmCalls: number
    evaluations: number
  }

  export type GeneratedInterviewPrepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | GeneratedInterviewPrepCountOutputTypeCountLlmCallsArgs
    evaluations?: boolean | GeneratedInterviewPrepCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * GeneratedInterviewPrepCountOutputType without action
   */
  export type GeneratedInterviewPrepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrepCountOutputType
     */
    select?: GeneratedInterviewPrepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneratedInterviewPrepCountOutputType without action
   */
  export type GeneratedInterviewPrepCountOutputTypeCountLlmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
  }

  /**
   * GeneratedInterviewPrepCountOutputType without action
   */
  export type GeneratedInterviewPrepCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewEvaluationWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    monthlyRoasts: number | null
    totalRoasts: number | null
    bonusCredits: number | null
  }

  export type UserSumAggregateOutputType = {
    monthlyRoasts: number | null
    totalRoasts: number | null
    bonusCredits: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    emailVerified: Date | null
    image: string | null
    hashedPassword: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    subscriptionId: string | null
    customerId: string | null
    subscriptionEndsAt: Date | null
    monthlyRoasts: number | null
    totalRoasts: number | null
    bonusCredits: number | null
    lastRoastReset: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    emailVerified: Date | null
    image: string | null
    hashedPassword: string | null
    subscriptionTier: $Enums.SubscriptionTier | null
    subscriptionId: string | null
    customerId: string | null
    subscriptionEndsAt: Date | null
    monthlyRoasts: number | null
    totalRoasts: number | null
    bonusCredits: number | null
    lastRoastReset: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    emailVerified: number
    image: number
    hashedPassword: number
    subscriptionTier: number
    subscriptionId: number
    customerId: number
    subscriptionEndsAt: number
    monthlyRoasts: number
    totalRoasts: number
    bonusCredits: number
    lastRoastReset: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    monthlyRoasts?: true
    totalRoasts?: true
    bonusCredits?: true
  }

  export type UserSumAggregateInputType = {
    monthlyRoasts?: true
    totalRoasts?: true
    bonusCredits?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    emailVerified?: true
    image?: true
    hashedPassword?: true
    subscriptionTier?: true
    subscriptionId?: true
    customerId?: true
    subscriptionEndsAt?: true
    monthlyRoasts?: true
    totalRoasts?: true
    bonusCredits?: true
    lastRoastReset?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    emailVerified?: true
    image?: true
    hashedPassword?: true
    subscriptionTier?: true
    subscriptionId?: true
    customerId?: true
    subscriptionEndsAt?: true
    monthlyRoasts?: true
    totalRoasts?: true
    bonusCredits?: true
    lastRoastReset?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    emailVerified?: true
    image?: true
    hashedPassword?: true
    subscriptionTier?: true
    subscriptionId?: true
    customerId?: true
    subscriptionEndsAt?: true
    monthlyRoasts?: true
    totalRoasts?: true
    bonusCredits?: true
    lastRoastReset?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    emailVerified: Date | null
    image: string | null
    hashedPassword: string | null
    subscriptionTier: $Enums.SubscriptionTier
    subscriptionId: string | null
    customerId: string | null
    subscriptionEndsAt: Date | null
    monthlyRoasts: number
    totalRoasts: number
    bonusCredits: number
    lastRoastReset: Date
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    subscriptionTier?: boolean
    subscriptionId?: boolean
    customerId?: boolean
    subscriptionEndsAt?: boolean
    monthlyRoasts?: boolean
    totalRoasts?: boolean
    bonusCredits?: boolean
    lastRoastReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    llmCalls?: boolean | User$llmCallsArgs<ExtArgs>
    resumes?: boolean | User$resumesArgs<ExtArgs>
    generatedRoasts?: boolean | User$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | User$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | User$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | User$generatedInterviewPrepsArgs<ExtArgs>
    interviewEvaluations?: boolean | User$interviewEvaluationsArgs<ExtArgs>
    sharedAnalyses?: boolean | User$sharedAnalysesArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    chatbot?: boolean | User$chatbotArgs<ExtArgs>
    verificationTokens?: boolean | User$verificationTokensArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    subscriptionTier?: boolean
    subscriptionId?: boolean
    customerId?: boolean
    subscriptionEndsAt?: boolean
    monthlyRoasts?: boolean
    totalRoasts?: boolean
    bonusCredits?: boolean
    lastRoastReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    subscriptionTier?: boolean
    subscriptionId?: boolean
    customerId?: boolean
    subscriptionEndsAt?: boolean
    monthlyRoasts?: boolean
    totalRoasts?: boolean
    bonusCredits?: boolean
    lastRoastReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    emailVerified?: boolean
    image?: boolean
    hashedPassword?: boolean
    subscriptionTier?: boolean
    subscriptionId?: boolean
    customerId?: boolean
    subscriptionEndsAt?: boolean
    monthlyRoasts?: boolean
    totalRoasts?: boolean
    bonusCredits?: boolean
    lastRoastReset?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "emailVerified" | "image" | "hashedPassword" | "subscriptionTier" | "subscriptionId" | "customerId" | "subscriptionEndsAt" | "monthlyRoasts" | "totalRoasts" | "bonusCredits" | "lastRoastReset" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    llmCalls?: boolean | User$llmCallsArgs<ExtArgs>
    resumes?: boolean | User$resumesArgs<ExtArgs>
    generatedRoasts?: boolean | User$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | User$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | User$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | User$generatedInterviewPrepsArgs<ExtArgs>
    interviewEvaluations?: boolean | User$interviewEvaluationsArgs<ExtArgs>
    sharedAnalyses?: boolean | User$sharedAnalysesArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    chatbot?: boolean | User$chatbotArgs<ExtArgs>
    verificationTokens?: boolean | User$verificationTokensArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
      resumes: Prisma.$ResumePayload<ExtArgs>[]
      generatedRoasts: Prisma.$GeneratedRoastPayload<ExtArgs>[]
      generatedCoverLetters: Prisma.$GeneratedCoverLetterPayload<ExtArgs>[]
      generatedResumes: Prisma.$GeneratedResumePayload<ExtArgs>[]
      generatedInterviewPreps: Prisma.$GeneratedInterviewPrepPayload<ExtArgs>[]
      interviewEvaluations: Prisma.$InterviewEvaluationPayload<ExtArgs>[]
      sharedAnalyses: Prisma.$SharedAnalysisPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      chatbot: Prisma.$ChatbotPayload<ExtArgs>[]
      verificationTokens: Prisma.$VerificationTokenPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      emailVerified: Date | null
      image: string | null
      hashedPassword: string | null
      subscriptionTier: $Enums.SubscriptionTier
      subscriptionId: string | null
      customerId: string | null
      subscriptionEndsAt: Date | null
      monthlyRoasts: number
      totalRoasts: number
      bonusCredits: number
      lastRoastReset: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    llmCalls<T extends User$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, User$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resumes<T extends User$resumesArgs<ExtArgs> = {}>(args?: Subset<T, User$resumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedRoasts<T extends User$generatedRoastsArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedRoastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedCoverLetters<T extends User$generatedCoverLettersArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedCoverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedResumes<T extends User$generatedResumesArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedResumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedInterviewPreps<T extends User$generatedInterviewPrepsArgs<ExtArgs> = {}>(args?: Subset<T, User$generatedInterviewPrepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interviewEvaluations<T extends User$interviewEvaluationsArgs<ExtArgs> = {}>(args?: Subset<T, User$interviewEvaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedAnalyses<T extends User$sharedAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatbot<T extends User$chatbotArgs<ExtArgs> = {}>(args?: Subset<T, User$chatbotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verificationTokens<T extends User$verificationTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$verificationTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly subscriptionTier: FieldRef<"User", 'SubscriptionTier'>
    readonly subscriptionId: FieldRef<"User", 'String'>
    readonly customerId: FieldRef<"User", 'String'>
    readonly subscriptionEndsAt: FieldRef<"User", 'DateTime'>
    readonly monthlyRoasts: FieldRef<"User", 'Int'>
    readonly totalRoasts: FieldRef<"User", 'Int'>
    readonly bonusCredits: FieldRef<"User", 'Int'>
    readonly lastRoastReset: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.llmCalls
   */
  export type User$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * User.resumes
   */
  export type User$resumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    cursor?: ResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * User.generatedRoasts
   */
  export type User$generatedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    cursor?: GeneratedRoastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * User.generatedCoverLetters
   */
  export type User$generatedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    where?: GeneratedCoverLetterWhereInput
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    cursor?: GeneratedCoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * User.generatedResumes
   */
  export type User$generatedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    where?: GeneratedResumeWhereInput
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    cursor?: GeneratedResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * User.generatedInterviewPreps
   */
  export type User$generatedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    where?: GeneratedInterviewPrepWhereInput
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * User.interviewEvaluations
   */
  export type User$interviewEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    where?: InterviewEvaluationWhereInput
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    cursor?: InterviewEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * User.sharedAnalyses
   */
  export type User$sharedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    where?: SharedAnalysisWhereInput
    orderBy?: SharedAnalysisOrderByWithRelationInput | SharedAnalysisOrderByWithRelationInput[]
    cursor?: SharedAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAnalysisScalarFieldEnum | SharedAnalysisScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.chatbot
   */
  export type User$chatbotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    where?: ChatbotWhereInput
    orderBy?: ChatbotOrderByWithRelationInput | ChatbotOrderByWithRelationInput[]
    cursor?: ChatbotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatbotScalarFieldEnum | ChatbotScalarFieldEnum[]
  }

  /**
   * User.verificationTokens
   */
  export type User$verificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    cursor?: VerificationTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    type: $Enums.VerificationTokenType | null
    expiresAt: Date | null
    createdAt: Date | null
    usedAt: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    type: $Enums.VerificationTokenType | null
    expiresAt: Date | null
    createdAt: Date | null
    usedAt: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    type: number
    expiresAt: number
    createdAt: number
    usedAt: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    type?: true
    expiresAt?: true
    createdAt?: true
    usedAt?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    type?: true
    expiresAt?: true
    createdAt?: true
    usedAt?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    type?: true
    expiresAt?: true
    createdAt?: true
    usedAt?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date
    createdAt: Date
    usedAt: Date | null
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    type?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    type?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    type?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    type?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    usedAt?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "type" | "expiresAt" | "createdAt" | "usedAt", ExtArgs["result"]["verificationToken"]>
  export type VerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type VerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      type: $Enums.VerificationTokenType
      expiresAt: Date
      createdAt: Date
      usedAt: Date | null
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly userId: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly type: FieldRef<"VerificationToken", 'VerificationTokenType'>
    readonly expiresAt: FieldRef<"VerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"VerificationToken", 'DateTime'>
    readonly usedAt: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model LlmCall
   */

  export type AggregateLlmCall = {
    _count: LlmCallCountAggregateOutputType | null
    _avg: LlmCallAvgAggregateOutputType | null
    _sum: LlmCallSumAggregateOutputType | null
    _min: LlmCallMinAggregateOutputType | null
    _max: LlmCallMaxAggregateOutputType | null
  }

  export type LlmCallAvgAggregateOutputType = {
    totalInputTokens: number | null
    totalOutputTokens: number | null
    totalTokens: number | null
    totalCostUsd: Decimal | null
    totalProcessingTimeMs: number | null
  }

  export type LlmCallSumAggregateOutputType = {
    totalInputTokens: number | null
    totalOutputTokens: number | null
    totalTokens: number | null
    totalCostUsd: Decimal | null
    totalProcessingTimeMs: number | null
  }

  export type LlmCallMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    model: string | null
    operationType: string | null
    totalInputTokens: number | null
    totalOutputTokens: number | null
    totalTokens: number | null
    totalCostUsd: Decimal | null
    totalProcessingTimeMs: number | null
    status: $Enums.LlmCallStatus | null
    errorMessage: string | null
    resumeId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    generatedRoastId: string | null
    generatedCoverLetterId: string | null
    generatedResumeId: string | null
    generatedInterviewPrepId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type LlmCallMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    model: string | null
    operationType: string | null
    totalInputTokens: number | null
    totalOutputTokens: number | null
    totalTokens: number | null
    totalCostUsd: Decimal | null
    totalProcessingTimeMs: number | null
    status: $Enums.LlmCallStatus | null
    errorMessage: string | null
    resumeId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    generatedRoastId: string | null
    generatedCoverLetterId: string | null
    generatedResumeId: string | null
    generatedInterviewPrepId: string | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type LlmCallCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    model: number
    operationType: number
    totalInputTokens: number
    totalOutputTokens: number
    totalTokens: number
    totalCostUsd: number
    totalProcessingTimeMs: number
    status: number
    errorMessage: number
    resumeId: number
    extractedResumeId: number
    extractedJobId: number
    generatedRoastId: number
    generatedCoverLetterId: number
    generatedResumeId: number
    generatedInterviewPrepId: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type LlmCallAvgAggregateInputType = {
    totalInputTokens?: true
    totalOutputTokens?: true
    totalTokens?: true
    totalCostUsd?: true
    totalProcessingTimeMs?: true
  }

  export type LlmCallSumAggregateInputType = {
    totalInputTokens?: true
    totalOutputTokens?: true
    totalTokens?: true
    totalCostUsd?: true
    totalProcessingTimeMs?: true
  }

  export type LlmCallMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    model?: true
    operationType?: true
    totalInputTokens?: true
    totalOutputTokens?: true
    totalTokens?: true
    totalCostUsd?: true
    totalProcessingTimeMs?: true
    status?: true
    errorMessage?: true
    resumeId?: true
    extractedResumeId?: true
    extractedJobId?: true
    generatedRoastId?: true
    generatedCoverLetterId?: true
    generatedResumeId?: true
    generatedInterviewPrepId?: true
    createdAt?: true
    completedAt?: true
  }

  export type LlmCallMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    model?: true
    operationType?: true
    totalInputTokens?: true
    totalOutputTokens?: true
    totalTokens?: true
    totalCostUsd?: true
    totalProcessingTimeMs?: true
    status?: true
    errorMessage?: true
    resumeId?: true
    extractedResumeId?: true
    extractedJobId?: true
    generatedRoastId?: true
    generatedCoverLetterId?: true
    generatedResumeId?: true
    generatedInterviewPrepId?: true
    createdAt?: true
    completedAt?: true
  }

  export type LlmCallCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    model?: true
    operationType?: true
    totalInputTokens?: true
    totalOutputTokens?: true
    totalTokens?: true
    totalCostUsd?: true
    totalProcessingTimeMs?: true
    status?: true
    errorMessage?: true
    resumeId?: true
    extractedResumeId?: true
    extractedJobId?: true
    generatedRoastId?: true
    generatedCoverLetterId?: true
    generatedResumeId?: true
    generatedInterviewPrepId?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type LlmCallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LlmCall to aggregate.
     */
    where?: LlmCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmCalls to fetch.
     */
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LlmCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LlmCalls
    **/
    _count?: true | LlmCallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LlmCallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LlmCallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LlmCallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LlmCallMaxAggregateInputType
  }

  export type GetLlmCallAggregateType<T extends LlmCallAggregateArgs> = {
        [P in keyof T & keyof AggregateLlmCall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLlmCall[P]>
      : GetScalarType<T[P], AggregateLlmCall[P]>
  }




  export type LlmCallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithAggregationInput | LlmCallOrderByWithAggregationInput[]
    by: LlmCallScalarFieldEnum[] | LlmCallScalarFieldEnum
    having?: LlmCallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LlmCallCountAggregateInputType | true
    _avg?: LlmCallAvgAggregateInputType
    _sum?: LlmCallSumAggregateInputType
    _min?: LlmCallMinAggregateInputType
    _max?: LlmCallMaxAggregateInputType
  }

  export type LlmCallGroupByOutputType = {
    id: string
    userId: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens: number
    totalOutputTokens: number
    totalTokens: number
    totalCostUsd: Decimal
    totalProcessingTimeMs: number | null
    status: $Enums.LlmCallStatus
    errorMessage: string | null
    resumeId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    generatedRoastId: string | null
    generatedCoverLetterId: string | null
    generatedResumeId: string | null
    generatedInterviewPrepId: string | null
    createdAt: Date
    completedAt: Date | null
    _count: LlmCallCountAggregateOutputType | null
    _avg: LlmCallAvgAggregateOutputType | null
    _sum: LlmCallSumAggregateOutputType | null
    _min: LlmCallMinAggregateOutputType | null
    _max: LlmCallMaxAggregateOutputType | null
  }

  type GetLlmCallGroupByPayload<T extends LlmCallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LlmCallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LlmCallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LlmCallGroupByOutputType[P]>
            : GetScalarType<T[P], LlmCallGroupByOutputType[P]>
        }
      >
    >


  export type LlmCallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    totalInputTokens?: boolean
    totalOutputTokens?: boolean
    totalTokens?: boolean
    totalCostUsd?: boolean
    totalProcessingTimeMs?: boolean
    status?: boolean
    errorMessage?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    generatedRoastId?: boolean
    generatedCoverLetterId?: boolean
    generatedResumeId?: boolean
    generatedInterviewPrepId?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | LlmCall$userArgs<ExtArgs>
    resume?: boolean | LlmCall$resumeArgs<ExtArgs>
    extractedResume?: boolean | LlmCall$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | LlmCall$extractedJobArgs<ExtArgs>
    generatedRoast?: boolean | LlmCall$generatedRoastArgs<ExtArgs>
    generatedCoverLetter?: boolean | LlmCall$generatedCoverLetterArgs<ExtArgs>
    generatedResume?: boolean | LlmCall$generatedResumeArgs<ExtArgs>
    generatedInterviewPrep?: boolean | LlmCall$generatedInterviewPrepArgs<ExtArgs>
    messages?: boolean | LlmCall$messagesArgs<ExtArgs>
    _count?: boolean | LlmCallCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["llmCall"]>

  export type LlmCallSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    totalInputTokens?: boolean
    totalOutputTokens?: boolean
    totalTokens?: boolean
    totalCostUsd?: boolean
    totalProcessingTimeMs?: boolean
    status?: boolean
    errorMessage?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    generatedRoastId?: boolean
    generatedCoverLetterId?: boolean
    generatedResumeId?: boolean
    generatedInterviewPrepId?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | LlmCall$userArgs<ExtArgs>
    resume?: boolean | LlmCall$resumeArgs<ExtArgs>
    extractedResume?: boolean | LlmCall$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | LlmCall$extractedJobArgs<ExtArgs>
    generatedRoast?: boolean | LlmCall$generatedRoastArgs<ExtArgs>
    generatedCoverLetter?: boolean | LlmCall$generatedCoverLetterArgs<ExtArgs>
    generatedResume?: boolean | LlmCall$generatedResumeArgs<ExtArgs>
    generatedInterviewPrep?: boolean | LlmCall$generatedInterviewPrepArgs<ExtArgs>
  }, ExtArgs["result"]["llmCall"]>

  export type LlmCallSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    totalInputTokens?: boolean
    totalOutputTokens?: boolean
    totalTokens?: boolean
    totalCostUsd?: boolean
    totalProcessingTimeMs?: boolean
    status?: boolean
    errorMessage?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    generatedRoastId?: boolean
    generatedCoverLetterId?: boolean
    generatedResumeId?: boolean
    generatedInterviewPrepId?: boolean
    createdAt?: boolean
    completedAt?: boolean
    user?: boolean | LlmCall$userArgs<ExtArgs>
    resume?: boolean | LlmCall$resumeArgs<ExtArgs>
    extractedResume?: boolean | LlmCall$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | LlmCall$extractedJobArgs<ExtArgs>
    generatedRoast?: boolean | LlmCall$generatedRoastArgs<ExtArgs>
    generatedCoverLetter?: boolean | LlmCall$generatedCoverLetterArgs<ExtArgs>
    generatedResume?: boolean | LlmCall$generatedResumeArgs<ExtArgs>
    generatedInterviewPrep?: boolean | LlmCall$generatedInterviewPrepArgs<ExtArgs>
  }, ExtArgs["result"]["llmCall"]>

  export type LlmCallSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    operationType?: boolean
    totalInputTokens?: boolean
    totalOutputTokens?: boolean
    totalTokens?: boolean
    totalCostUsd?: boolean
    totalProcessingTimeMs?: boolean
    status?: boolean
    errorMessage?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    generatedRoastId?: boolean
    generatedCoverLetterId?: boolean
    generatedResumeId?: boolean
    generatedInterviewPrepId?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type LlmCallOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "model" | "operationType" | "totalInputTokens" | "totalOutputTokens" | "totalTokens" | "totalCostUsd" | "totalProcessingTimeMs" | "status" | "errorMessage" | "resumeId" | "extractedResumeId" | "extractedJobId" | "generatedRoastId" | "generatedCoverLetterId" | "generatedResumeId" | "generatedInterviewPrepId" | "createdAt" | "completedAt", ExtArgs["result"]["llmCall"]>
  export type LlmCallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LlmCall$userArgs<ExtArgs>
    resume?: boolean | LlmCall$resumeArgs<ExtArgs>
    extractedResume?: boolean | LlmCall$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | LlmCall$extractedJobArgs<ExtArgs>
    generatedRoast?: boolean | LlmCall$generatedRoastArgs<ExtArgs>
    generatedCoverLetter?: boolean | LlmCall$generatedCoverLetterArgs<ExtArgs>
    generatedResume?: boolean | LlmCall$generatedResumeArgs<ExtArgs>
    generatedInterviewPrep?: boolean | LlmCall$generatedInterviewPrepArgs<ExtArgs>
    messages?: boolean | LlmCall$messagesArgs<ExtArgs>
    _count?: boolean | LlmCallCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LlmCallIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LlmCall$userArgs<ExtArgs>
    resume?: boolean | LlmCall$resumeArgs<ExtArgs>
    extractedResume?: boolean | LlmCall$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | LlmCall$extractedJobArgs<ExtArgs>
    generatedRoast?: boolean | LlmCall$generatedRoastArgs<ExtArgs>
    generatedCoverLetter?: boolean | LlmCall$generatedCoverLetterArgs<ExtArgs>
    generatedResume?: boolean | LlmCall$generatedResumeArgs<ExtArgs>
    generatedInterviewPrep?: boolean | LlmCall$generatedInterviewPrepArgs<ExtArgs>
  }
  export type LlmCallIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LlmCall$userArgs<ExtArgs>
    resume?: boolean | LlmCall$resumeArgs<ExtArgs>
    extractedResume?: boolean | LlmCall$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | LlmCall$extractedJobArgs<ExtArgs>
    generatedRoast?: boolean | LlmCall$generatedRoastArgs<ExtArgs>
    generatedCoverLetter?: boolean | LlmCall$generatedCoverLetterArgs<ExtArgs>
    generatedResume?: boolean | LlmCall$generatedResumeArgs<ExtArgs>
    generatedInterviewPrep?: boolean | LlmCall$generatedInterviewPrepArgs<ExtArgs>
  }

  export type $LlmCallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LlmCall"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      resume: Prisma.$ResumePayload<ExtArgs> | null
      extractedResume: Prisma.$ExtractedResumePayload<ExtArgs> | null
      extractedJob: Prisma.$ExtractedJobDescriptionPayload<ExtArgs> | null
      generatedRoast: Prisma.$GeneratedRoastPayload<ExtArgs> | null
      generatedCoverLetter: Prisma.$GeneratedCoverLetterPayload<ExtArgs> | null
      generatedResume: Prisma.$GeneratedResumePayload<ExtArgs> | null
      generatedInterviewPrep: Prisma.$GeneratedInterviewPrepPayload<ExtArgs> | null
      messages: Prisma.$LlmMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      provider: string
      model: string
      operationType: string
      totalInputTokens: number
      totalOutputTokens: number
      totalTokens: number
      totalCostUsd: Prisma.Decimal
      totalProcessingTimeMs: number | null
      status: $Enums.LlmCallStatus
      errorMessage: string | null
      resumeId: string | null
      extractedResumeId: string | null
      extractedJobId: string | null
      generatedRoastId: string | null
      generatedCoverLetterId: string | null
      generatedResumeId: string | null
      generatedInterviewPrepId: string | null
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["llmCall"]>
    composites: {}
  }

  type LlmCallGetPayload<S extends boolean | null | undefined | LlmCallDefaultArgs> = $Result.GetResult<Prisma.$LlmCallPayload, S>

  type LlmCallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LlmCallFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LlmCallCountAggregateInputType | true
    }

  export interface LlmCallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LlmCall'], meta: { name: 'LlmCall' } }
    /**
     * Find zero or one LlmCall that matches the filter.
     * @param {LlmCallFindUniqueArgs} args - Arguments to find a LlmCall
     * @example
     * // Get one LlmCall
     * const llmCall = await prisma.llmCall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LlmCallFindUniqueArgs>(args: SelectSubset<T, LlmCallFindUniqueArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LlmCall that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LlmCallFindUniqueOrThrowArgs} args - Arguments to find a LlmCall
     * @example
     * // Get one LlmCall
     * const llmCall = await prisma.llmCall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LlmCallFindUniqueOrThrowArgs>(args: SelectSubset<T, LlmCallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LlmCall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallFindFirstArgs} args - Arguments to find a LlmCall
     * @example
     * // Get one LlmCall
     * const llmCall = await prisma.llmCall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LlmCallFindFirstArgs>(args?: SelectSubset<T, LlmCallFindFirstArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LlmCall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallFindFirstOrThrowArgs} args - Arguments to find a LlmCall
     * @example
     * // Get one LlmCall
     * const llmCall = await prisma.llmCall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LlmCallFindFirstOrThrowArgs>(args?: SelectSubset<T, LlmCallFindFirstOrThrowArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LlmCalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LlmCalls
     * const llmCalls = await prisma.llmCall.findMany()
     * 
     * // Get first 10 LlmCalls
     * const llmCalls = await prisma.llmCall.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const llmCallWithIdOnly = await prisma.llmCall.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LlmCallFindManyArgs>(args?: SelectSubset<T, LlmCallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LlmCall.
     * @param {LlmCallCreateArgs} args - Arguments to create a LlmCall.
     * @example
     * // Create one LlmCall
     * const LlmCall = await prisma.llmCall.create({
     *   data: {
     *     // ... data to create a LlmCall
     *   }
     * })
     * 
     */
    create<T extends LlmCallCreateArgs>(args: SelectSubset<T, LlmCallCreateArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LlmCalls.
     * @param {LlmCallCreateManyArgs} args - Arguments to create many LlmCalls.
     * @example
     * // Create many LlmCalls
     * const llmCall = await prisma.llmCall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LlmCallCreateManyArgs>(args?: SelectSubset<T, LlmCallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LlmCalls and returns the data saved in the database.
     * @param {LlmCallCreateManyAndReturnArgs} args - Arguments to create many LlmCalls.
     * @example
     * // Create many LlmCalls
     * const llmCall = await prisma.llmCall.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LlmCalls and only return the `id`
     * const llmCallWithIdOnly = await prisma.llmCall.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LlmCallCreateManyAndReturnArgs>(args?: SelectSubset<T, LlmCallCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LlmCall.
     * @param {LlmCallDeleteArgs} args - Arguments to delete one LlmCall.
     * @example
     * // Delete one LlmCall
     * const LlmCall = await prisma.llmCall.delete({
     *   where: {
     *     // ... filter to delete one LlmCall
     *   }
     * })
     * 
     */
    delete<T extends LlmCallDeleteArgs>(args: SelectSubset<T, LlmCallDeleteArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LlmCall.
     * @param {LlmCallUpdateArgs} args - Arguments to update one LlmCall.
     * @example
     * // Update one LlmCall
     * const llmCall = await prisma.llmCall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LlmCallUpdateArgs>(args: SelectSubset<T, LlmCallUpdateArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LlmCalls.
     * @param {LlmCallDeleteManyArgs} args - Arguments to filter LlmCalls to delete.
     * @example
     * // Delete a few LlmCalls
     * const { count } = await prisma.llmCall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LlmCallDeleteManyArgs>(args?: SelectSubset<T, LlmCallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LlmCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LlmCalls
     * const llmCall = await prisma.llmCall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LlmCallUpdateManyArgs>(args: SelectSubset<T, LlmCallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LlmCalls and returns the data updated in the database.
     * @param {LlmCallUpdateManyAndReturnArgs} args - Arguments to update many LlmCalls.
     * @example
     * // Update many LlmCalls
     * const llmCall = await prisma.llmCall.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LlmCalls and only return the `id`
     * const llmCallWithIdOnly = await prisma.llmCall.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LlmCallUpdateManyAndReturnArgs>(args: SelectSubset<T, LlmCallUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LlmCall.
     * @param {LlmCallUpsertArgs} args - Arguments to update or create a LlmCall.
     * @example
     * // Update or create a LlmCall
     * const llmCall = await prisma.llmCall.upsert({
     *   create: {
     *     // ... data to create a LlmCall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LlmCall we want to update
     *   }
     * })
     */
    upsert<T extends LlmCallUpsertArgs>(args: SelectSubset<T, LlmCallUpsertArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LlmCalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallCountArgs} args - Arguments to filter LlmCalls to count.
     * @example
     * // Count the number of LlmCalls
     * const count = await prisma.llmCall.count({
     *   where: {
     *     // ... the filter for the LlmCalls we want to count
     *   }
     * })
    **/
    count<T extends LlmCallCountArgs>(
      args?: Subset<T, LlmCallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LlmCallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LlmCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LlmCallAggregateArgs>(args: Subset<T, LlmCallAggregateArgs>): Prisma.PrismaPromise<GetLlmCallAggregateType<T>>

    /**
     * Group by LlmCall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmCallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LlmCallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LlmCallGroupByArgs['orderBy'] }
        : { orderBy?: LlmCallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LlmCallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLlmCallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LlmCall model
   */
  readonly fields: LlmCallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LlmCall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LlmCallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends LlmCall$userArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resume<T extends LlmCall$resumeArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$resumeArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedResume<T extends LlmCall$extractedResumeArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$extractedResumeArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedJob<T extends LlmCall$extractedJobArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$extractedJobArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    generatedRoast<T extends LlmCall$generatedRoastArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$generatedRoastArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    generatedCoverLetter<T extends LlmCall$generatedCoverLetterArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$generatedCoverLetterArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    generatedResume<T extends LlmCall$generatedResumeArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$generatedResumeArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    generatedInterviewPrep<T extends LlmCall$generatedInterviewPrepArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$generatedInterviewPrepArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends LlmCall$messagesArgs<ExtArgs> = {}>(args?: Subset<T, LlmCall$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LlmCall model
   */
  interface LlmCallFieldRefs {
    readonly id: FieldRef<"LlmCall", 'String'>
    readonly userId: FieldRef<"LlmCall", 'String'>
    readonly provider: FieldRef<"LlmCall", 'String'>
    readonly model: FieldRef<"LlmCall", 'String'>
    readonly operationType: FieldRef<"LlmCall", 'String'>
    readonly totalInputTokens: FieldRef<"LlmCall", 'Int'>
    readonly totalOutputTokens: FieldRef<"LlmCall", 'Int'>
    readonly totalTokens: FieldRef<"LlmCall", 'Int'>
    readonly totalCostUsd: FieldRef<"LlmCall", 'Decimal'>
    readonly totalProcessingTimeMs: FieldRef<"LlmCall", 'Int'>
    readonly status: FieldRef<"LlmCall", 'LlmCallStatus'>
    readonly errorMessage: FieldRef<"LlmCall", 'String'>
    readonly resumeId: FieldRef<"LlmCall", 'String'>
    readonly extractedResumeId: FieldRef<"LlmCall", 'String'>
    readonly extractedJobId: FieldRef<"LlmCall", 'String'>
    readonly generatedRoastId: FieldRef<"LlmCall", 'String'>
    readonly generatedCoverLetterId: FieldRef<"LlmCall", 'String'>
    readonly generatedResumeId: FieldRef<"LlmCall", 'String'>
    readonly generatedInterviewPrepId: FieldRef<"LlmCall", 'String'>
    readonly createdAt: FieldRef<"LlmCall", 'DateTime'>
    readonly completedAt: FieldRef<"LlmCall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LlmCall findUnique
   */
  export type LlmCallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * Filter, which LlmCall to fetch.
     */
    where: LlmCallWhereUniqueInput
  }

  /**
   * LlmCall findUniqueOrThrow
   */
  export type LlmCallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * Filter, which LlmCall to fetch.
     */
    where: LlmCallWhereUniqueInput
  }

  /**
   * LlmCall findFirst
   */
  export type LlmCallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * Filter, which LlmCall to fetch.
     */
    where?: LlmCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmCalls to fetch.
     */
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LlmCalls.
     */
    cursor?: LlmCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LlmCalls.
     */
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * LlmCall findFirstOrThrow
   */
  export type LlmCallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * Filter, which LlmCall to fetch.
     */
    where?: LlmCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmCalls to fetch.
     */
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LlmCalls.
     */
    cursor?: LlmCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmCalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LlmCalls.
     */
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * LlmCall findMany
   */
  export type LlmCallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * Filter, which LlmCalls to fetch.
     */
    where?: LlmCallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmCalls to fetch.
     */
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LlmCalls.
     */
    cursor?: LlmCallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmCalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmCalls.
     */
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * LlmCall create
   */
  export type LlmCallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * The data needed to create a LlmCall.
     */
    data: XOR<LlmCallCreateInput, LlmCallUncheckedCreateInput>
  }

  /**
   * LlmCall createMany
   */
  export type LlmCallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LlmCalls.
     */
    data: LlmCallCreateManyInput | LlmCallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LlmCall createManyAndReturn
   */
  export type LlmCallCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * The data used to create many LlmCalls.
     */
    data: LlmCallCreateManyInput | LlmCallCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LlmCall update
   */
  export type LlmCallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * The data needed to update a LlmCall.
     */
    data: XOR<LlmCallUpdateInput, LlmCallUncheckedUpdateInput>
    /**
     * Choose, which LlmCall to update.
     */
    where: LlmCallWhereUniqueInput
  }

  /**
   * LlmCall updateMany
   */
  export type LlmCallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LlmCalls.
     */
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyInput>
    /**
     * Filter which LlmCalls to update
     */
    where?: LlmCallWhereInput
    /**
     * Limit how many LlmCalls to update.
     */
    limit?: number
  }

  /**
   * LlmCall updateManyAndReturn
   */
  export type LlmCallUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * The data used to update LlmCalls.
     */
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyInput>
    /**
     * Filter which LlmCalls to update
     */
    where?: LlmCallWhereInput
    /**
     * Limit how many LlmCalls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LlmCall upsert
   */
  export type LlmCallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * The filter to search for the LlmCall to update in case it exists.
     */
    where: LlmCallWhereUniqueInput
    /**
     * In case the LlmCall found by the `where` argument doesn't exist, create a new LlmCall with this data.
     */
    create: XOR<LlmCallCreateInput, LlmCallUncheckedCreateInput>
    /**
     * In case the LlmCall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LlmCallUpdateInput, LlmCallUncheckedUpdateInput>
  }

  /**
   * LlmCall delete
   */
  export type LlmCallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    /**
     * Filter which LlmCall to delete.
     */
    where: LlmCallWhereUniqueInput
  }

  /**
   * LlmCall deleteMany
   */
  export type LlmCallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LlmCalls to delete
     */
    where?: LlmCallWhereInput
    /**
     * Limit how many LlmCalls to delete.
     */
    limit?: number
  }

  /**
   * LlmCall.user
   */
  export type LlmCall$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LlmCall.resume
   */
  export type LlmCall$resumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
  }

  /**
   * LlmCall.extractedResume
   */
  export type LlmCall$extractedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    where?: ExtractedResumeWhereInput
  }

  /**
   * LlmCall.extractedJob
   */
  export type LlmCall$extractedJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    where?: ExtractedJobDescriptionWhereInput
  }

  /**
   * LlmCall.generatedRoast
   */
  export type LlmCall$generatedRoastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
  }

  /**
   * LlmCall.generatedCoverLetter
   */
  export type LlmCall$generatedCoverLetterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    where?: GeneratedCoverLetterWhereInput
  }

  /**
   * LlmCall.generatedResume
   */
  export type LlmCall$generatedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    where?: GeneratedResumeWhereInput
  }

  /**
   * LlmCall.generatedInterviewPrep
   */
  export type LlmCall$generatedInterviewPrepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    where?: GeneratedInterviewPrepWhereInput
  }

  /**
   * LlmCall.messages
   */
  export type LlmCall$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    where?: LlmMessageWhereInput
    orderBy?: LlmMessageOrderByWithRelationInput | LlmMessageOrderByWithRelationInput[]
    cursor?: LlmMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmMessageScalarFieldEnum | LlmMessageScalarFieldEnum[]
  }

  /**
   * LlmCall without action
   */
  export type LlmCallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
  }


  /**
   * Model LlmMessage
   */

  export type AggregateLlmMessage = {
    _count: LlmMessageCountAggregateOutputType | null
    _avg: LlmMessageAvgAggregateOutputType | null
    _sum: LlmMessageSumAggregateOutputType | null
    _min: LlmMessageMinAggregateOutputType | null
    _max: LlmMessageMaxAggregateOutputType | null
  }

  export type LlmMessageAvgAggregateOutputType = {
    messageIndex: number | null
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    temperature: Decimal | null
    maxTokens: number | null
  }

  export type LlmMessageSumAggregateOutputType = {
    messageIndex: number | null
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    temperature: Decimal | null
    maxTokens: number | null
  }

  export type LlmMessageMinAggregateOutputType = {
    id: string | null
    llmCallId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    messageIndex: number | null
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    finishReason: string | null
    temperature: Decimal | null
    maxTokens: number | null
    createdAt: Date | null
  }

  export type LlmMessageMaxAggregateOutputType = {
    id: string | null
    llmCallId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    messageIndex: number | null
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    finishReason: string | null
    temperature: Decimal | null
    maxTokens: number | null
    createdAt: Date | null
  }

  export type LlmMessageCountAggregateOutputType = {
    id: number
    llmCallId: number
    role: number
    content: number
    messageIndex: number
    inputTokens: number
    outputTokens: number
    totalTokens: number
    costUsd: number
    processingTimeMs: number
    finishReason: number
    temperature: number
    maxTokens: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type LlmMessageAvgAggregateInputType = {
    messageIndex?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    costUsd?: true
    processingTimeMs?: true
    temperature?: true
    maxTokens?: true
  }

  export type LlmMessageSumAggregateInputType = {
    messageIndex?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    costUsd?: true
    processingTimeMs?: true
    temperature?: true
    maxTokens?: true
  }

  export type LlmMessageMinAggregateInputType = {
    id?: true
    llmCallId?: true
    role?: true
    content?: true
    messageIndex?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    costUsd?: true
    processingTimeMs?: true
    finishReason?: true
    temperature?: true
    maxTokens?: true
    createdAt?: true
  }

  export type LlmMessageMaxAggregateInputType = {
    id?: true
    llmCallId?: true
    role?: true
    content?: true
    messageIndex?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    costUsd?: true
    processingTimeMs?: true
    finishReason?: true
    temperature?: true
    maxTokens?: true
    createdAt?: true
  }

  export type LlmMessageCountAggregateInputType = {
    id?: true
    llmCallId?: true
    role?: true
    content?: true
    messageIndex?: true
    inputTokens?: true
    outputTokens?: true
    totalTokens?: true
    costUsd?: true
    processingTimeMs?: true
    finishReason?: true
    temperature?: true
    maxTokens?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type LlmMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LlmMessage to aggregate.
     */
    where?: LlmMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmMessages to fetch.
     */
    orderBy?: LlmMessageOrderByWithRelationInput | LlmMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LlmMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LlmMessages
    **/
    _count?: true | LlmMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LlmMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LlmMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LlmMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LlmMessageMaxAggregateInputType
  }

  export type GetLlmMessageAggregateType<T extends LlmMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateLlmMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLlmMessage[P]>
      : GetScalarType<T[P], AggregateLlmMessage[P]>
  }




  export type LlmMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LlmMessageWhereInput
    orderBy?: LlmMessageOrderByWithAggregationInput | LlmMessageOrderByWithAggregationInput[]
    by: LlmMessageScalarFieldEnum[] | LlmMessageScalarFieldEnum
    having?: LlmMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LlmMessageCountAggregateInputType | true
    _avg?: LlmMessageAvgAggregateInputType
    _sum?: LlmMessageSumAggregateInputType
    _min?: LlmMessageMinAggregateInputType
    _max?: LlmMessageMaxAggregateInputType
  }

  export type LlmMessageGroupByOutputType = {
    id: string
    llmCallId: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens: number | null
    outputTokens: number | null
    totalTokens: number | null
    costUsd: Decimal
    processingTimeMs: number | null
    finishReason: string | null
    temperature: Decimal | null
    maxTokens: number | null
    metadata: JsonValue | null
    createdAt: Date
    _count: LlmMessageCountAggregateOutputType | null
    _avg: LlmMessageAvgAggregateOutputType | null
    _sum: LlmMessageSumAggregateOutputType | null
    _min: LlmMessageMinAggregateOutputType | null
    _max: LlmMessageMaxAggregateOutputType | null
  }

  type GetLlmMessageGroupByPayload<T extends LlmMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LlmMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LlmMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LlmMessageGroupByOutputType[P]>
            : GetScalarType<T[P], LlmMessageGroupByOutputType[P]>
        }
      >
    >


  export type LlmMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    llmCallId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    finishReason?: boolean
    temperature?: boolean
    maxTokens?: boolean
    metadata?: boolean
    createdAt?: boolean
    llmCall?: boolean | LlmCallDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["llmMessage"]>

  export type LlmMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    llmCallId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    finishReason?: boolean
    temperature?: boolean
    maxTokens?: boolean
    metadata?: boolean
    createdAt?: boolean
    llmCall?: boolean | LlmCallDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["llmMessage"]>

  export type LlmMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    llmCallId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    finishReason?: boolean
    temperature?: boolean
    maxTokens?: boolean
    metadata?: boolean
    createdAt?: boolean
    llmCall?: boolean | LlmCallDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["llmMessage"]>

  export type LlmMessageSelectScalar = {
    id?: boolean
    llmCallId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    totalTokens?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    finishReason?: boolean
    temperature?: boolean
    maxTokens?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type LlmMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "llmCallId" | "role" | "content" | "messageIndex" | "inputTokens" | "outputTokens" | "totalTokens" | "costUsd" | "processingTimeMs" | "finishReason" | "temperature" | "maxTokens" | "metadata" | "createdAt", ExtArgs["result"]["llmMessage"]>
  export type LlmMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCall?: boolean | LlmCallDefaultArgs<ExtArgs>
  }
  export type LlmMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCall?: boolean | LlmCallDefaultArgs<ExtArgs>
  }
  export type LlmMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCall?: boolean | LlmCallDefaultArgs<ExtArgs>
  }

  export type $LlmMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LlmMessage"
    objects: {
      llmCall: Prisma.$LlmCallPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      llmCallId: string
      role: $Enums.MessageRole
      content: string
      messageIndex: number
      inputTokens: number | null
      outputTokens: number | null
      totalTokens: number | null
      costUsd: Prisma.Decimal
      processingTimeMs: number | null
      finishReason: string | null
      temperature: Prisma.Decimal | null
      maxTokens: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["llmMessage"]>
    composites: {}
  }

  type LlmMessageGetPayload<S extends boolean | null | undefined | LlmMessageDefaultArgs> = $Result.GetResult<Prisma.$LlmMessagePayload, S>

  type LlmMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LlmMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LlmMessageCountAggregateInputType | true
    }

  export interface LlmMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LlmMessage'], meta: { name: 'LlmMessage' } }
    /**
     * Find zero or one LlmMessage that matches the filter.
     * @param {LlmMessageFindUniqueArgs} args - Arguments to find a LlmMessage
     * @example
     * // Get one LlmMessage
     * const llmMessage = await prisma.llmMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LlmMessageFindUniqueArgs>(args: SelectSubset<T, LlmMessageFindUniqueArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LlmMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LlmMessageFindUniqueOrThrowArgs} args - Arguments to find a LlmMessage
     * @example
     * // Get one LlmMessage
     * const llmMessage = await prisma.llmMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LlmMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, LlmMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LlmMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageFindFirstArgs} args - Arguments to find a LlmMessage
     * @example
     * // Get one LlmMessage
     * const llmMessage = await prisma.llmMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LlmMessageFindFirstArgs>(args?: SelectSubset<T, LlmMessageFindFirstArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LlmMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageFindFirstOrThrowArgs} args - Arguments to find a LlmMessage
     * @example
     * // Get one LlmMessage
     * const llmMessage = await prisma.llmMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LlmMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, LlmMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LlmMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LlmMessages
     * const llmMessages = await prisma.llmMessage.findMany()
     * 
     * // Get first 10 LlmMessages
     * const llmMessages = await prisma.llmMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const llmMessageWithIdOnly = await prisma.llmMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LlmMessageFindManyArgs>(args?: SelectSubset<T, LlmMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LlmMessage.
     * @param {LlmMessageCreateArgs} args - Arguments to create a LlmMessage.
     * @example
     * // Create one LlmMessage
     * const LlmMessage = await prisma.llmMessage.create({
     *   data: {
     *     // ... data to create a LlmMessage
     *   }
     * })
     * 
     */
    create<T extends LlmMessageCreateArgs>(args: SelectSubset<T, LlmMessageCreateArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LlmMessages.
     * @param {LlmMessageCreateManyArgs} args - Arguments to create many LlmMessages.
     * @example
     * // Create many LlmMessages
     * const llmMessage = await prisma.llmMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LlmMessageCreateManyArgs>(args?: SelectSubset<T, LlmMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LlmMessages and returns the data saved in the database.
     * @param {LlmMessageCreateManyAndReturnArgs} args - Arguments to create many LlmMessages.
     * @example
     * // Create many LlmMessages
     * const llmMessage = await prisma.llmMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LlmMessages and only return the `id`
     * const llmMessageWithIdOnly = await prisma.llmMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LlmMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, LlmMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LlmMessage.
     * @param {LlmMessageDeleteArgs} args - Arguments to delete one LlmMessage.
     * @example
     * // Delete one LlmMessage
     * const LlmMessage = await prisma.llmMessage.delete({
     *   where: {
     *     // ... filter to delete one LlmMessage
     *   }
     * })
     * 
     */
    delete<T extends LlmMessageDeleteArgs>(args: SelectSubset<T, LlmMessageDeleteArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LlmMessage.
     * @param {LlmMessageUpdateArgs} args - Arguments to update one LlmMessage.
     * @example
     * // Update one LlmMessage
     * const llmMessage = await prisma.llmMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LlmMessageUpdateArgs>(args: SelectSubset<T, LlmMessageUpdateArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LlmMessages.
     * @param {LlmMessageDeleteManyArgs} args - Arguments to filter LlmMessages to delete.
     * @example
     * // Delete a few LlmMessages
     * const { count } = await prisma.llmMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LlmMessageDeleteManyArgs>(args?: SelectSubset<T, LlmMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LlmMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LlmMessages
     * const llmMessage = await prisma.llmMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LlmMessageUpdateManyArgs>(args: SelectSubset<T, LlmMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LlmMessages and returns the data updated in the database.
     * @param {LlmMessageUpdateManyAndReturnArgs} args - Arguments to update many LlmMessages.
     * @example
     * // Update many LlmMessages
     * const llmMessage = await prisma.llmMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LlmMessages and only return the `id`
     * const llmMessageWithIdOnly = await prisma.llmMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LlmMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, LlmMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LlmMessage.
     * @param {LlmMessageUpsertArgs} args - Arguments to update or create a LlmMessage.
     * @example
     * // Update or create a LlmMessage
     * const llmMessage = await prisma.llmMessage.upsert({
     *   create: {
     *     // ... data to create a LlmMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LlmMessage we want to update
     *   }
     * })
     */
    upsert<T extends LlmMessageUpsertArgs>(args: SelectSubset<T, LlmMessageUpsertArgs<ExtArgs>>): Prisma__LlmMessageClient<$Result.GetResult<Prisma.$LlmMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LlmMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageCountArgs} args - Arguments to filter LlmMessages to count.
     * @example
     * // Count the number of LlmMessages
     * const count = await prisma.llmMessage.count({
     *   where: {
     *     // ... the filter for the LlmMessages we want to count
     *   }
     * })
    **/
    count<T extends LlmMessageCountArgs>(
      args?: Subset<T, LlmMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LlmMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LlmMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LlmMessageAggregateArgs>(args: Subset<T, LlmMessageAggregateArgs>): Prisma.PrismaPromise<GetLlmMessageAggregateType<T>>

    /**
     * Group by LlmMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LlmMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LlmMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LlmMessageGroupByArgs['orderBy'] }
        : { orderBy?: LlmMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LlmMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLlmMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LlmMessage model
   */
  readonly fields: LlmMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LlmMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LlmMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    llmCall<T extends LlmCallDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LlmCallDefaultArgs<ExtArgs>>): Prisma__LlmCallClient<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LlmMessage model
   */
  interface LlmMessageFieldRefs {
    readonly id: FieldRef<"LlmMessage", 'String'>
    readonly llmCallId: FieldRef<"LlmMessage", 'String'>
    readonly role: FieldRef<"LlmMessage", 'MessageRole'>
    readonly content: FieldRef<"LlmMessage", 'String'>
    readonly messageIndex: FieldRef<"LlmMessage", 'Int'>
    readonly inputTokens: FieldRef<"LlmMessage", 'Int'>
    readonly outputTokens: FieldRef<"LlmMessage", 'Int'>
    readonly totalTokens: FieldRef<"LlmMessage", 'Int'>
    readonly costUsd: FieldRef<"LlmMessage", 'Decimal'>
    readonly processingTimeMs: FieldRef<"LlmMessage", 'Int'>
    readonly finishReason: FieldRef<"LlmMessage", 'String'>
    readonly temperature: FieldRef<"LlmMessage", 'Decimal'>
    readonly maxTokens: FieldRef<"LlmMessage", 'Int'>
    readonly metadata: FieldRef<"LlmMessage", 'Json'>
    readonly createdAt: FieldRef<"LlmMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LlmMessage findUnique
   */
  export type LlmMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * Filter, which LlmMessage to fetch.
     */
    where: LlmMessageWhereUniqueInput
  }

  /**
   * LlmMessage findUniqueOrThrow
   */
  export type LlmMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * Filter, which LlmMessage to fetch.
     */
    where: LlmMessageWhereUniqueInput
  }

  /**
   * LlmMessage findFirst
   */
  export type LlmMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * Filter, which LlmMessage to fetch.
     */
    where?: LlmMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmMessages to fetch.
     */
    orderBy?: LlmMessageOrderByWithRelationInput | LlmMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LlmMessages.
     */
    cursor?: LlmMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LlmMessages.
     */
    distinct?: LlmMessageScalarFieldEnum | LlmMessageScalarFieldEnum[]
  }

  /**
   * LlmMessage findFirstOrThrow
   */
  export type LlmMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * Filter, which LlmMessage to fetch.
     */
    where?: LlmMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmMessages to fetch.
     */
    orderBy?: LlmMessageOrderByWithRelationInput | LlmMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LlmMessages.
     */
    cursor?: LlmMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LlmMessages.
     */
    distinct?: LlmMessageScalarFieldEnum | LlmMessageScalarFieldEnum[]
  }

  /**
   * LlmMessage findMany
   */
  export type LlmMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * Filter, which LlmMessages to fetch.
     */
    where?: LlmMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LlmMessages to fetch.
     */
    orderBy?: LlmMessageOrderByWithRelationInput | LlmMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LlmMessages.
     */
    cursor?: LlmMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LlmMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LlmMessages.
     */
    skip?: number
    distinct?: LlmMessageScalarFieldEnum | LlmMessageScalarFieldEnum[]
  }

  /**
   * LlmMessage create
   */
  export type LlmMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a LlmMessage.
     */
    data: XOR<LlmMessageCreateInput, LlmMessageUncheckedCreateInput>
  }

  /**
   * LlmMessage createMany
   */
  export type LlmMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LlmMessages.
     */
    data: LlmMessageCreateManyInput | LlmMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LlmMessage createManyAndReturn
   */
  export type LlmMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * The data used to create many LlmMessages.
     */
    data: LlmMessageCreateManyInput | LlmMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LlmMessage update
   */
  export type LlmMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a LlmMessage.
     */
    data: XOR<LlmMessageUpdateInput, LlmMessageUncheckedUpdateInput>
    /**
     * Choose, which LlmMessage to update.
     */
    where: LlmMessageWhereUniqueInput
  }

  /**
   * LlmMessage updateMany
   */
  export type LlmMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LlmMessages.
     */
    data: XOR<LlmMessageUpdateManyMutationInput, LlmMessageUncheckedUpdateManyInput>
    /**
     * Filter which LlmMessages to update
     */
    where?: LlmMessageWhereInput
    /**
     * Limit how many LlmMessages to update.
     */
    limit?: number
  }

  /**
   * LlmMessage updateManyAndReturn
   */
  export type LlmMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * The data used to update LlmMessages.
     */
    data: XOR<LlmMessageUpdateManyMutationInput, LlmMessageUncheckedUpdateManyInput>
    /**
     * Filter which LlmMessages to update
     */
    where?: LlmMessageWhereInput
    /**
     * Limit how many LlmMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LlmMessage upsert
   */
  export type LlmMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the LlmMessage to update in case it exists.
     */
    where: LlmMessageWhereUniqueInput
    /**
     * In case the LlmMessage found by the `where` argument doesn't exist, create a new LlmMessage with this data.
     */
    create: XOR<LlmMessageCreateInput, LlmMessageUncheckedCreateInput>
    /**
     * In case the LlmMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LlmMessageUpdateInput, LlmMessageUncheckedUpdateInput>
  }

  /**
   * LlmMessage delete
   */
  export type LlmMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
    /**
     * Filter which LlmMessage to delete.
     */
    where: LlmMessageWhereUniqueInput
  }

  /**
   * LlmMessage deleteMany
   */
  export type LlmMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LlmMessages to delete
     */
    where?: LlmMessageWhereInput
    /**
     * Limit how many LlmMessages to delete.
     */
    limit?: number
  }

  /**
   * LlmMessage without action
   */
  export type LlmMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmMessage
     */
    select?: LlmMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmMessage
     */
    omit?: LlmMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmMessageInclude<ExtArgs> | null
  }


  /**
   * Model Resume
   */

  export type AggregateResume = {
    _count: ResumeCountAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  export type ResumeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    fileHash: string | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type ResumeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    fileHash: string | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type ResumeCountAggregateOutputType = {
    id: number
    userId: number
    filename: number
    fileHash: number
    mimeType: number
    images: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ResumeMinAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    fileHash?: true
    mimeType?: true
    createdAt?: true
  }

  export type ResumeMaxAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    fileHash?: true
    mimeType?: true
    createdAt?: true
  }

  export type ResumeCountAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    fileHash?: true
    mimeType?: true
    images?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resume to aggregate.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resumes
    **/
    _count?: true | ResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResumeMaxAggregateInputType
  }

  export type GetResumeAggregateType<T extends ResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResume[P]>
      : GetScalarType<T[P], AggregateResume[P]>
  }




  export type ResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResumeWhereInput
    orderBy?: ResumeOrderByWithAggregationInput | ResumeOrderByWithAggregationInput[]
    by: ResumeScalarFieldEnum[] | ResumeScalarFieldEnum
    having?: ResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResumeCountAggregateInputType | true
    _min?: ResumeMinAggregateInputType
    _max?: ResumeMaxAggregateInputType
  }

  export type ResumeGroupByOutputType = {
    id: string
    userId: string | null
    filename: string
    fileHash: string
    mimeType: string
    images: string[]
    metadata: JsonValue | null
    createdAt: Date
    _count: ResumeCountAggregateOutputType | null
    _min: ResumeMinAggregateOutputType | null
    _max: ResumeMaxAggregateOutputType | null
  }

  type GetResumeGroupByPayload<T extends ResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ResumeGroupByOutputType[P]>
        }
      >
    >


  export type ResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileHash?: boolean
    mimeType?: boolean
    images?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Resume$userArgs<ExtArgs>
    llmCalls?: boolean | Resume$llmCallsArgs<ExtArgs>
    extractedResumes?: boolean | Resume$extractedResumesArgs<ExtArgs>
    generatedRoasts?: boolean | Resume$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | Resume$generatedCoverLettersArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileHash?: boolean
    mimeType?: boolean
    images?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Resume$userArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileHash?: boolean
    mimeType?: boolean
    images?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | Resume$userArgs<ExtArgs>
  }, ExtArgs["result"]["resume"]>

  export type ResumeSelectScalar = {
    id?: boolean
    userId?: boolean
    filename?: boolean
    fileHash?: boolean
    mimeType?: boolean
    images?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "filename" | "fileHash" | "mimeType" | "images" | "metadata" | "createdAt", ExtArgs["result"]["resume"]>
  export type ResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resume$userArgs<ExtArgs>
    llmCalls?: boolean | Resume$llmCallsArgs<ExtArgs>
    extractedResumes?: boolean | Resume$extractedResumesArgs<ExtArgs>
    generatedRoasts?: boolean | Resume$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | Resume$generatedCoverLettersArgs<ExtArgs>
    _count?: boolean | ResumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resume$userArgs<ExtArgs>
  }
  export type ResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Resume$userArgs<ExtArgs>
  }

  export type $ResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resume"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
      extractedResumes: Prisma.$ExtractedResumePayload<ExtArgs>[]
      generatedRoasts: Prisma.$GeneratedRoastPayload<ExtArgs>[]
      generatedCoverLetters: Prisma.$GeneratedCoverLetterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      filename: string
      fileHash: string
      mimeType: string
      images: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["resume"]>
    composites: {}
  }

  type ResumeGetPayload<S extends boolean | null | undefined | ResumeDefaultArgs> = $Result.GetResult<Prisma.$ResumePayload, S>

  type ResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ResumeCountAggregateInputType | true
    }

  export interface ResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resume'], meta: { name: 'Resume' } }
    /**
     * Find zero or one Resume that matches the filter.
     * @param {ResumeFindUniqueArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResumeFindUniqueArgs>(args: SelectSubset<T, ResumeFindUniqueArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Resume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ResumeFindUniqueOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, ResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResumeFindFirstArgs>(args?: SelectSubset<T, ResumeFindFirstArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Resume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindFirstOrThrowArgs} args - Arguments to find a Resume
     * @example
     * // Get one Resume
     * const resume = await prisma.resume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, ResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Resumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resumes
     * const resumes = await prisma.resume.findMany()
     * 
     * // Get first 10 Resumes
     * const resumes = await prisma.resume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resumeWithIdOnly = await prisma.resume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResumeFindManyArgs>(args?: SelectSubset<T, ResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Resume.
     * @param {ResumeCreateArgs} args - Arguments to create a Resume.
     * @example
     * // Create one Resume
     * const Resume = await prisma.resume.create({
     *   data: {
     *     // ... data to create a Resume
     *   }
     * })
     * 
     */
    create<T extends ResumeCreateArgs>(args: SelectSubset<T, ResumeCreateArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Resumes.
     * @param {ResumeCreateManyArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resume = await prisma.resume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResumeCreateManyArgs>(args?: SelectSubset<T, ResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Resumes and returns the data saved in the database.
     * @param {ResumeCreateManyAndReturnArgs} args - Arguments to create many Resumes.
     * @example
     * // Create many Resumes
     * const resume = await prisma.resume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Resumes and only return the `id`
     * const resumeWithIdOnly = await prisma.resume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, ResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Resume.
     * @param {ResumeDeleteArgs} args - Arguments to delete one Resume.
     * @example
     * // Delete one Resume
     * const Resume = await prisma.resume.delete({
     *   where: {
     *     // ... filter to delete one Resume
     *   }
     * })
     * 
     */
    delete<T extends ResumeDeleteArgs>(args: SelectSubset<T, ResumeDeleteArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Resume.
     * @param {ResumeUpdateArgs} args - Arguments to update one Resume.
     * @example
     * // Update one Resume
     * const resume = await prisma.resume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResumeUpdateArgs>(args: SelectSubset<T, ResumeUpdateArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Resumes.
     * @param {ResumeDeleteManyArgs} args - Arguments to filter Resumes to delete.
     * @example
     * // Delete a few Resumes
     * const { count } = await prisma.resume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResumeDeleteManyArgs>(args?: SelectSubset<T, ResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResumeUpdateManyArgs>(args: SelectSubset<T, ResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resumes and returns the data updated in the database.
     * @param {ResumeUpdateManyAndReturnArgs} args - Arguments to update many Resumes.
     * @example
     * // Update many Resumes
     * const resume = await prisma.resume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Resumes and only return the `id`
     * const resumeWithIdOnly = await prisma.resume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, ResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Resume.
     * @param {ResumeUpsertArgs} args - Arguments to update or create a Resume.
     * @example
     * // Update or create a Resume
     * const resume = await prisma.resume.upsert({
     *   create: {
     *     // ... data to create a Resume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resume we want to update
     *   }
     * })
     */
    upsert<T extends ResumeUpsertArgs>(args: SelectSubset<T, ResumeUpsertArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Resumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeCountArgs} args - Arguments to filter Resumes to count.
     * @example
     * // Count the number of Resumes
     * const count = await prisma.resume.count({
     *   where: {
     *     // ... the filter for the Resumes we want to count
     *   }
     * })
    **/
    count<T extends ResumeCountArgs>(
      args?: Subset<T, ResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResumeAggregateArgs>(args: Subset<T, ResumeAggregateArgs>): Prisma.PrismaPromise<GetResumeAggregateType<T>>

    /**
     * Group by Resume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResumeGroupByArgs['orderBy'] }
        : { orderBy?: ResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resume model
   */
  readonly fields: ResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Resume$userArgs<ExtArgs> = {}>(args?: Subset<T, Resume$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    llmCalls<T extends Resume$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    extractedResumes<T extends Resume$extractedResumesArgs<ExtArgs> = {}>(args?: Subset<T, Resume$extractedResumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedRoasts<T extends Resume$generatedRoastsArgs<ExtArgs> = {}>(args?: Subset<T, Resume$generatedRoastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedCoverLetters<T extends Resume$generatedCoverLettersArgs<ExtArgs> = {}>(args?: Subset<T, Resume$generatedCoverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resume model
   */
  interface ResumeFieldRefs {
    readonly id: FieldRef<"Resume", 'String'>
    readonly userId: FieldRef<"Resume", 'String'>
    readonly filename: FieldRef<"Resume", 'String'>
    readonly fileHash: FieldRef<"Resume", 'String'>
    readonly mimeType: FieldRef<"Resume", 'String'>
    readonly images: FieldRef<"Resume", 'String[]'>
    readonly metadata: FieldRef<"Resume", 'Json'>
    readonly createdAt: FieldRef<"Resume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resume findUnique
   */
  export type ResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume findUniqueOrThrow
   */
  export type ResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume findFirst
   */
  export type ResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume findFirstOrThrow
   */
  export type ResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resume to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resumes.
     */
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume findMany
   */
  export type ResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter, which Resumes to fetch.
     */
    where?: ResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resumes to fetch.
     */
    orderBy?: ResumeOrderByWithRelationInput | ResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resumes.
     */
    cursor?: ResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resumes.
     */
    skip?: number
    distinct?: ResumeScalarFieldEnum | ResumeScalarFieldEnum[]
  }

  /**
   * Resume create
   */
  export type ResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a Resume.
     */
    data: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
  }

  /**
   * Resume createMany
   */
  export type ResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resume createManyAndReturn
   */
  export type ResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * The data used to create many Resumes.
     */
    data: ResumeCreateManyInput | ResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resume update
   */
  export type ResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a Resume.
     */
    data: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
    /**
     * Choose, which Resume to update.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume updateMany
   */
  export type ResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to update.
     */
    limit?: number
  }

  /**
   * Resume updateManyAndReturn
   */
  export type ResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * The data used to update Resumes.
     */
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyInput>
    /**
     * Filter which Resumes to update
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Resume upsert
   */
  export type ResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the Resume to update in case it exists.
     */
    where: ResumeWhereUniqueInput
    /**
     * In case the Resume found by the `where` argument doesn't exist, create a new Resume with this data.
     */
    create: XOR<ResumeCreateInput, ResumeUncheckedCreateInput>
    /**
     * In case the Resume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResumeUpdateInput, ResumeUncheckedUpdateInput>
  }

  /**
   * Resume delete
   */
  export type ResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    /**
     * Filter which Resume to delete.
     */
    where: ResumeWhereUniqueInput
  }

  /**
   * Resume deleteMany
   */
  export type ResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resumes to delete
     */
    where?: ResumeWhereInput
    /**
     * Limit how many Resumes to delete.
     */
    limit?: number
  }

  /**
   * Resume.user
   */
  export type Resume$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Resume.llmCalls
   */
  export type Resume$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * Resume.extractedResumes
   */
  export type Resume$extractedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    where?: ExtractedResumeWhereInput
    orderBy?: ExtractedResumeOrderByWithRelationInput | ExtractedResumeOrderByWithRelationInput[]
    cursor?: ExtractedResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExtractedResumeScalarFieldEnum | ExtractedResumeScalarFieldEnum[]
  }

  /**
   * Resume.generatedRoasts
   */
  export type Resume$generatedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    cursor?: GeneratedRoastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * Resume.generatedCoverLetters
   */
  export type Resume$generatedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    where?: GeneratedCoverLetterWhereInput
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    cursor?: GeneratedCoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * Resume without action
   */
  export type ResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
  }


  /**
   * Model ExtractedResume
   */

  export type AggregateExtractedResume = {
    _count: ExtractedResumeCountAggregateOutputType | null
    _min: ExtractedResumeMinAggregateOutputType | null
    _max: ExtractedResumeMaxAggregateOutputType | null
  }

  export type ExtractedResumeMinAggregateOutputType = {
    id: string | null
    resumeId: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type ExtractedResumeMaxAggregateOutputType = {
    id: string | null
    resumeId: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type ExtractedResumeCountAggregateOutputType = {
    id: number
    resumeId: number
    contentHash: number
    data: number
    createdAt: number
    _all: number
  }


  export type ExtractedResumeMinAggregateInputType = {
    id?: true
    resumeId?: true
    contentHash?: true
    createdAt?: true
  }

  export type ExtractedResumeMaxAggregateInputType = {
    id?: true
    resumeId?: true
    contentHash?: true
    createdAt?: true
  }

  export type ExtractedResumeCountAggregateInputType = {
    id?: true
    resumeId?: true
    contentHash?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type ExtractedResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtractedResume to aggregate.
     */
    where?: ExtractedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedResumes to fetch.
     */
    orderBy?: ExtractedResumeOrderByWithRelationInput | ExtractedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtractedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtractedResumes
    **/
    _count?: true | ExtractedResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtractedResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtractedResumeMaxAggregateInputType
  }

  export type GetExtractedResumeAggregateType<T extends ExtractedResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateExtractedResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtractedResume[P]>
      : GetScalarType<T[P], AggregateExtractedResume[P]>
  }




  export type ExtractedResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtractedResumeWhereInput
    orderBy?: ExtractedResumeOrderByWithAggregationInput | ExtractedResumeOrderByWithAggregationInput[]
    by: ExtractedResumeScalarFieldEnum[] | ExtractedResumeScalarFieldEnum
    having?: ExtractedResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtractedResumeCountAggregateInputType | true
    _min?: ExtractedResumeMinAggregateInputType
    _max?: ExtractedResumeMaxAggregateInputType
  }

  export type ExtractedResumeGroupByOutputType = {
    id: string
    resumeId: string
    contentHash: string
    data: JsonValue
    createdAt: Date
    _count: ExtractedResumeCountAggregateOutputType | null
    _min: ExtractedResumeMinAggregateOutputType | null
    _max: ExtractedResumeMaxAggregateOutputType | null
  }

  type GetExtractedResumeGroupByPayload<T extends ExtractedResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtractedResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtractedResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtractedResumeGroupByOutputType[P]>
            : GetScalarType<T[P], ExtractedResumeGroupByOutputType[P]>
        }
      >
    >


  export type ExtractedResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    contentHash?: boolean
    data?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    llmCalls?: boolean | ExtractedResume$llmCallsArgs<ExtArgs>
    summarizedResumes?: boolean | ExtractedResume$summarizedResumesArgs<ExtArgs>
    generatedRoasts?: boolean | ExtractedResume$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | ExtractedResume$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | ExtractedResume$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | ExtractedResume$generatedInterviewPrepsArgs<ExtArgs>
    _count?: boolean | ExtractedResumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extractedResume"]>

  export type ExtractedResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    contentHash?: boolean
    data?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extractedResume"]>

  export type ExtractedResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    resumeId?: boolean
    contentHash?: boolean
    data?: boolean
    createdAt?: boolean
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extractedResume"]>

  export type ExtractedResumeSelectScalar = {
    id?: boolean
    resumeId?: boolean
    contentHash?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type ExtractedResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "resumeId" | "contentHash" | "data" | "createdAt", ExtArgs["result"]["extractedResume"]>
  export type ExtractedResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
    llmCalls?: boolean | ExtractedResume$llmCallsArgs<ExtArgs>
    summarizedResumes?: boolean | ExtractedResume$summarizedResumesArgs<ExtArgs>
    generatedRoasts?: boolean | ExtractedResume$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | ExtractedResume$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | ExtractedResume$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | ExtractedResume$generatedInterviewPrepsArgs<ExtArgs>
    _count?: boolean | ExtractedResumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExtractedResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }
  export type ExtractedResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resume?: boolean | ResumeDefaultArgs<ExtArgs>
  }

  export type $ExtractedResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtractedResume"
    objects: {
      resume: Prisma.$ResumePayload<ExtArgs>
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
      summarizedResumes: Prisma.$SummarizedResumePayload<ExtArgs>[]
      generatedRoasts: Prisma.$GeneratedRoastPayload<ExtArgs>[]
      generatedCoverLetters: Prisma.$GeneratedCoverLetterPayload<ExtArgs>[]
      generatedResumes: Prisma.$GeneratedResumePayload<ExtArgs>[]
      generatedInterviewPreps: Prisma.$GeneratedInterviewPrepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      resumeId: string
      contentHash: string
      data: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["extractedResume"]>
    composites: {}
  }

  type ExtractedResumeGetPayload<S extends boolean | null | undefined | ExtractedResumeDefaultArgs> = $Result.GetResult<Prisma.$ExtractedResumePayload, S>

  type ExtractedResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExtractedResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtractedResumeCountAggregateInputType | true
    }

  export interface ExtractedResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtractedResume'], meta: { name: 'ExtractedResume' } }
    /**
     * Find zero or one ExtractedResume that matches the filter.
     * @param {ExtractedResumeFindUniqueArgs} args - Arguments to find a ExtractedResume
     * @example
     * // Get one ExtractedResume
     * const extractedResume = await prisma.extractedResume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtractedResumeFindUniqueArgs>(args: SelectSubset<T, ExtractedResumeFindUniqueArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExtractedResume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExtractedResumeFindUniqueOrThrowArgs} args - Arguments to find a ExtractedResume
     * @example
     * // Get one ExtractedResume
     * const extractedResume = await prisma.extractedResume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtractedResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, ExtractedResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExtractedResume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeFindFirstArgs} args - Arguments to find a ExtractedResume
     * @example
     * // Get one ExtractedResume
     * const extractedResume = await prisma.extractedResume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtractedResumeFindFirstArgs>(args?: SelectSubset<T, ExtractedResumeFindFirstArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExtractedResume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeFindFirstOrThrowArgs} args - Arguments to find a ExtractedResume
     * @example
     * // Get one ExtractedResume
     * const extractedResume = await prisma.extractedResume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtractedResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, ExtractedResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExtractedResumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtractedResumes
     * const extractedResumes = await prisma.extractedResume.findMany()
     * 
     * // Get first 10 ExtractedResumes
     * const extractedResumes = await prisma.extractedResume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extractedResumeWithIdOnly = await prisma.extractedResume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExtractedResumeFindManyArgs>(args?: SelectSubset<T, ExtractedResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExtractedResume.
     * @param {ExtractedResumeCreateArgs} args - Arguments to create a ExtractedResume.
     * @example
     * // Create one ExtractedResume
     * const ExtractedResume = await prisma.extractedResume.create({
     *   data: {
     *     // ... data to create a ExtractedResume
     *   }
     * })
     * 
     */
    create<T extends ExtractedResumeCreateArgs>(args: SelectSubset<T, ExtractedResumeCreateArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExtractedResumes.
     * @param {ExtractedResumeCreateManyArgs} args - Arguments to create many ExtractedResumes.
     * @example
     * // Create many ExtractedResumes
     * const extractedResume = await prisma.extractedResume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExtractedResumeCreateManyArgs>(args?: SelectSubset<T, ExtractedResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExtractedResumes and returns the data saved in the database.
     * @param {ExtractedResumeCreateManyAndReturnArgs} args - Arguments to create many ExtractedResumes.
     * @example
     * // Create many ExtractedResumes
     * const extractedResume = await prisma.extractedResume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExtractedResumes and only return the `id`
     * const extractedResumeWithIdOnly = await prisma.extractedResume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExtractedResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, ExtractedResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExtractedResume.
     * @param {ExtractedResumeDeleteArgs} args - Arguments to delete one ExtractedResume.
     * @example
     * // Delete one ExtractedResume
     * const ExtractedResume = await prisma.extractedResume.delete({
     *   where: {
     *     // ... filter to delete one ExtractedResume
     *   }
     * })
     * 
     */
    delete<T extends ExtractedResumeDeleteArgs>(args: SelectSubset<T, ExtractedResumeDeleteArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExtractedResume.
     * @param {ExtractedResumeUpdateArgs} args - Arguments to update one ExtractedResume.
     * @example
     * // Update one ExtractedResume
     * const extractedResume = await prisma.extractedResume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExtractedResumeUpdateArgs>(args: SelectSubset<T, ExtractedResumeUpdateArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExtractedResumes.
     * @param {ExtractedResumeDeleteManyArgs} args - Arguments to filter ExtractedResumes to delete.
     * @example
     * // Delete a few ExtractedResumes
     * const { count } = await prisma.extractedResume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExtractedResumeDeleteManyArgs>(args?: SelectSubset<T, ExtractedResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtractedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtractedResumes
     * const extractedResume = await prisma.extractedResume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExtractedResumeUpdateManyArgs>(args: SelectSubset<T, ExtractedResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtractedResumes and returns the data updated in the database.
     * @param {ExtractedResumeUpdateManyAndReturnArgs} args - Arguments to update many ExtractedResumes.
     * @example
     * // Update many ExtractedResumes
     * const extractedResume = await prisma.extractedResume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExtractedResumes and only return the `id`
     * const extractedResumeWithIdOnly = await prisma.extractedResume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExtractedResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, ExtractedResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExtractedResume.
     * @param {ExtractedResumeUpsertArgs} args - Arguments to update or create a ExtractedResume.
     * @example
     * // Update or create a ExtractedResume
     * const extractedResume = await prisma.extractedResume.upsert({
     *   create: {
     *     // ... data to create a ExtractedResume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtractedResume we want to update
     *   }
     * })
     */
    upsert<T extends ExtractedResumeUpsertArgs>(args: SelectSubset<T, ExtractedResumeUpsertArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExtractedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeCountArgs} args - Arguments to filter ExtractedResumes to count.
     * @example
     * // Count the number of ExtractedResumes
     * const count = await prisma.extractedResume.count({
     *   where: {
     *     // ... the filter for the ExtractedResumes we want to count
     *   }
     * })
    **/
    count<T extends ExtractedResumeCountArgs>(
      args?: Subset<T, ExtractedResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtractedResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtractedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtractedResumeAggregateArgs>(args: Subset<T, ExtractedResumeAggregateArgs>): Prisma.PrismaPromise<GetExtractedResumeAggregateType<T>>

    /**
     * Group by ExtractedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtractedResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtractedResumeGroupByArgs['orderBy'] }
        : { orderBy?: ExtractedResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtractedResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtractedResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtractedResume model
   */
  readonly fields: ExtractedResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtractedResume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtractedResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resume<T extends ResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResumeDefaultArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    llmCalls<T extends ExtractedResume$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResume$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summarizedResumes<T extends ExtractedResume$summarizedResumesArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResume$summarizedResumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedRoasts<T extends ExtractedResume$generatedRoastsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResume$generatedRoastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedCoverLetters<T extends ExtractedResume$generatedCoverLettersArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResume$generatedCoverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedResumes<T extends ExtractedResume$generatedResumesArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResume$generatedResumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedInterviewPreps<T extends ExtractedResume$generatedInterviewPrepsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResume$generatedInterviewPrepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExtractedResume model
   */
  interface ExtractedResumeFieldRefs {
    readonly id: FieldRef<"ExtractedResume", 'String'>
    readonly resumeId: FieldRef<"ExtractedResume", 'String'>
    readonly contentHash: FieldRef<"ExtractedResume", 'String'>
    readonly data: FieldRef<"ExtractedResume", 'Json'>
    readonly createdAt: FieldRef<"ExtractedResume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExtractedResume findUnique
   */
  export type ExtractedResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedResume to fetch.
     */
    where: ExtractedResumeWhereUniqueInput
  }

  /**
   * ExtractedResume findUniqueOrThrow
   */
  export type ExtractedResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedResume to fetch.
     */
    where: ExtractedResumeWhereUniqueInput
  }

  /**
   * ExtractedResume findFirst
   */
  export type ExtractedResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedResume to fetch.
     */
    where?: ExtractedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedResumes to fetch.
     */
    orderBy?: ExtractedResumeOrderByWithRelationInput | ExtractedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtractedResumes.
     */
    cursor?: ExtractedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtractedResumes.
     */
    distinct?: ExtractedResumeScalarFieldEnum | ExtractedResumeScalarFieldEnum[]
  }

  /**
   * ExtractedResume findFirstOrThrow
   */
  export type ExtractedResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedResume to fetch.
     */
    where?: ExtractedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedResumes to fetch.
     */
    orderBy?: ExtractedResumeOrderByWithRelationInput | ExtractedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtractedResumes.
     */
    cursor?: ExtractedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtractedResumes.
     */
    distinct?: ExtractedResumeScalarFieldEnum | ExtractedResumeScalarFieldEnum[]
  }

  /**
   * ExtractedResume findMany
   */
  export type ExtractedResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedResumes to fetch.
     */
    where?: ExtractedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedResumes to fetch.
     */
    orderBy?: ExtractedResumeOrderByWithRelationInput | ExtractedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtractedResumes.
     */
    cursor?: ExtractedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedResumes.
     */
    skip?: number
    distinct?: ExtractedResumeScalarFieldEnum | ExtractedResumeScalarFieldEnum[]
  }

  /**
   * ExtractedResume create
   */
  export type ExtractedResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a ExtractedResume.
     */
    data: XOR<ExtractedResumeCreateInput, ExtractedResumeUncheckedCreateInput>
  }

  /**
   * ExtractedResume createMany
   */
  export type ExtractedResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtractedResumes.
     */
    data: ExtractedResumeCreateManyInput | ExtractedResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtractedResume createManyAndReturn
   */
  export type ExtractedResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * The data used to create many ExtractedResumes.
     */
    data: ExtractedResumeCreateManyInput | ExtractedResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtractedResume update
   */
  export type ExtractedResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a ExtractedResume.
     */
    data: XOR<ExtractedResumeUpdateInput, ExtractedResumeUncheckedUpdateInput>
    /**
     * Choose, which ExtractedResume to update.
     */
    where: ExtractedResumeWhereUniqueInput
  }

  /**
   * ExtractedResume updateMany
   */
  export type ExtractedResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtractedResumes.
     */
    data: XOR<ExtractedResumeUpdateManyMutationInput, ExtractedResumeUncheckedUpdateManyInput>
    /**
     * Filter which ExtractedResumes to update
     */
    where?: ExtractedResumeWhereInput
    /**
     * Limit how many ExtractedResumes to update.
     */
    limit?: number
  }

  /**
   * ExtractedResume updateManyAndReturn
   */
  export type ExtractedResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * The data used to update ExtractedResumes.
     */
    data: XOR<ExtractedResumeUpdateManyMutationInput, ExtractedResumeUncheckedUpdateManyInput>
    /**
     * Filter which ExtractedResumes to update
     */
    where?: ExtractedResumeWhereInput
    /**
     * Limit how many ExtractedResumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtractedResume upsert
   */
  export type ExtractedResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the ExtractedResume to update in case it exists.
     */
    where: ExtractedResumeWhereUniqueInput
    /**
     * In case the ExtractedResume found by the `where` argument doesn't exist, create a new ExtractedResume with this data.
     */
    create: XOR<ExtractedResumeCreateInput, ExtractedResumeUncheckedCreateInput>
    /**
     * In case the ExtractedResume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtractedResumeUpdateInput, ExtractedResumeUncheckedUpdateInput>
  }

  /**
   * ExtractedResume delete
   */
  export type ExtractedResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    /**
     * Filter which ExtractedResume to delete.
     */
    where: ExtractedResumeWhereUniqueInput
  }

  /**
   * ExtractedResume deleteMany
   */
  export type ExtractedResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtractedResumes to delete
     */
    where?: ExtractedResumeWhereInput
    /**
     * Limit how many ExtractedResumes to delete.
     */
    limit?: number
  }

  /**
   * ExtractedResume.llmCalls
   */
  export type ExtractedResume$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * ExtractedResume.summarizedResumes
   */
  export type ExtractedResume$summarizedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    where?: SummarizedResumeWhereInput
    orderBy?: SummarizedResumeOrderByWithRelationInput | SummarizedResumeOrderByWithRelationInput[]
    cursor?: SummarizedResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummarizedResumeScalarFieldEnum | SummarizedResumeScalarFieldEnum[]
  }

  /**
   * ExtractedResume.generatedRoasts
   */
  export type ExtractedResume$generatedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    cursor?: GeneratedRoastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * ExtractedResume.generatedCoverLetters
   */
  export type ExtractedResume$generatedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    where?: GeneratedCoverLetterWhereInput
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    cursor?: GeneratedCoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * ExtractedResume.generatedResumes
   */
  export type ExtractedResume$generatedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    where?: GeneratedResumeWhereInput
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    cursor?: GeneratedResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * ExtractedResume.generatedInterviewPreps
   */
  export type ExtractedResume$generatedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    where?: GeneratedInterviewPrepWhereInput
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * ExtractedResume without action
   */
  export type ExtractedResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
  }


  /**
   * Model ExtractedJobDescription
   */

  export type AggregateExtractedJobDescription = {
    _count: ExtractedJobDescriptionCountAggregateOutputType | null
    _min: ExtractedJobDescriptionMinAggregateOutputType | null
    _max: ExtractedJobDescriptionMaxAggregateOutputType | null
  }

  export type ExtractedJobDescriptionMinAggregateOutputType = {
    id: string | null
    contentHash: string | null
    originalText: string | null
    createdAt: Date | null
  }

  export type ExtractedJobDescriptionMaxAggregateOutputType = {
    id: string | null
    contentHash: string | null
    originalText: string | null
    createdAt: Date | null
  }

  export type ExtractedJobDescriptionCountAggregateOutputType = {
    id: number
    contentHash: number
    originalText: number
    data: number
    createdAt: number
    _all: number
  }


  export type ExtractedJobDescriptionMinAggregateInputType = {
    id?: true
    contentHash?: true
    originalText?: true
    createdAt?: true
  }

  export type ExtractedJobDescriptionMaxAggregateInputType = {
    id?: true
    contentHash?: true
    originalText?: true
    createdAt?: true
  }

  export type ExtractedJobDescriptionCountAggregateInputType = {
    id?: true
    contentHash?: true
    originalText?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type ExtractedJobDescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtractedJobDescription to aggregate.
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedJobDescriptions to fetch.
     */
    orderBy?: ExtractedJobDescriptionOrderByWithRelationInput | ExtractedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtractedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedJobDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtractedJobDescriptions
    **/
    _count?: true | ExtractedJobDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtractedJobDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtractedJobDescriptionMaxAggregateInputType
  }

  export type GetExtractedJobDescriptionAggregateType<T extends ExtractedJobDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateExtractedJobDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtractedJobDescription[P]>
      : GetScalarType<T[P], AggregateExtractedJobDescription[P]>
  }




  export type ExtractedJobDescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtractedJobDescriptionWhereInput
    orderBy?: ExtractedJobDescriptionOrderByWithAggregationInput | ExtractedJobDescriptionOrderByWithAggregationInput[]
    by: ExtractedJobDescriptionScalarFieldEnum[] | ExtractedJobDescriptionScalarFieldEnum
    having?: ExtractedJobDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtractedJobDescriptionCountAggregateInputType | true
    _min?: ExtractedJobDescriptionMinAggregateInputType
    _max?: ExtractedJobDescriptionMaxAggregateInputType
  }

  export type ExtractedJobDescriptionGroupByOutputType = {
    id: string
    contentHash: string
    originalText: string
    data: JsonValue
    createdAt: Date
    _count: ExtractedJobDescriptionCountAggregateOutputType | null
    _min: ExtractedJobDescriptionMinAggregateOutputType | null
    _max: ExtractedJobDescriptionMaxAggregateOutputType | null
  }

  type GetExtractedJobDescriptionGroupByPayload<T extends ExtractedJobDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtractedJobDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtractedJobDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtractedJobDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ExtractedJobDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type ExtractedJobDescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentHash?: boolean
    originalText?: boolean
    data?: boolean
    createdAt?: boolean
    llmCalls?: boolean | ExtractedJobDescription$llmCallsArgs<ExtArgs>
    summarizedJobDescriptions?: boolean | ExtractedJobDescription$summarizedJobDescriptionsArgs<ExtArgs>
    generatedRoasts?: boolean | ExtractedJobDescription$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | ExtractedJobDescription$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | ExtractedJobDescription$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | ExtractedJobDescription$generatedInterviewPrepsArgs<ExtArgs>
    _count?: boolean | ExtractedJobDescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extractedJobDescription"]>

  export type ExtractedJobDescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentHash?: boolean
    originalText?: boolean
    data?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["extractedJobDescription"]>

  export type ExtractedJobDescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentHash?: boolean
    originalText?: boolean
    data?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["extractedJobDescription"]>

  export type ExtractedJobDescriptionSelectScalar = {
    id?: boolean
    contentHash?: boolean
    originalText?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type ExtractedJobDescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentHash" | "originalText" | "data" | "createdAt", ExtArgs["result"]["extractedJobDescription"]>
  export type ExtractedJobDescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    llmCalls?: boolean | ExtractedJobDescription$llmCallsArgs<ExtArgs>
    summarizedJobDescriptions?: boolean | ExtractedJobDescription$summarizedJobDescriptionsArgs<ExtArgs>
    generatedRoasts?: boolean | ExtractedJobDescription$generatedRoastsArgs<ExtArgs>
    generatedCoverLetters?: boolean | ExtractedJobDescription$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | ExtractedJobDescription$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | ExtractedJobDescription$generatedInterviewPrepsArgs<ExtArgs>
    _count?: boolean | ExtractedJobDescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExtractedJobDescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExtractedJobDescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExtractedJobDescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtractedJobDescription"
    objects: {
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
      summarizedJobDescriptions: Prisma.$SummarizedJobDescriptionPayload<ExtArgs>[]
      generatedRoasts: Prisma.$GeneratedRoastPayload<ExtArgs>[]
      generatedCoverLetters: Prisma.$GeneratedCoverLetterPayload<ExtArgs>[]
      generatedResumes: Prisma.$GeneratedResumePayload<ExtArgs>[]
      generatedInterviewPreps: Prisma.$GeneratedInterviewPrepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentHash: string
      originalText: string
      data: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["extractedJobDescription"]>
    composites: {}
  }

  type ExtractedJobDescriptionGetPayload<S extends boolean | null | undefined | ExtractedJobDescriptionDefaultArgs> = $Result.GetResult<Prisma.$ExtractedJobDescriptionPayload, S>

  type ExtractedJobDescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExtractedJobDescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtractedJobDescriptionCountAggregateInputType | true
    }

  export interface ExtractedJobDescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtractedJobDescription'], meta: { name: 'ExtractedJobDescription' } }
    /**
     * Find zero or one ExtractedJobDescription that matches the filter.
     * @param {ExtractedJobDescriptionFindUniqueArgs} args - Arguments to find a ExtractedJobDescription
     * @example
     * // Get one ExtractedJobDescription
     * const extractedJobDescription = await prisma.extractedJobDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtractedJobDescriptionFindUniqueArgs>(args: SelectSubset<T, ExtractedJobDescriptionFindUniqueArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExtractedJobDescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExtractedJobDescriptionFindUniqueOrThrowArgs} args - Arguments to find a ExtractedJobDescription
     * @example
     * // Get one ExtractedJobDescription
     * const extractedJobDescription = await prisma.extractedJobDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtractedJobDescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExtractedJobDescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExtractedJobDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionFindFirstArgs} args - Arguments to find a ExtractedJobDescription
     * @example
     * // Get one ExtractedJobDescription
     * const extractedJobDescription = await prisma.extractedJobDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtractedJobDescriptionFindFirstArgs>(args?: SelectSubset<T, ExtractedJobDescriptionFindFirstArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExtractedJobDescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionFindFirstOrThrowArgs} args - Arguments to find a ExtractedJobDescription
     * @example
     * // Get one ExtractedJobDescription
     * const extractedJobDescription = await prisma.extractedJobDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtractedJobDescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExtractedJobDescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExtractedJobDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtractedJobDescriptions
     * const extractedJobDescriptions = await prisma.extractedJobDescription.findMany()
     * 
     * // Get first 10 ExtractedJobDescriptions
     * const extractedJobDescriptions = await prisma.extractedJobDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extractedJobDescriptionWithIdOnly = await prisma.extractedJobDescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExtractedJobDescriptionFindManyArgs>(args?: SelectSubset<T, ExtractedJobDescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExtractedJobDescription.
     * @param {ExtractedJobDescriptionCreateArgs} args - Arguments to create a ExtractedJobDescription.
     * @example
     * // Create one ExtractedJobDescription
     * const ExtractedJobDescription = await prisma.extractedJobDescription.create({
     *   data: {
     *     // ... data to create a ExtractedJobDescription
     *   }
     * })
     * 
     */
    create<T extends ExtractedJobDescriptionCreateArgs>(args: SelectSubset<T, ExtractedJobDescriptionCreateArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExtractedJobDescriptions.
     * @param {ExtractedJobDescriptionCreateManyArgs} args - Arguments to create many ExtractedJobDescriptions.
     * @example
     * // Create many ExtractedJobDescriptions
     * const extractedJobDescription = await prisma.extractedJobDescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExtractedJobDescriptionCreateManyArgs>(args?: SelectSubset<T, ExtractedJobDescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExtractedJobDescriptions and returns the data saved in the database.
     * @param {ExtractedJobDescriptionCreateManyAndReturnArgs} args - Arguments to create many ExtractedJobDescriptions.
     * @example
     * // Create many ExtractedJobDescriptions
     * const extractedJobDescription = await prisma.extractedJobDescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExtractedJobDescriptions and only return the `id`
     * const extractedJobDescriptionWithIdOnly = await prisma.extractedJobDescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExtractedJobDescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExtractedJobDescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExtractedJobDescription.
     * @param {ExtractedJobDescriptionDeleteArgs} args - Arguments to delete one ExtractedJobDescription.
     * @example
     * // Delete one ExtractedJobDescription
     * const ExtractedJobDescription = await prisma.extractedJobDescription.delete({
     *   where: {
     *     // ... filter to delete one ExtractedJobDescription
     *   }
     * })
     * 
     */
    delete<T extends ExtractedJobDescriptionDeleteArgs>(args: SelectSubset<T, ExtractedJobDescriptionDeleteArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExtractedJobDescription.
     * @param {ExtractedJobDescriptionUpdateArgs} args - Arguments to update one ExtractedJobDescription.
     * @example
     * // Update one ExtractedJobDescription
     * const extractedJobDescription = await prisma.extractedJobDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExtractedJobDescriptionUpdateArgs>(args: SelectSubset<T, ExtractedJobDescriptionUpdateArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExtractedJobDescriptions.
     * @param {ExtractedJobDescriptionDeleteManyArgs} args - Arguments to filter ExtractedJobDescriptions to delete.
     * @example
     * // Delete a few ExtractedJobDescriptions
     * const { count } = await prisma.extractedJobDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExtractedJobDescriptionDeleteManyArgs>(args?: SelectSubset<T, ExtractedJobDescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtractedJobDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtractedJobDescriptions
     * const extractedJobDescription = await prisma.extractedJobDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExtractedJobDescriptionUpdateManyArgs>(args: SelectSubset<T, ExtractedJobDescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtractedJobDescriptions and returns the data updated in the database.
     * @param {ExtractedJobDescriptionUpdateManyAndReturnArgs} args - Arguments to update many ExtractedJobDescriptions.
     * @example
     * // Update many ExtractedJobDescriptions
     * const extractedJobDescription = await prisma.extractedJobDescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExtractedJobDescriptions and only return the `id`
     * const extractedJobDescriptionWithIdOnly = await prisma.extractedJobDescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExtractedJobDescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExtractedJobDescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExtractedJobDescription.
     * @param {ExtractedJobDescriptionUpsertArgs} args - Arguments to update or create a ExtractedJobDescription.
     * @example
     * // Update or create a ExtractedJobDescription
     * const extractedJobDescription = await prisma.extractedJobDescription.upsert({
     *   create: {
     *     // ... data to create a ExtractedJobDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtractedJobDescription we want to update
     *   }
     * })
     */
    upsert<T extends ExtractedJobDescriptionUpsertArgs>(args: SelectSubset<T, ExtractedJobDescriptionUpsertArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExtractedJobDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionCountArgs} args - Arguments to filter ExtractedJobDescriptions to count.
     * @example
     * // Count the number of ExtractedJobDescriptions
     * const count = await prisma.extractedJobDescription.count({
     *   where: {
     *     // ... the filter for the ExtractedJobDescriptions we want to count
     *   }
     * })
    **/
    count<T extends ExtractedJobDescriptionCountArgs>(
      args?: Subset<T, ExtractedJobDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtractedJobDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtractedJobDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtractedJobDescriptionAggregateArgs>(args: Subset<T, ExtractedJobDescriptionAggregateArgs>): Prisma.PrismaPromise<GetExtractedJobDescriptionAggregateType<T>>

    /**
     * Group by ExtractedJobDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtractedJobDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtractedJobDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtractedJobDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: ExtractedJobDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtractedJobDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtractedJobDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtractedJobDescription model
   */
  readonly fields: ExtractedJobDescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtractedJobDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtractedJobDescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    llmCalls<T extends ExtractedJobDescription$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescription$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    summarizedJobDescriptions<T extends ExtractedJobDescription$summarizedJobDescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescription$summarizedJobDescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedRoasts<T extends ExtractedJobDescription$generatedRoastsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescription$generatedRoastsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedCoverLetters<T extends ExtractedJobDescription$generatedCoverLettersArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescription$generatedCoverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedResumes<T extends ExtractedJobDescription$generatedResumesArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescription$generatedResumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedInterviewPreps<T extends ExtractedJobDescription$generatedInterviewPrepsArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescription$generatedInterviewPrepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExtractedJobDescription model
   */
  interface ExtractedJobDescriptionFieldRefs {
    readonly id: FieldRef<"ExtractedJobDescription", 'String'>
    readonly contentHash: FieldRef<"ExtractedJobDescription", 'String'>
    readonly originalText: FieldRef<"ExtractedJobDescription", 'String'>
    readonly data: FieldRef<"ExtractedJobDescription", 'Json'>
    readonly createdAt: FieldRef<"ExtractedJobDescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExtractedJobDescription findUnique
   */
  export type ExtractedJobDescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedJobDescription to fetch.
     */
    where: ExtractedJobDescriptionWhereUniqueInput
  }

  /**
   * ExtractedJobDescription findUniqueOrThrow
   */
  export type ExtractedJobDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedJobDescription to fetch.
     */
    where: ExtractedJobDescriptionWhereUniqueInput
  }

  /**
   * ExtractedJobDescription findFirst
   */
  export type ExtractedJobDescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedJobDescription to fetch.
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedJobDescriptions to fetch.
     */
    orderBy?: ExtractedJobDescriptionOrderByWithRelationInput | ExtractedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtractedJobDescriptions.
     */
    cursor?: ExtractedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedJobDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtractedJobDescriptions.
     */
    distinct?: ExtractedJobDescriptionScalarFieldEnum | ExtractedJobDescriptionScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription findFirstOrThrow
   */
  export type ExtractedJobDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedJobDescription to fetch.
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedJobDescriptions to fetch.
     */
    orderBy?: ExtractedJobDescriptionOrderByWithRelationInput | ExtractedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtractedJobDescriptions.
     */
    cursor?: ExtractedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedJobDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtractedJobDescriptions.
     */
    distinct?: ExtractedJobDescriptionScalarFieldEnum | ExtractedJobDescriptionScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription findMany
   */
  export type ExtractedJobDescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which ExtractedJobDescriptions to fetch.
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtractedJobDescriptions to fetch.
     */
    orderBy?: ExtractedJobDescriptionOrderByWithRelationInput | ExtractedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtractedJobDescriptions.
     */
    cursor?: ExtractedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtractedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtractedJobDescriptions.
     */
    skip?: number
    distinct?: ExtractedJobDescriptionScalarFieldEnum | ExtractedJobDescriptionScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription create
   */
  export type ExtractedJobDescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExtractedJobDescription.
     */
    data: XOR<ExtractedJobDescriptionCreateInput, ExtractedJobDescriptionUncheckedCreateInput>
  }

  /**
   * ExtractedJobDescription createMany
   */
  export type ExtractedJobDescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtractedJobDescriptions.
     */
    data: ExtractedJobDescriptionCreateManyInput | ExtractedJobDescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtractedJobDescription createManyAndReturn
   */
  export type ExtractedJobDescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many ExtractedJobDescriptions.
     */
    data: ExtractedJobDescriptionCreateManyInput | ExtractedJobDescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtractedJobDescription update
   */
  export type ExtractedJobDescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExtractedJobDescription.
     */
    data: XOR<ExtractedJobDescriptionUpdateInput, ExtractedJobDescriptionUncheckedUpdateInput>
    /**
     * Choose, which ExtractedJobDescription to update.
     */
    where: ExtractedJobDescriptionWhereUniqueInput
  }

  /**
   * ExtractedJobDescription updateMany
   */
  export type ExtractedJobDescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtractedJobDescriptions.
     */
    data: XOR<ExtractedJobDescriptionUpdateManyMutationInput, ExtractedJobDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which ExtractedJobDescriptions to update
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * Limit how many ExtractedJobDescriptions to update.
     */
    limit?: number
  }

  /**
   * ExtractedJobDescription updateManyAndReturn
   */
  export type ExtractedJobDescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * The data used to update ExtractedJobDescriptions.
     */
    data: XOR<ExtractedJobDescriptionUpdateManyMutationInput, ExtractedJobDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which ExtractedJobDescriptions to update
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * Limit how many ExtractedJobDescriptions to update.
     */
    limit?: number
  }

  /**
   * ExtractedJobDescription upsert
   */
  export type ExtractedJobDescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExtractedJobDescription to update in case it exists.
     */
    where: ExtractedJobDescriptionWhereUniqueInput
    /**
     * In case the ExtractedJobDescription found by the `where` argument doesn't exist, create a new ExtractedJobDescription with this data.
     */
    create: XOR<ExtractedJobDescriptionCreateInput, ExtractedJobDescriptionUncheckedCreateInput>
    /**
     * In case the ExtractedJobDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtractedJobDescriptionUpdateInput, ExtractedJobDescriptionUncheckedUpdateInput>
  }

  /**
   * ExtractedJobDescription delete
   */
  export type ExtractedJobDescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter which ExtractedJobDescription to delete.
     */
    where: ExtractedJobDescriptionWhereUniqueInput
  }

  /**
   * ExtractedJobDescription deleteMany
   */
  export type ExtractedJobDescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtractedJobDescriptions to delete
     */
    where?: ExtractedJobDescriptionWhereInput
    /**
     * Limit how many ExtractedJobDescriptions to delete.
     */
    limit?: number
  }

  /**
   * ExtractedJobDescription.llmCalls
   */
  export type ExtractedJobDescription$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription.summarizedJobDescriptions
   */
  export type ExtractedJobDescription$summarizedJobDescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    where?: SummarizedJobDescriptionWhereInput
    orderBy?: SummarizedJobDescriptionOrderByWithRelationInput | SummarizedJobDescriptionOrderByWithRelationInput[]
    cursor?: SummarizedJobDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SummarizedJobDescriptionScalarFieldEnum | SummarizedJobDescriptionScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription.generatedRoasts
   */
  export type ExtractedJobDescription$generatedRoastsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    cursor?: GeneratedRoastWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription.generatedCoverLetters
   */
  export type ExtractedJobDescription$generatedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    where?: GeneratedCoverLetterWhereInput
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    cursor?: GeneratedCoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription.generatedResumes
   */
  export type ExtractedJobDescription$generatedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    where?: GeneratedResumeWhereInput
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    cursor?: GeneratedResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription.generatedInterviewPreps
   */
  export type ExtractedJobDescription$generatedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    where?: GeneratedInterviewPrepWhereInput
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * ExtractedJobDescription without action
   */
  export type ExtractedJobDescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
  }


  /**
   * Model SummarizedResume
   */

  export type AggregateSummarizedResume = {
    _count: SummarizedResumeCountAggregateOutputType | null
    _min: SummarizedResumeMinAggregateOutputType | null
    _max: SummarizedResumeMaxAggregateOutputType | null
  }

  export type SummarizedResumeMinAggregateOutputType = {
    id: string | null
    extractedResumeId: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type SummarizedResumeMaxAggregateOutputType = {
    id: string | null
    extractedResumeId: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type SummarizedResumeCountAggregateOutputType = {
    id: number
    extractedResumeId: number
    contentHash: number
    summary: number
    createdAt: number
    _all: number
  }


  export type SummarizedResumeMinAggregateInputType = {
    id?: true
    extractedResumeId?: true
    contentHash?: true
    createdAt?: true
  }

  export type SummarizedResumeMaxAggregateInputType = {
    id?: true
    extractedResumeId?: true
    contentHash?: true
    createdAt?: true
  }

  export type SummarizedResumeCountAggregateInputType = {
    id?: true
    extractedResumeId?: true
    contentHash?: true
    summary?: true
    createdAt?: true
    _all?: true
  }

  export type SummarizedResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummarizedResume to aggregate.
     */
    where?: SummarizedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedResumes to fetch.
     */
    orderBy?: SummarizedResumeOrderByWithRelationInput | SummarizedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummarizedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummarizedResumes
    **/
    _count?: true | SummarizedResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummarizedResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummarizedResumeMaxAggregateInputType
  }

  export type GetSummarizedResumeAggregateType<T extends SummarizedResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateSummarizedResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummarizedResume[P]>
      : GetScalarType<T[P], AggregateSummarizedResume[P]>
  }




  export type SummarizedResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummarizedResumeWhereInput
    orderBy?: SummarizedResumeOrderByWithAggregationInput | SummarizedResumeOrderByWithAggregationInput[]
    by: SummarizedResumeScalarFieldEnum[] | SummarizedResumeScalarFieldEnum
    having?: SummarizedResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummarizedResumeCountAggregateInputType | true
    _min?: SummarizedResumeMinAggregateInputType
    _max?: SummarizedResumeMaxAggregateInputType
  }

  export type SummarizedResumeGroupByOutputType = {
    id: string
    extractedResumeId: string
    contentHash: string
    summary: JsonValue
    createdAt: Date
    _count: SummarizedResumeCountAggregateOutputType | null
    _min: SummarizedResumeMinAggregateOutputType | null
    _max: SummarizedResumeMaxAggregateOutputType | null
  }

  type GetSummarizedResumeGroupByPayload<T extends SummarizedResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummarizedResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummarizedResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummarizedResumeGroupByOutputType[P]>
            : GetScalarType<T[P], SummarizedResumeGroupByOutputType[P]>
        }
      >
    >


  export type SummarizedResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extractedResumeId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
    extractedResume?: boolean | ExtractedResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summarizedResume"]>

  export type SummarizedResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extractedResumeId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
    extractedResume?: boolean | ExtractedResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summarizedResume"]>

  export type SummarizedResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extractedResumeId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
    extractedResume?: boolean | ExtractedResumeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summarizedResume"]>

  export type SummarizedResumeSelectScalar = {
    id?: boolean
    extractedResumeId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
  }

  export type SummarizedResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "extractedResumeId" | "contentHash" | "summary" | "createdAt", ExtArgs["result"]["summarizedResume"]>
  export type SummarizedResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extractedResume?: boolean | ExtractedResumeDefaultArgs<ExtArgs>
  }
  export type SummarizedResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extractedResume?: boolean | ExtractedResumeDefaultArgs<ExtArgs>
  }
  export type SummarizedResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extractedResume?: boolean | ExtractedResumeDefaultArgs<ExtArgs>
  }

  export type $SummarizedResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummarizedResume"
    objects: {
      extractedResume: Prisma.$ExtractedResumePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      extractedResumeId: string
      contentHash: string
      summary: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["summarizedResume"]>
    composites: {}
  }

  type SummarizedResumeGetPayload<S extends boolean | null | undefined | SummarizedResumeDefaultArgs> = $Result.GetResult<Prisma.$SummarizedResumePayload, S>

  type SummarizedResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummarizedResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummarizedResumeCountAggregateInputType | true
    }

  export interface SummarizedResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummarizedResume'], meta: { name: 'SummarizedResume' } }
    /**
     * Find zero or one SummarizedResume that matches the filter.
     * @param {SummarizedResumeFindUniqueArgs} args - Arguments to find a SummarizedResume
     * @example
     * // Get one SummarizedResume
     * const summarizedResume = await prisma.summarizedResume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummarizedResumeFindUniqueArgs>(args: SelectSubset<T, SummarizedResumeFindUniqueArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummarizedResume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummarizedResumeFindUniqueOrThrowArgs} args - Arguments to find a SummarizedResume
     * @example
     * // Get one SummarizedResume
     * const summarizedResume = await prisma.summarizedResume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummarizedResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, SummarizedResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummarizedResume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeFindFirstArgs} args - Arguments to find a SummarizedResume
     * @example
     * // Get one SummarizedResume
     * const summarizedResume = await prisma.summarizedResume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummarizedResumeFindFirstArgs>(args?: SelectSubset<T, SummarizedResumeFindFirstArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummarizedResume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeFindFirstOrThrowArgs} args - Arguments to find a SummarizedResume
     * @example
     * // Get one SummarizedResume
     * const summarizedResume = await prisma.summarizedResume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummarizedResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, SummarizedResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummarizedResumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummarizedResumes
     * const summarizedResumes = await prisma.summarizedResume.findMany()
     * 
     * // Get first 10 SummarizedResumes
     * const summarizedResumes = await prisma.summarizedResume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summarizedResumeWithIdOnly = await prisma.summarizedResume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummarizedResumeFindManyArgs>(args?: SelectSubset<T, SummarizedResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummarizedResume.
     * @param {SummarizedResumeCreateArgs} args - Arguments to create a SummarizedResume.
     * @example
     * // Create one SummarizedResume
     * const SummarizedResume = await prisma.summarizedResume.create({
     *   data: {
     *     // ... data to create a SummarizedResume
     *   }
     * })
     * 
     */
    create<T extends SummarizedResumeCreateArgs>(args: SelectSubset<T, SummarizedResumeCreateArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummarizedResumes.
     * @param {SummarizedResumeCreateManyArgs} args - Arguments to create many SummarizedResumes.
     * @example
     * // Create many SummarizedResumes
     * const summarizedResume = await prisma.summarizedResume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummarizedResumeCreateManyArgs>(args?: SelectSubset<T, SummarizedResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummarizedResumes and returns the data saved in the database.
     * @param {SummarizedResumeCreateManyAndReturnArgs} args - Arguments to create many SummarizedResumes.
     * @example
     * // Create many SummarizedResumes
     * const summarizedResume = await prisma.summarizedResume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummarizedResumes and only return the `id`
     * const summarizedResumeWithIdOnly = await prisma.summarizedResume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummarizedResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, SummarizedResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummarizedResume.
     * @param {SummarizedResumeDeleteArgs} args - Arguments to delete one SummarizedResume.
     * @example
     * // Delete one SummarizedResume
     * const SummarizedResume = await prisma.summarizedResume.delete({
     *   where: {
     *     // ... filter to delete one SummarizedResume
     *   }
     * })
     * 
     */
    delete<T extends SummarizedResumeDeleteArgs>(args: SelectSubset<T, SummarizedResumeDeleteArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummarizedResume.
     * @param {SummarizedResumeUpdateArgs} args - Arguments to update one SummarizedResume.
     * @example
     * // Update one SummarizedResume
     * const summarizedResume = await prisma.summarizedResume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummarizedResumeUpdateArgs>(args: SelectSubset<T, SummarizedResumeUpdateArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummarizedResumes.
     * @param {SummarizedResumeDeleteManyArgs} args - Arguments to filter SummarizedResumes to delete.
     * @example
     * // Delete a few SummarizedResumes
     * const { count } = await prisma.summarizedResume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummarizedResumeDeleteManyArgs>(args?: SelectSubset<T, SummarizedResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummarizedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummarizedResumes
     * const summarizedResume = await prisma.summarizedResume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummarizedResumeUpdateManyArgs>(args: SelectSubset<T, SummarizedResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummarizedResumes and returns the data updated in the database.
     * @param {SummarizedResumeUpdateManyAndReturnArgs} args - Arguments to update many SummarizedResumes.
     * @example
     * // Update many SummarizedResumes
     * const summarizedResume = await prisma.summarizedResume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummarizedResumes and only return the `id`
     * const summarizedResumeWithIdOnly = await prisma.summarizedResume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummarizedResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, SummarizedResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummarizedResume.
     * @param {SummarizedResumeUpsertArgs} args - Arguments to update or create a SummarizedResume.
     * @example
     * // Update or create a SummarizedResume
     * const summarizedResume = await prisma.summarizedResume.upsert({
     *   create: {
     *     // ... data to create a SummarizedResume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummarizedResume we want to update
     *   }
     * })
     */
    upsert<T extends SummarizedResumeUpsertArgs>(args: SelectSubset<T, SummarizedResumeUpsertArgs<ExtArgs>>): Prisma__SummarizedResumeClient<$Result.GetResult<Prisma.$SummarizedResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummarizedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeCountArgs} args - Arguments to filter SummarizedResumes to count.
     * @example
     * // Count the number of SummarizedResumes
     * const count = await prisma.summarizedResume.count({
     *   where: {
     *     // ... the filter for the SummarizedResumes we want to count
     *   }
     * })
    **/
    count<T extends SummarizedResumeCountArgs>(
      args?: Subset<T, SummarizedResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummarizedResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummarizedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummarizedResumeAggregateArgs>(args: Subset<T, SummarizedResumeAggregateArgs>): Prisma.PrismaPromise<GetSummarizedResumeAggregateType<T>>

    /**
     * Group by SummarizedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummarizedResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummarizedResumeGroupByArgs['orderBy'] }
        : { orderBy?: SummarizedResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummarizedResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummarizedResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummarizedResume model
   */
  readonly fields: SummarizedResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummarizedResume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummarizedResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    extractedResume<T extends ExtractedResumeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedResumeDefaultArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummarizedResume model
   */
  interface SummarizedResumeFieldRefs {
    readonly id: FieldRef<"SummarizedResume", 'String'>
    readonly extractedResumeId: FieldRef<"SummarizedResume", 'String'>
    readonly contentHash: FieldRef<"SummarizedResume", 'String'>
    readonly summary: FieldRef<"SummarizedResume", 'Json'>
    readonly createdAt: FieldRef<"SummarizedResume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SummarizedResume findUnique
   */
  export type SummarizedResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedResume to fetch.
     */
    where: SummarizedResumeWhereUniqueInput
  }

  /**
   * SummarizedResume findUniqueOrThrow
   */
  export type SummarizedResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedResume to fetch.
     */
    where: SummarizedResumeWhereUniqueInput
  }

  /**
   * SummarizedResume findFirst
   */
  export type SummarizedResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedResume to fetch.
     */
    where?: SummarizedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedResumes to fetch.
     */
    orderBy?: SummarizedResumeOrderByWithRelationInput | SummarizedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummarizedResumes.
     */
    cursor?: SummarizedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummarizedResumes.
     */
    distinct?: SummarizedResumeScalarFieldEnum | SummarizedResumeScalarFieldEnum[]
  }

  /**
   * SummarizedResume findFirstOrThrow
   */
  export type SummarizedResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedResume to fetch.
     */
    where?: SummarizedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedResumes to fetch.
     */
    orderBy?: SummarizedResumeOrderByWithRelationInput | SummarizedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummarizedResumes.
     */
    cursor?: SummarizedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummarizedResumes.
     */
    distinct?: SummarizedResumeScalarFieldEnum | SummarizedResumeScalarFieldEnum[]
  }

  /**
   * SummarizedResume findMany
   */
  export type SummarizedResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedResumes to fetch.
     */
    where?: SummarizedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedResumes to fetch.
     */
    orderBy?: SummarizedResumeOrderByWithRelationInput | SummarizedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummarizedResumes.
     */
    cursor?: SummarizedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedResumes.
     */
    skip?: number
    distinct?: SummarizedResumeScalarFieldEnum | SummarizedResumeScalarFieldEnum[]
  }

  /**
   * SummarizedResume create
   */
  export type SummarizedResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a SummarizedResume.
     */
    data: XOR<SummarizedResumeCreateInput, SummarizedResumeUncheckedCreateInput>
  }

  /**
   * SummarizedResume createMany
   */
  export type SummarizedResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummarizedResumes.
     */
    data: SummarizedResumeCreateManyInput | SummarizedResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummarizedResume createManyAndReturn
   */
  export type SummarizedResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * The data used to create many SummarizedResumes.
     */
    data: SummarizedResumeCreateManyInput | SummarizedResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummarizedResume update
   */
  export type SummarizedResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a SummarizedResume.
     */
    data: XOR<SummarizedResumeUpdateInput, SummarizedResumeUncheckedUpdateInput>
    /**
     * Choose, which SummarizedResume to update.
     */
    where: SummarizedResumeWhereUniqueInput
  }

  /**
   * SummarizedResume updateMany
   */
  export type SummarizedResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummarizedResumes.
     */
    data: XOR<SummarizedResumeUpdateManyMutationInput, SummarizedResumeUncheckedUpdateManyInput>
    /**
     * Filter which SummarizedResumes to update
     */
    where?: SummarizedResumeWhereInput
    /**
     * Limit how many SummarizedResumes to update.
     */
    limit?: number
  }

  /**
   * SummarizedResume updateManyAndReturn
   */
  export type SummarizedResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * The data used to update SummarizedResumes.
     */
    data: XOR<SummarizedResumeUpdateManyMutationInput, SummarizedResumeUncheckedUpdateManyInput>
    /**
     * Filter which SummarizedResumes to update
     */
    where?: SummarizedResumeWhereInput
    /**
     * Limit how many SummarizedResumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummarizedResume upsert
   */
  export type SummarizedResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the SummarizedResume to update in case it exists.
     */
    where: SummarizedResumeWhereUniqueInput
    /**
     * In case the SummarizedResume found by the `where` argument doesn't exist, create a new SummarizedResume with this data.
     */
    create: XOR<SummarizedResumeCreateInput, SummarizedResumeUncheckedCreateInput>
    /**
     * In case the SummarizedResume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummarizedResumeUpdateInput, SummarizedResumeUncheckedUpdateInput>
  }

  /**
   * SummarizedResume delete
   */
  export type SummarizedResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
    /**
     * Filter which SummarizedResume to delete.
     */
    where: SummarizedResumeWhereUniqueInput
  }

  /**
   * SummarizedResume deleteMany
   */
  export type SummarizedResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummarizedResumes to delete
     */
    where?: SummarizedResumeWhereInput
    /**
     * Limit how many SummarizedResumes to delete.
     */
    limit?: number
  }

  /**
   * SummarizedResume without action
   */
  export type SummarizedResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedResume
     */
    select?: SummarizedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedResume
     */
    omit?: SummarizedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedResumeInclude<ExtArgs> | null
  }


  /**
   * Model SummarizedJobDescription
   */

  export type AggregateSummarizedJobDescription = {
    _count: SummarizedJobDescriptionCountAggregateOutputType | null
    _min: SummarizedJobDescriptionMinAggregateOutputType | null
    _max: SummarizedJobDescriptionMaxAggregateOutputType | null
  }

  export type SummarizedJobDescriptionMinAggregateOutputType = {
    id: string | null
    extractedJobId: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type SummarizedJobDescriptionMaxAggregateOutputType = {
    id: string | null
    extractedJobId: string | null
    contentHash: string | null
    createdAt: Date | null
  }

  export type SummarizedJobDescriptionCountAggregateOutputType = {
    id: number
    extractedJobId: number
    contentHash: number
    summary: number
    createdAt: number
    _all: number
  }


  export type SummarizedJobDescriptionMinAggregateInputType = {
    id?: true
    extractedJobId?: true
    contentHash?: true
    createdAt?: true
  }

  export type SummarizedJobDescriptionMaxAggregateInputType = {
    id?: true
    extractedJobId?: true
    contentHash?: true
    createdAt?: true
  }

  export type SummarizedJobDescriptionCountAggregateInputType = {
    id?: true
    extractedJobId?: true
    contentHash?: true
    summary?: true
    createdAt?: true
    _all?: true
  }

  export type SummarizedJobDescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummarizedJobDescription to aggregate.
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedJobDescriptions to fetch.
     */
    orderBy?: SummarizedJobDescriptionOrderByWithRelationInput | SummarizedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SummarizedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedJobDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SummarizedJobDescriptions
    **/
    _count?: true | SummarizedJobDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SummarizedJobDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SummarizedJobDescriptionMaxAggregateInputType
  }

  export type GetSummarizedJobDescriptionAggregateType<T extends SummarizedJobDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSummarizedJobDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSummarizedJobDescription[P]>
      : GetScalarType<T[P], AggregateSummarizedJobDescription[P]>
  }




  export type SummarizedJobDescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SummarizedJobDescriptionWhereInput
    orderBy?: SummarizedJobDescriptionOrderByWithAggregationInput | SummarizedJobDescriptionOrderByWithAggregationInput[]
    by: SummarizedJobDescriptionScalarFieldEnum[] | SummarizedJobDescriptionScalarFieldEnum
    having?: SummarizedJobDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SummarizedJobDescriptionCountAggregateInputType | true
    _min?: SummarizedJobDescriptionMinAggregateInputType
    _max?: SummarizedJobDescriptionMaxAggregateInputType
  }

  export type SummarizedJobDescriptionGroupByOutputType = {
    id: string
    extractedJobId: string
    contentHash: string
    summary: JsonValue
    createdAt: Date
    _count: SummarizedJobDescriptionCountAggregateOutputType | null
    _min: SummarizedJobDescriptionMinAggregateOutputType | null
    _max: SummarizedJobDescriptionMaxAggregateOutputType | null
  }

  type GetSummarizedJobDescriptionGroupByPayload<T extends SummarizedJobDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SummarizedJobDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SummarizedJobDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SummarizedJobDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SummarizedJobDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type SummarizedJobDescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
    extractedJob?: boolean | ExtractedJobDescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summarizedJobDescription"]>

  export type SummarizedJobDescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
    extractedJob?: boolean | ExtractedJobDescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summarizedJobDescription"]>

  export type SummarizedJobDescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
    extractedJob?: boolean | ExtractedJobDescriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["summarizedJobDescription"]>

  export type SummarizedJobDescriptionSelectScalar = {
    id?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    summary?: boolean
    createdAt?: boolean
  }

  export type SummarizedJobDescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "extractedJobId" | "contentHash" | "summary" | "createdAt", ExtArgs["result"]["summarizedJobDescription"]>
  export type SummarizedJobDescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extractedJob?: boolean | ExtractedJobDescriptionDefaultArgs<ExtArgs>
  }
  export type SummarizedJobDescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extractedJob?: boolean | ExtractedJobDescriptionDefaultArgs<ExtArgs>
  }
  export type SummarizedJobDescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extractedJob?: boolean | ExtractedJobDescriptionDefaultArgs<ExtArgs>
  }

  export type $SummarizedJobDescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SummarizedJobDescription"
    objects: {
      extractedJob: Prisma.$ExtractedJobDescriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      extractedJobId: string
      contentHash: string
      summary: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["summarizedJobDescription"]>
    composites: {}
  }

  type SummarizedJobDescriptionGetPayload<S extends boolean | null | undefined | SummarizedJobDescriptionDefaultArgs> = $Result.GetResult<Prisma.$SummarizedJobDescriptionPayload, S>

  type SummarizedJobDescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SummarizedJobDescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SummarizedJobDescriptionCountAggregateInputType | true
    }

  export interface SummarizedJobDescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SummarizedJobDescription'], meta: { name: 'SummarizedJobDescription' } }
    /**
     * Find zero or one SummarizedJobDescription that matches the filter.
     * @param {SummarizedJobDescriptionFindUniqueArgs} args - Arguments to find a SummarizedJobDescription
     * @example
     * // Get one SummarizedJobDescription
     * const summarizedJobDescription = await prisma.summarizedJobDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SummarizedJobDescriptionFindUniqueArgs>(args: SelectSubset<T, SummarizedJobDescriptionFindUniqueArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SummarizedJobDescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SummarizedJobDescriptionFindUniqueOrThrowArgs} args - Arguments to find a SummarizedJobDescription
     * @example
     * // Get one SummarizedJobDescription
     * const summarizedJobDescription = await prisma.summarizedJobDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SummarizedJobDescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SummarizedJobDescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummarizedJobDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionFindFirstArgs} args - Arguments to find a SummarizedJobDescription
     * @example
     * // Get one SummarizedJobDescription
     * const summarizedJobDescription = await prisma.summarizedJobDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SummarizedJobDescriptionFindFirstArgs>(args?: SelectSubset<T, SummarizedJobDescriptionFindFirstArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SummarizedJobDescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionFindFirstOrThrowArgs} args - Arguments to find a SummarizedJobDescription
     * @example
     * // Get one SummarizedJobDescription
     * const summarizedJobDescription = await prisma.summarizedJobDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SummarizedJobDescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SummarizedJobDescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SummarizedJobDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SummarizedJobDescriptions
     * const summarizedJobDescriptions = await prisma.summarizedJobDescription.findMany()
     * 
     * // Get first 10 SummarizedJobDescriptions
     * const summarizedJobDescriptions = await prisma.summarizedJobDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const summarizedJobDescriptionWithIdOnly = await prisma.summarizedJobDescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SummarizedJobDescriptionFindManyArgs>(args?: SelectSubset<T, SummarizedJobDescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SummarizedJobDescription.
     * @param {SummarizedJobDescriptionCreateArgs} args - Arguments to create a SummarizedJobDescription.
     * @example
     * // Create one SummarizedJobDescription
     * const SummarizedJobDescription = await prisma.summarizedJobDescription.create({
     *   data: {
     *     // ... data to create a SummarizedJobDescription
     *   }
     * })
     * 
     */
    create<T extends SummarizedJobDescriptionCreateArgs>(args: SelectSubset<T, SummarizedJobDescriptionCreateArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SummarizedJobDescriptions.
     * @param {SummarizedJobDescriptionCreateManyArgs} args - Arguments to create many SummarizedJobDescriptions.
     * @example
     * // Create many SummarizedJobDescriptions
     * const summarizedJobDescription = await prisma.summarizedJobDescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SummarizedJobDescriptionCreateManyArgs>(args?: SelectSubset<T, SummarizedJobDescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SummarizedJobDescriptions and returns the data saved in the database.
     * @param {SummarizedJobDescriptionCreateManyAndReturnArgs} args - Arguments to create many SummarizedJobDescriptions.
     * @example
     * // Create many SummarizedJobDescriptions
     * const summarizedJobDescription = await prisma.summarizedJobDescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SummarizedJobDescriptions and only return the `id`
     * const summarizedJobDescriptionWithIdOnly = await prisma.summarizedJobDescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SummarizedJobDescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SummarizedJobDescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SummarizedJobDescription.
     * @param {SummarizedJobDescriptionDeleteArgs} args - Arguments to delete one SummarizedJobDescription.
     * @example
     * // Delete one SummarizedJobDescription
     * const SummarizedJobDescription = await prisma.summarizedJobDescription.delete({
     *   where: {
     *     // ... filter to delete one SummarizedJobDescription
     *   }
     * })
     * 
     */
    delete<T extends SummarizedJobDescriptionDeleteArgs>(args: SelectSubset<T, SummarizedJobDescriptionDeleteArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SummarizedJobDescription.
     * @param {SummarizedJobDescriptionUpdateArgs} args - Arguments to update one SummarizedJobDescription.
     * @example
     * // Update one SummarizedJobDescription
     * const summarizedJobDescription = await prisma.summarizedJobDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SummarizedJobDescriptionUpdateArgs>(args: SelectSubset<T, SummarizedJobDescriptionUpdateArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SummarizedJobDescriptions.
     * @param {SummarizedJobDescriptionDeleteManyArgs} args - Arguments to filter SummarizedJobDescriptions to delete.
     * @example
     * // Delete a few SummarizedJobDescriptions
     * const { count } = await prisma.summarizedJobDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SummarizedJobDescriptionDeleteManyArgs>(args?: SelectSubset<T, SummarizedJobDescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummarizedJobDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SummarizedJobDescriptions
     * const summarizedJobDescription = await prisma.summarizedJobDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SummarizedJobDescriptionUpdateManyArgs>(args: SelectSubset<T, SummarizedJobDescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SummarizedJobDescriptions and returns the data updated in the database.
     * @param {SummarizedJobDescriptionUpdateManyAndReturnArgs} args - Arguments to update many SummarizedJobDescriptions.
     * @example
     * // Update many SummarizedJobDescriptions
     * const summarizedJobDescription = await prisma.summarizedJobDescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SummarizedJobDescriptions and only return the `id`
     * const summarizedJobDescriptionWithIdOnly = await prisma.summarizedJobDescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SummarizedJobDescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SummarizedJobDescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SummarizedJobDescription.
     * @param {SummarizedJobDescriptionUpsertArgs} args - Arguments to update or create a SummarizedJobDescription.
     * @example
     * // Update or create a SummarizedJobDescription
     * const summarizedJobDescription = await prisma.summarizedJobDescription.upsert({
     *   create: {
     *     // ... data to create a SummarizedJobDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SummarizedJobDescription we want to update
     *   }
     * })
     */
    upsert<T extends SummarizedJobDescriptionUpsertArgs>(args: SelectSubset<T, SummarizedJobDescriptionUpsertArgs<ExtArgs>>): Prisma__SummarizedJobDescriptionClient<$Result.GetResult<Prisma.$SummarizedJobDescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SummarizedJobDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionCountArgs} args - Arguments to filter SummarizedJobDescriptions to count.
     * @example
     * // Count the number of SummarizedJobDescriptions
     * const count = await prisma.summarizedJobDescription.count({
     *   where: {
     *     // ... the filter for the SummarizedJobDescriptions we want to count
     *   }
     * })
    **/
    count<T extends SummarizedJobDescriptionCountArgs>(
      args?: Subset<T, SummarizedJobDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SummarizedJobDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SummarizedJobDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SummarizedJobDescriptionAggregateArgs>(args: Subset<T, SummarizedJobDescriptionAggregateArgs>): Prisma.PrismaPromise<GetSummarizedJobDescriptionAggregateType<T>>

    /**
     * Group by SummarizedJobDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SummarizedJobDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SummarizedJobDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SummarizedJobDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: SummarizedJobDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SummarizedJobDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSummarizedJobDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SummarizedJobDescription model
   */
  readonly fields: SummarizedJobDescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SummarizedJobDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SummarizedJobDescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    extractedJob<T extends ExtractedJobDescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExtractedJobDescriptionDefaultArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SummarizedJobDescription model
   */
  interface SummarizedJobDescriptionFieldRefs {
    readonly id: FieldRef<"SummarizedJobDescription", 'String'>
    readonly extractedJobId: FieldRef<"SummarizedJobDescription", 'String'>
    readonly contentHash: FieldRef<"SummarizedJobDescription", 'String'>
    readonly summary: FieldRef<"SummarizedJobDescription", 'Json'>
    readonly createdAt: FieldRef<"SummarizedJobDescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SummarizedJobDescription findUnique
   */
  export type SummarizedJobDescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedJobDescription to fetch.
     */
    where: SummarizedJobDescriptionWhereUniqueInput
  }

  /**
   * SummarizedJobDescription findUniqueOrThrow
   */
  export type SummarizedJobDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedJobDescription to fetch.
     */
    where: SummarizedJobDescriptionWhereUniqueInput
  }

  /**
   * SummarizedJobDescription findFirst
   */
  export type SummarizedJobDescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedJobDescription to fetch.
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedJobDescriptions to fetch.
     */
    orderBy?: SummarizedJobDescriptionOrderByWithRelationInput | SummarizedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummarizedJobDescriptions.
     */
    cursor?: SummarizedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedJobDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummarizedJobDescriptions.
     */
    distinct?: SummarizedJobDescriptionScalarFieldEnum | SummarizedJobDescriptionScalarFieldEnum[]
  }

  /**
   * SummarizedJobDescription findFirstOrThrow
   */
  export type SummarizedJobDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedJobDescription to fetch.
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedJobDescriptions to fetch.
     */
    orderBy?: SummarizedJobDescriptionOrderByWithRelationInput | SummarizedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SummarizedJobDescriptions.
     */
    cursor?: SummarizedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedJobDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SummarizedJobDescriptions.
     */
    distinct?: SummarizedJobDescriptionScalarFieldEnum | SummarizedJobDescriptionScalarFieldEnum[]
  }

  /**
   * SummarizedJobDescription findMany
   */
  export type SummarizedJobDescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which SummarizedJobDescriptions to fetch.
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SummarizedJobDescriptions to fetch.
     */
    orderBy?: SummarizedJobDescriptionOrderByWithRelationInput | SummarizedJobDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SummarizedJobDescriptions.
     */
    cursor?: SummarizedJobDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SummarizedJobDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SummarizedJobDescriptions.
     */
    skip?: number
    distinct?: SummarizedJobDescriptionScalarFieldEnum | SummarizedJobDescriptionScalarFieldEnum[]
  }

  /**
   * SummarizedJobDescription create
   */
  export type SummarizedJobDescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a SummarizedJobDescription.
     */
    data: XOR<SummarizedJobDescriptionCreateInput, SummarizedJobDescriptionUncheckedCreateInput>
  }

  /**
   * SummarizedJobDescription createMany
   */
  export type SummarizedJobDescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SummarizedJobDescriptions.
     */
    data: SummarizedJobDescriptionCreateManyInput | SummarizedJobDescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SummarizedJobDescription createManyAndReturn
   */
  export type SummarizedJobDescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many SummarizedJobDescriptions.
     */
    data: SummarizedJobDescriptionCreateManyInput | SummarizedJobDescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummarizedJobDescription update
   */
  export type SummarizedJobDescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a SummarizedJobDescription.
     */
    data: XOR<SummarizedJobDescriptionUpdateInput, SummarizedJobDescriptionUncheckedUpdateInput>
    /**
     * Choose, which SummarizedJobDescription to update.
     */
    where: SummarizedJobDescriptionWhereUniqueInput
  }

  /**
   * SummarizedJobDescription updateMany
   */
  export type SummarizedJobDescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SummarizedJobDescriptions.
     */
    data: XOR<SummarizedJobDescriptionUpdateManyMutationInput, SummarizedJobDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which SummarizedJobDescriptions to update
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * Limit how many SummarizedJobDescriptions to update.
     */
    limit?: number
  }

  /**
   * SummarizedJobDescription updateManyAndReturn
   */
  export type SummarizedJobDescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * The data used to update SummarizedJobDescriptions.
     */
    data: XOR<SummarizedJobDescriptionUpdateManyMutationInput, SummarizedJobDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which SummarizedJobDescriptions to update
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * Limit how many SummarizedJobDescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SummarizedJobDescription upsert
   */
  export type SummarizedJobDescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the SummarizedJobDescription to update in case it exists.
     */
    where: SummarizedJobDescriptionWhereUniqueInput
    /**
     * In case the SummarizedJobDescription found by the `where` argument doesn't exist, create a new SummarizedJobDescription with this data.
     */
    create: XOR<SummarizedJobDescriptionCreateInput, SummarizedJobDescriptionUncheckedCreateInput>
    /**
     * In case the SummarizedJobDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SummarizedJobDescriptionUpdateInput, SummarizedJobDescriptionUncheckedUpdateInput>
  }

  /**
   * SummarizedJobDescription delete
   */
  export type SummarizedJobDescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
    /**
     * Filter which SummarizedJobDescription to delete.
     */
    where: SummarizedJobDescriptionWhereUniqueInput
  }

  /**
   * SummarizedJobDescription deleteMany
   */
  export type SummarizedJobDescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SummarizedJobDescriptions to delete
     */
    where?: SummarizedJobDescriptionWhereInput
    /**
     * Limit how many SummarizedJobDescriptions to delete.
     */
    limit?: number
  }

  /**
   * SummarizedJobDescription without action
   */
  export type SummarizedJobDescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SummarizedJobDescription
     */
    select?: SummarizedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SummarizedJobDescription
     */
    omit?: SummarizedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SummarizedJobDescriptionInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedRoast
   */

  export type AggregateGeneratedRoast = {
    _count: GeneratedRoastCountAggregateOutputType | null
    _avg: GeneratedRoastAvgAggregateOutputType | null
    _sum: GeneratedRoastSumAggregateOutputType | null
    _min: GeneratedRoastMinAggregateOutputType | null
    _max: GeneratedRoastMaxAggregateOutputType | null
  }

  export type GeneratedRoastAvgAggregateOutputType = {
    overallScore: number | null
  }

  export type GeneratedRoastSumAggregateOutputType = {
    overallScore: number | null
  }

  export type GeneratedRoastMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string | null
    overallScore: number | null
    createdAt: Date | null
  }

  export type GeneratedRoastMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string | null
    overallScore: number | null
    createdAt: Date | null
  }

  export type GeneratedRoastCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    extractedResumeId: number
    extractedJobId: number
    contentHash: number
    data: number
    overallScore: number
    createdAt: number
    _all: number
  }


  export type GeneratedRoastAvgAggregateInputType = {
    overallScore?: true
  }

  export type GeneratedRoastSumAggregateInputType = {
    overallScore?: true
  }

  export type GeneratedRoastMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    overallScore?: true
    createdAt?: true
  }

  export type GeneratedRoastMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    overallScore?: true
    createdAt?: true
  }

  export type GeneratedRoastCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    data?: true
    overallScore?: true
    createdAt?: true
    _all?: true
  }

  export type GeneratedRoastAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedRoast to aggregate.
     */
    where?: GeneratedRoastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedRoasts to fetch.
     */
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedRoastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedRoasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedRoasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedRoasts
    **/
    _count?: true | GeneratedRoastCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneratedRoastAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneratedRoastSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedRoastMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedRoastMaxAggregateInputType
  }

  export type GetGeneratedRoastAggregateType<T extends GeneratedRoastAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedRoast]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedRoast[P]>
      : GetScalarType<T[P], AggregateGeneratedRoast[P]>
  }




  export type GeneratedRoastGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedRoastWhereInput
    orderBy?: GeneratedRoastOrderByWithAggregationInput | GeneratedRoastOrderByWithAggregationInput[]
    by: GeneratedRoastScalarFieldEnum[] | GeneratedRoastScalarFieldEnum
    having?: GeneratedRoastScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedRoastCountAggregateInputType | true
    _avg?: GeneratedRoastAvgAggregateInputType
    _sum?: GeneratedRoastSumAggregateInputType
    _min?: GeneratedRoastMinAggregateInputType
    _max?: GeneratedRoastMaxAggregateInputType
  }

  export type GeneratedRoastGroupByOutputType = {
    id: string
    userId: string | null
    resumeId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string
    data: JsonValue
    overallScore: number | null
    createdAt: Date
    _count: GeneratedRoastCountAggregateOutputType | null
    _avg: GeneratedRoastAvgAggregateOutputType | null
    _sum: GeneratedRoastSumAggregateOutputType | null
    _min: GeneratedRoastMinAggregateOutputType | null
    _max: GeneratedRoastMaxAggregateOutputType | null
  }

  type GetGeneratedRoastGroupByPayload<T extends GeneratedRoastGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedRoastGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedRoastGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedRoastGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedRoastGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedRoastSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    overallScore?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedRoast$userArgs<ExtArgs>
    resume?: boolean | GeneratedRoast$resumeArgs<ExtArgs>
    extractedResume?: boolean | GeneratedRoast$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedRoast$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedRoast$llmCallsArgs<ExtArgs>
    sharedAnalyses?: boolean | GeneratedRoast$sharedAnalysesArgs<ExtArgs>
    generatedCoverLetters?: boolean | GeneratedRoast$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | GeneratedRoast$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | GeneratedRoast$generatedInterviewPrepsArgs<ExtArgs>
    _count?: boolean | GeneratedRoastCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedRoast"]>

  export type GeneratedRoastSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    overallScore?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedRoast$userArgs<ExtArgs>
    resume?: boolean | GeneratedRoast$resumeArgs<ExtArgs>
    extractedResume?: boolean | GeneratedRoast$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedRoast$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedRoast"]>

  export type GeneratedRoastSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    overallScore?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedRoast$userArgs<ExtArgs>
    resume?: boolean | GeneratedRoast$resumeArgs<ExtArgs>
    extractedResume?: boolean | GeneratedRoast$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedRoast$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedRoast"]>

  export type GeneratedRoastSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    overallScore?: boolean
    createdAt?: boolean
  }

  export type GeneratedRoastOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "extractedResumeId" | "extractedJobId" | "contentHash" | "data" | "overallScore" | "createdAt", ExtArgs["result"]["generatedRoast"]>
  export type GeneratedRoastInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedRoast$userArgs<ExtArgs>
    resume?: boolean | GeneratedRoast$resumeArgs<ExtArgs>
    extractedResume?: boolean | GeneratedRoast$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedRoast$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedRoast$llmCallsArgs<ExtArgs>
    sharedAnalyses?: boolean | GeneratedRoast$sharedAnalysesArgs<ExtArgs>
    generatedCoverLetters?: boolean | GeneratedRoast$generatedCoverLettersArgs<ExtArgs>
    generatedResumes?: boolean | GeneratedRoast$generatedResumesArgs<ExtArgs>
    generatedInterviewPreps?: boolean | GeneratedRoast$generatedInterviewPrepsArgs<ExtArgs>
    _count?: boolean | GeneratedRoastCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneratedRoastIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedRoast$userArgs<ExtArgs>
    resume?: boolean | GeneratedRoast$resumeArgs<ExtArgs>
    extractedResume?: boolean | GeneratedRoast$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedRoast$extractedJobArgs<ExtArgs>
  }
  export type GeneratedRoastIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedRoast$userArgs<ExtArgs>
    resume?: boolean | GeneratedRoast$resumeArgs<ExtArgs>
    extractedResume?: boolean | GeneratedRoast$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedRoast$extractedJobArgs<ExtArgs>
  }

  export type $GeneratedRoastPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedRoast"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      resume: Prisma.$ResumePayload<ExtArgs> | null
      extractedResume: Prisma.$ExtractedResumePayload<ExtArgs> | null
      extractedJob: Prisma.$ExtractedJobDescriptionPayload<ExtArgs> | null
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
      sharedAnalyses: Prisma.$SharedAnalysisPayload<ExtArgs>[]
      generatedCoverLetters: Prisma.$GeneratedCoverLetterPayload<ExtArgs>[]
      generatedResumes: Prisma.$GeneratedResumePayload<ExtArgs>[]
      generatedInterviewPreps: Prisma.$GeneratedInterviewPrepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      resumeId: string | null
      extractedResumeId: string | null
      extractedJobId: string | null
      contentHash: string
      data: Prisma.JsonValue
      overallScore: number | null
      createdAt: Date
    }, ExtArgs["result"]["generatedRoast"]>
    composites: {}
  }

  type GeneratedRoastGetPayload<S extends boolean | null | undefined | GeneratedRoastDefaultArgs> = $Result.GetResult<Prisma.$GeneratedRoastPayload, S>

  type GeneratedRoastCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneratedRoastFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneratedRoastCountAggregateInputType | true
    }

  export interface GeneratedRoastDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedRoast'], meta: { name: 'GeneratedRoast' } }
    /**
     * Find zero or one GeneratedRoast that matches the filter.
     * @param {GeneratedRoastFindUniqueArgs} args - Arguments to find a GeneratedRoast
     * @example
     * // Get one GeneratedRoast
     * const generatedRoast = await prisma.generatedRoast.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedRoastFindUniqueArgs>(args: SelectSubset<T, GeneratedRoastFindUniqueArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneratedRoast that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedRoastFindUniqueOrThrowArgs} args - Arguments to find a GeneratedRoast
     * @example
     * // Get one GeneratedRoast
     * const generatedRoast = await prisma.generatedRoast.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedRoastFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedRoastFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedRoast that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastFindFirstArgs} args - Arguments to find a GeneratedRoast
     * @example
     * // Get one GeneratedRoast
     * const generatedRoast = await prisma.generatedRoast.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedRoastFindFirstArgs>(args?: SelectSubset<T, GeneratedRoastFindFirstArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedRoast that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastFindFirstOrThrowArgs} args - Arguments to find a GeneratedRoast
     * @example
     * // Get one GeneratedRoast
     * const generatedRoast = await prisma.generatedRoast.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedRoastFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedRoastFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneratedRoasts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedRoasts
     * const generatedRoasts = await prisma.generatedRoast.findMany()
     * 
     * // Get first 10 GeneratedRoasts
     * const generatedRoasts = await prisma.generatedRoast.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedRoastWithIdOnly = await prisma.generatedRoast.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedRoastFindManyArgs>(args?: SelectSubset<T, GeneratedRoastFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneratedRoast.
     * @param {GeneratedRoastCreateArgs} args - Arguments to create a GeneratedRoast.
     * @example
     * // Create one GeneratedRoast
     * const GeneratedRoast = await prisma.generatedRoast.create({
     *   data: {
     *     // ... data to create a GeneratedRoast
     *   }
     * })
     * 
     */
    create<T extends GeneratedRoastCreateArgs>(args: SelectSubset<T, GeneratedRoastCreateArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneratedRoasts.
     * @param {GeneratedRoastCreateManyArgs} args - Arguments to create many GeneratedRoasts.
     * @example
     * // Create many GeneratedRoasts
     * const generatedRoast = await prisma.generatedRoast.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedRoastCreateManyArgs>(args?: SelectSubset<T, GeneratedRoastCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedRoasts and returns the data saved in the database.
     * @param {GeneratedRoastCreateManyAndReturnArgs} args - Arguments to create many GeneratedRoasts.
     * @example
     * // Create many GeneratedRoasts
     * const generatedRoast = await prisma.generatedRoast.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedRoasts and only return the `id`
     * const generatedRoastWithIdOnly = await prisma.generatedRoast.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedRoastCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedRoastCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneratedRoast.
     * @param {GeneratedRoastDeleteArgs} args - Arguments to delete one GeneratedRoast.
     * @example
     * // Delete one GeneratedRoast
     * const GeneratedRoast = await prisma.generatedRoast.delete({
     *   where: {
     *     // ... filter to delete one GeneratedRoast
     *   }
     * })
     * 
     */
    delete<T extends GeneratedRoastDeleteArgs>(args: SelectSubset<T, GeneratedRoastDeleteArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneratedRoast.
     * @param {GeneratedRoastUpdateArgs} args - Arguments to update one GeneratedRoast.
     * @example
     * // Update one GeneratedRoast
     * const generatedRoast = await prisma.generatedRoast.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedRoastUpdateArgs>(args: SelectSubset<T, GeneratedRoastUpdateArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneratedRoasts.
     * @param {GeneratedRoastDeleteManyArgs} args - Arguments to filter GeneratedRoasts to delete.
     * @example
     * // Delete a few GeneratedRoasts
     * const { count } = await prisma.generatedRoast.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedRoastDeleteManyArgs>(args?: SelectSubset<T, GeneratedRoastDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedRoasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedRoasts
     * const generatedRoast = await prisma.generatedRoast.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedRoastUpdateManyArgs>(args: SelectSubset<T, GeneratedRoastUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedRoasts and returns the data updated in the database.
     * @param {GeneratedRoastUpdateManyAndReturnArgs} args - Arguments to update many GeneratedRoasts.
     * @example
     * // Update many GeneratedRoasts
     * const generatedRoast = await prisma.generatedRoast.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeneratedRoasts and only return the `id`
     * const generatedRoastWithIdOnly = await prisma.generatedRoast.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneratedRoastUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneratedRoastUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeneratedRoast.
     * @param {GeneratedRoastUpsertArgs} args - Arguments to update or create a GeneratedRoast.
     * @example
     * // Update or create a GeneratedRoast
     * const generatedRoast = await prisma.generatedRoast.upsert({
     *   create: {
     *     // ... data to create a GeneratedRoast
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedRoast we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedRoastUpsertArgs>(args: SelectSubset<T, GeneratedRoastUpsertArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneratedRoasts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastCountArgs} args - Arguments to filter GeneratedRoasts to count.
     * @example
     * // Count the number of GeneratedRoasts
     * const count = await prisma.generatedRoast.count({
     *   where: {
     *     // ... the filter for the GeneratedRoasts we want to count
     *   }
     * })
    **/
    count<T extends GeneratedRoastCountArgs>(
      args?: Subset<T, GeneratedRoastCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedRoastCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedRoast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedRoastAggregateArgs>(args: Subset<T, GeneratedRoastAggregateArgs>): Prisma.PrismaPromise<GetGeneratedRoastAggregateType<T>>

    /**
     * Group by GeneratedRoast.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedRoastGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedRoastGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedRoastGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedRoastGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedRoastGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedRoastGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedRoast model
   */
  readonly fields: GeneratedRoastFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedRoast.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedRoastClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends GeneratedRoast$userArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resume<T extends GeneratedRoast$resumeArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$resumeArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedResume<T extends GeneratedRoast$extractedResumeArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$extractedResumeArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedJob<T extends GeneratedRoast$extractedJobArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$extractedJobArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    llmCalls<T extends GeneratedRoast$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sharedAnalyses<T extends GeneratedRoast$sharedAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$sharedAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedCoverLetters<T extends GeneratedRoast$generatedCoverLettersArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$generatedCoverLettersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedResumes<T extends GeneratedRoast$generatedResumesArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$generatedResumesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    generatedInterviewPreps<T extends GeneratedRoast$generatedInterviewPrepsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoast$generatedInterviewPrepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedRoast model
   */
  interface GeneratedRoastFieldRefs {
    readonly id: FieldRef<"GeneratedRoast", 'String'>
    readonly userId: FieldRef<"GeneratedRoast", 'String'>
    readonly resumeId: FieldRef<"GeneratedRoast", 'String'>
    readonly extractedResumeId: FieldRef<"GeneratedRoast", 'String'>
    readonly extractedJobId: FieldRef<"GeneratedRoast", 'String'>
    readonly contentHash: FieldRef<"GeneratedRoast", 'String'>
    readonly data: FieldRef<"GeneratedRoast", 'Json'>
    readonly overallScore: FieldRef<"GeneratedRoast", 'Int'>
    readonly createdAt: FieldRef<"GeneratedRoast", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedRoast findUnique
   */
  export type GeneratedRoastFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedRoast to fetch.
     */
    where: GeneratedRoastWhereUniqueInput
  }

  /**
   * GeneratedRoast findUniqueOrThrow
   */
  export type GeneratedRoastFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedRoast to fetch.
     */
    where: GeneratedRoastWhereUniqueInput
  }

  /**
   * GeneratedRoast findFirst
   */
  export type GeneratedRoastFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedRoast to fetch.
     */
    where?: GeneratedRoastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedRoasts to fetch.
     */
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedRoasts.
     */
    cursor?: GeneratedRoastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedRoasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedRoasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedRoasts.
     */
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * GeneratedRoast findFirstOrThrow
   */
  export type GeneratedRoastFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedRoast to fetch.
     */
    where?: GeneratedRoastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedRoasts to fetch.
     */
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedRoasts.
     */
    cursor?: GeneratedRoastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedRoasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedRoasts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedRoasts.
     */
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * GeneratedRoast findMany
   */
  export type GeneratedRoastFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedRoasts to fetch.
     */
    where?: GeneratedRoastWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedRoasts to fetch.
     */
    orderBy?: GeneratedRoastOrderByWithRelationInput | GeneratedRoastOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedRoasts.
     */
    cursor?: GeneratedRoastWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedRoasts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedRoasts.
     */
    skip?: number
    distinct?: GeneratedRoastScalarFieldEnum | GeneratedRoastScalarFieldEnum[]
  }

  /**
   * GeneratedRoast create
   */
  export type GeneratedRoastCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedRoast.
     */
    data: XOR<GeneratedRoastCreateInput, GeneratedRoastUncheckedCreateInput>
  }

  /**
   * GeneratedRoast createMany
   */
  export type GeneratedRoastCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedRoasts.
     */
    data: GeneratedRoastCreateManyInput | GeneratedRoastCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedRoast createManyAndReturn
   */
  export type GeneratedRoastCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * The data used to create many GeneratedRoasts.
     */
    data: GeneratedRoastCreateManyInput | GeneratedRoastCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedRoast update
   */
  export type GeneratedRoastUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedRoast.
     */
    data: XOR<GeneratedRoastUpdateInput, GeneratedRoastUncheckedUpdateInput>
    /**
     * Choose, which GeneratedRoast to update.
     */
    where: GeneratedRoastWhereUniqueInput
  }

  /**
   * GeneratedRoast updateMany
   */
  export type GeneratedRoastUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedRoasts.
     */
    data: XOR<GeneratedRoastUpdateManyMutationInput, GeneratedRoastUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedRoasts to update
     */
    where?: GeneratedRoastWhereInput
    /**
     * Limit how many GeneratedRoasts to update.
     */
    limit?: number
  }

  /**
   * GeneratedRoast updateManyAndReturn
   */
  export type GeneratedRoastUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * The data used to update GeneratedRoasts.
     */
    data: XOR<GeneratedRoastUpdateManyMutationInput, GeneratedRoastUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedRoasts to update
     */
    where?: GeneratedRoastWhereInput
    /**
     * Limit how many GeneratedRoasts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedRoast upsert
   */
  export type GeneratedRoastUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedRoast to update in case it exists.
     */
    where: GeneratedRoastWhereUniqueInput
    /**
     * In case the GeneratedRoast found by the `where` argument doesn't exist, create a new GeneratedRoast with this data.
     */
    create: XOR<GeneratedRoastCreateInput, GeneratedRoastUncheckedCreateInput>
    /**
     * In case the GeneratedRoast was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedRoastUpdateInput, GeneratedRoastUncheckedUpdateInput>
  }

  /**
   * GeneratedRoast delete
   */
  export type GeneratedRoastDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    /**
     * Filter which GeneratedRoast to delete.
     */
    where: GeneratedRoastWhereUniqueInput
  }

  /**
   * GeneratedRoast deleteMany
   */
  export type GeneratedRoastDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedRoasts to delete
     */
    where?: GeneratedRoastWhereInput
    /**
     * Limit how many GeneratedRoasts to delete.
     */
    limit?: number
  }

  /**
   * GeneratedRoast.user
   */
  export type GeneratedRoast$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GeneratedRoast.resume
   */
  export type GeneratedRoast$resumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
  }

  /**
   * GeneratedRoast.extractedResume
   */
  export type GeneratedRoast$extractedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    where?: ExtractedResumeWhereInput
  }

  /**
   * GeneratedRoast.extractedJob
   */
  export type GeneratedRoast$extractedJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    where?: ExtractedJobDescriptionWhereInput
  }

  /**
   * GeneratedRoast.llmCalls
   */
  export type GeneratedRoast$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * GeneratedRoast.sharedAnalyses
   */
  export type GeneratedRoast$sharedAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    where?: SharedAnalysisWhereInput
    orderBy?: SharedAnalysisOrderByWithRelationInput | SharedAnalysisOrderByWithRelationInput[]
    cursor?: SharedAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedAnalysisScalarFieldEnum | SharedAnalysisScalarFieldEnum[]
  }

  /**
   * GeneratedRoast.generatedCoverLetters
   */
  export type GeneratedRoast$generatedCoverLettersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    where?: GeneratedCoverLetterWhereInput
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    cursor?: GeneratedCoverLetterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * GeneratedRoast.generatedResumes
   */
  export type GeneratedRoast$generatedResumesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    where?: GeneratedResumeWhereInput
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    cursor?: GeneratedResumeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * GeneratedRoast.generatedInterviewPreps
   */
  export type GeneratedRoast$generatedInterviewPrepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    where?: GeneratedInterviewPrepWhereInput
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * GeneratedRoast without action
   */
  export type GeneratedRoastDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedCoverLetter
   */

  export type AggregateGeneratedCoverLetter = {
    _count: GeneratedCoverLetterCountAggregateOutputType | null
    _min: GeneratedCoverLetterMinAggregateOutputType | null
    _max: GeneratedCoverLetterMaxAggregateOutputType | null
  }

  export type GeneratedCoverLetterMinAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string | null
    content: string | null
    tone: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type GeneratedCoverLetterMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    resumeId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string | null
    content: string | null
    tone: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type GeneratedCoverLetterCountAggregateOutputType = {
    id: number
    userId: number
    resumeId: number
    roastId: number
    extractedResumeId: number
    extractedJobId: number
    contentHash: number
    content: number
    tone: number
    modelName: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type GeneratedCoverLetterMinAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    content?: true
    tone?: true
    modelName?: true
    createdAt?: true
  }

  export type GeneratedCoverLetterMaxAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    content?: true
    tone?: true
    modelName?: true
    createdAt?: true
  }

  export type GeneratedCoverLetterCountAggregateInputType = {
    id?: true
    userId?: true
    resumeId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    content?: true
    tone?: true
    modelName?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type GeneratedCoverLetterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedCoverLetter to aggregate.
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedCoverLetters to fetch.
     */
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedCoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedCoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedCoverLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedCoverLetters
    **/
    _count?: true | GeneratedCoverLetterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedCoverLetterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedCoverLetterMaxAggregateInputType
  }

  export type GetGeneratedCoverLetterAggregateType<T extends GeneratedCoverLetterAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedCoverLetter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedCoverLetter[P]>
      : GetScalarType<T[P], AggregateGeneratedCoverLetter[P]>
  }




  export type GeneratedCoverLetterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedCoverLetterWhereInput
    orderBy?: GeneratedCoverLetterOrderByWithAggregationInput | GeneratedCoverLetterOrderByWithAggregationInput[]
    by: GeneratedCoverLetterScalarFieldEnum[] | GeneratedCoverLetterScalarFieldEnum
    having?: GeneratedCoverLetterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedCoverLetterCountAggregateInputType | true
    _min?: GeneratedCoverLetterMinAggregateInputType
    _max?: GeneratedCoverLetterMaxAggregateInputType
  }

  export type GeneratedCoverLetterGroupByOutputType = {
    id: string
    userId: string | null
    resumeId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string
    content: string
    tone: string
    modelName: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: GeneratedCoverLetterCountAggregateOutputType | null
    _min: GeneratedCoverLetterMinAggregateOutputType | null
    _max: GeneratedCoverLetterMaxAggregateOutputType | null
  }

  type GetGeneratedCoverLetterGroupByPayload<T extends GeneratedCoverLetterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedCoverLetterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedCoverLetterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedCoverLetterGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedCoverLetterGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedCoverLetterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    content?: boolean
    tone?: boolean
    modelName?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedCoverLetter$userArgs<ExtArgs>
    resume?: boolean | GeneratedCoverLetter$resumeArgs<ExtArgs>
    roast?: boolean | GeneratedCoverLetter$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedCoverLetter$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedCoverLetter$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedCoverLetter$llmCallsArgs<ExtArgs>
    _count?: boolean | GeneratedCoverLetterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedCoverLetter"]>

  export type GeneratedCoverLetterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    content?: boolean
    tone?: boolean
    modelName?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedCoverLetter$userArgs<ExtArgs>
    resume?: boolean | GeneratedCoverLetter$resumeArgs<ExtArgs>
    roast?: boolean | GeneratedCoverLetter$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedCoverLetter$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedCoverLetter$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedCoverLetter"]>

  export type GeneratedCoverLetterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    content?: boolean
    tone?: boolean
    modelName?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedCoverLetter$userArgs<ExtArgs>
    resume?: boolean | GeneratedCoverLetter$resumeArgs<ExtArgs>
    roast?: boolean | GeneratedCoverLetter$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedCoverLetter$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedCoverLetter$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedCoverLetter"]>

  export type GeneratedCoverLetterSelectScalar = {
    id?: boolean
    userId?: boolean
    resumeId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    content?: boolean
    tone?: boolean
    modelName?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type GeneratedCoverLetterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "resumeId" | "roastId" | "extractedResumeId" | "extractedJobId" | "contentHash" | "content" | "tone" | "modelName" | "metadata" | "createdAt", ExtArgs["result"]["generatedCoverLetter"]>
  export type GeneratedCoverLetterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedCoverLetter$userArgs<ExtArgs>
    resume?: boolean | GeneratedCoverLetter$resumeArgs<ExtArgs>
    roast?: boolean | GeneratedCoverLetter$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedCoverLetter$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedCoverLetter$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedCoverLetter$llmCallsArgs<ExtArgs>
    _count?: boolean | GeneratedCoverLetterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneratedCoverLetterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedCoverLetter$userArgs<ExtArgs>
    resume?: boolean | GeneratedCoverLetter$resumeArgs<ExtArgs>
    roast?: boolean | GeneratedCoverLetter$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedCoverLetter$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedCoverLetter$extractedJobArgs<ExtArgs>
  }
  export type GeneratedCoverLetterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedCoverLetter$userArgs<ExtArgs>
    resume?: boolean | GeneratedCoverLetter$resumeArgs<ExtArgs>
    roast?: boolean | GeneratedCoverLetter$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedCoverLetter$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedCoverLetter$extractedJobArgs<ExtArgs>
  }

  export type $GeneratedCoverLetterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedCoverLetter"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      resume: Prisma.$ResumePayload<ExtArgs> | null
      roast: Prisma.$GeneratedRoastPayload<ExtArgs> | null
      extractedResume: Prisma.$ExtractedResumePayload<ExtArgs> | null
      extractedJob: Prisma.$ExtractedJobDescriptionPayload<ExtArgs> | null
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      resumeId: string | null
      roastId: string | null
      extractedResumeId: string | null
      extractedJobId: string | null
      contentHash: string
      content: string
      tone: string
      modelName: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["generatedCoverLetter"]>
    composites: {}
  }

  type GeneratedCoverLetterGetPayload<S extends boolean | null | undefined | GeneratedCoverLetterDefaultArgs> = $Result.GetResult<Prisma.$GeneratedCoverLetterPayload, S>

  type GeneratedCoverLetterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneratedCoverLetterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneratedCoverLetterCountAggregateInputType | true
    }

  export interface GeneratedCoverLetterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedCoverLetter'], meta: { name: 'GeneratedCoverLetter' } }
    /**
     * Find zero or one GeneratedCoverLetter that matches the filter.
     * @param {GeneratedCoverLetterFindUniqueArgs} args - Arguments to find a GeneratedCoverLetter
     * @example
     * // Get one GeneratedCoverLetter
     * const generatedCoverLetter = await prisma.generatedCoverLetter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedCoverLetterFindUniqueArgs>(args: SelectSubset<T, GeneratedCoverLetterFindUniqueArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneratedCoverLetter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedCoverLetterFindUniqueOrThrowArgs} args - Arguments to find a GeneratedCoverLetter
     * @example
     * // Get one GeneratedCoverLetter
     * const generatedCoverLetter = await prisma.generatedCoverLetter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedCoverLetterFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedCoverLetterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedCoverLetter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterFindFirstArgs} args - Arguments to find a GeneratedCoverLetter
     * @example
     * // Get one GeneratedCoverLetter
     * const generatedCoverLetter = await prisma.generatedCoverLetter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedCoverLetterFindFirstArgs>(args?: SelectSubset<T, GeneratedCoverLetterFindFirstArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedCoverLetter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterFindFirstOrThrowArgs} args - Arguments to find a GeneratedCoverLetter
     * @example
     * // Get one GeneratedCoverLetter
     * const generatedCoverLetter = await prisma.generatedCoverLetter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedCoverLetterFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedCoverLetterFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneratedCoverLetters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedCoverLetters
     * const generatedCoverLetters = await prisma.generatedCoverLetter.findMany()
     * 
     * // Get first 10 GeneratedCoverLetters
     * const generatedCoverLetters = await prisma.generatedCoverLetter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedCoverLetterWithIdOnly = await prisma.generatedCoverLetter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedCoverLetterFindManyArgs>(args?: SelectSubset<T, GeneratedCoverLetterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneratedCoverLetter.
     * @param {GeneratedCoverLetterCreateArgs} args - Arguments to create a GeneratedCoverLetter.
     * @example
     * // Create one GeneratedCoverLetter
     * const GeneratedCoverLetter = await prisma.generatedCoverLetter.create({
     *   data: {
     *     // ... data to create a GeneratedCoverLetter
     *   }
     * })
     * 
     */
    create<T extends GeneratedCoverLetterCreateArgs>(args: SelectSubset<T, GeneratedCoverLetterCreateArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneratedCoverLetters.
     * @param {GeneratedCoverLetterCreateManyArgs} args - Arguments to create many GeneratedCoverLetters.
     * @example
     * // Create many GeneratedCoverLetters
     * const generatedCoverLetter = await prisma.generatedCoverLetter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedCoverLetterCreateManyArgs>(args?: SelectSubset<T, GeneratedCoverLetterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedCoverLetters and returns the data saved in the database.
     * @param {GeneratedCoverLetterCreateManyAndReturnArgs} args - Arguments to create many GeneratedCoverLetters.
     * @example
     * // Create many GeneratedCoverLetters
     * const generatedCoverLetter = await prisma.generatedCoverLetter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedCoverLetters and only return the `id`
     * const generatedCoverLetterWithIdOnly = await prisma.generatedCoverLetter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedCoverLetterCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedCoverLetterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneratedCoverLetter.
     * @param {GeneratedCoverLetterDeleteArgs} args - Arguments to delete one GeneratedCoverLetter.
     * @example
     * // Delete one GeneratedCoverLetter
     * const GeneratedCoverLetter = await prisma.generatedCoverLetter.delete({
     *   where: {
     *     // ... filter to delete one GeneratedCoverLetter
     *   }
     * })
     * 
     */
    delete<T extends GeneratedCoverLetterDeleteArgs>(args: SelectSubset<T, GeneratedCoverLetterDeleteArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneratedCoverLetter.
     * @param {GeneratedCoverLetterUpdateArgs} args - Arguments to update one GeneratedCoverLetter.
     * @example
     * // Update one GeneratedCoverLetter
     * const generatedCoverLetter = await prisma.generatedCoverLetter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedCoverLetterUpdateArgs>(args: SelectSubset<T, GeneratedCoverLetterUpdateArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneratedCoverLetters.
     * @param {GeneratedCoverLetterDeleteManyArgs} args - Arguments to filter GeneratedCoverLetters to delete.
     * @example
     * // Delete a few GeneratedCoverLetters
     * const { count } = await prisma.generatedCoverLetter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedCoverLetterDeleteManyArgs>(args?: SelectSubset<T, GeneratedCoverLetterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedCoverLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedCoverLetters
     * const generatedCoverLetter = await prisma.generatedCoverLetter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedCoverLetterUpdateManyArgs>(args: SelectSubset<T, GeneratedCoverLetterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedCoverLetters and returns the data updated in the database.
     * @param {GeneratedCoverLetterUpdateManyAndReturnArgs} args - Arguments to update many GeneratedCoverLetters.
     * @example
     * // Update many GeneratedCoverLetters
     * const generatedCoverLetter = await prisma.generatedCoverLetter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeneratedCoverLetters and only return the `id`
     * const generatedCoverLetterWithIdOnly = await prisma.generatedCoverLetter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneratedCoverLetterUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneratedCoverLetterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeneratedCoverLetter.
     * @param {GeneratedCoverLetterUpsertArgs} args - Arguments to update or create a GeneratedCoverLetter.
     * @example
     * // Update or create a GeneratedCoverLetter
     * const generatedCoverLetter = await prisma.generatedCoverLetter.upsert({
     *   create: {
     *     // ... data to create a GeneratedCoverLetter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedCoverLetter we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedCoverLetterUpsertArgs>(args: SelectSubset<T, GeneratedCoverLetterUpsertArgs<ExtArgs>>): Prisma__GeneratedCoverLetterClient<$Result.GetResult<Prisma.$GeneratedCoverLetterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneratedCoverLetters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterCountArgs} args - Arguments to filter GeneratedCoverLetters to count.
     * @example
     * // Count the number of GeneratedCoverLetters
     * const count = await prisma.generatedCoverLetter.count({
     *   where: {
     *     // ... the filter for the GeneratedCoverLetters we want to count
     *   }
     * })
    **/
    count<T extends GeneratedCoverLetterCountArgs>(
      args?: Subset<T, GeneratedCoverLetterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedCoverLetterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedCoverLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedCoverLetterAggregateArgs>(args: Subset<T, GeneratedCoverLetterAggregateArgs>): Prisma.PrismaPromise<GetGeneratedCoverLetterAggregateType<T>>

    /**
     * Group by GeneratedCoverLetter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedCoverLetterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedCoverLetterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedCoverLetterGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedCoverLetterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedCoverLetterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedCoverLetterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedCoverLetter model
   */
  readonly fields: GeneratedCoverLetterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedCoverLetter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedCoverLetterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends GeneratedCoverLetter$userArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedCoverLetter$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    resume<T extends GeneratedCoverLetter$resumeArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedCoverLetter$resumeArgs<ExtArgs>>): Prisma__ResumeClient<$Result.GetResult<Prisma.$ResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roast<T extends GeneratedCoverLetter$roastArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedCoverLetter$roastArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedResume<T extends GeneratedCoverLetter$extractedResumeArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedCoverLetter$extractedResumeArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedJob<T extends GeneratedCoverLetter$extractedJobArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedCoverLetter$extractedJobArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    llmCalls<T extends GeneratedCoverLetter$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedCoverLetter$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedCoverLetter model
   */
  interface GeneratedCoverLetterFieldRefs {
    readonly id: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly userId: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly resumeId: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly roastId: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly extractedResumeId: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly extractedJobId: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly contentHash: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly content: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly tone: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly modelName: FieldRef<"GeneratedCoverLetter", 'String'>
    readonly metadata: FieldRef<"GeneratedCoverLetter", 'Json'>
    readonly createdAt: FieldRef<"GeneratedCoverLetter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedCoverLetter findUnique
   */
  export type GeneratedCoverLetterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedCoverLetter to fetch.
     */
    where: GeneratedCoverLetterWhereUniqueInput
  }

  /**
   * GeneratedCoverLetter findUniqueOrThrow
   */
  export type GeneratedCoverLetterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedCoverLetter to fetch.
     */
    where: GeneratedCoverLetterWhereUniqueInput
  }

  /**
   * GeneratedCoverLetter findFirst
   */
  export type GeneratedCoverLetterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedCoverLetter to fetch.
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedCoverLetters to fetch.
     */
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedCoverLetters.
     */
    cursor?: GeneratedCoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedCoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedCoverLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedCoverLetters.
     */
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * GeneratedCoverLetter findFirstOrThrow
   */
  export type GeneratedCoverLetterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedCoverLetter to fetch.
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedCoverLetters to fetch.
     */
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedCoverLetters.
     */
    cursor?: GeneratedCoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedCoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedCoverLetters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedCoverLetters.
     */
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * GeneratedCoverLetter findMany
   */
  export type GeneratedCoverLetterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedCoverLetters to fetch.
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedCoverLetters to fetch.
     */
    orderBy?: GeneratedCoverLetterOrderByWithRelationInput | GeneratedCoverLetterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedCoverLetters.
     */
    cursor?: GeneratedCoverLetterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedCoverLetters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedCoverLetters.
     */
    skip?: number
    distinct?: GeneratedCoverLetterScalarFieldEnum | GeneratedCoverLetterScalarFieldEnum[]
  }

  /**
   * GeneratedCoverLetter create
   */
  export type GeneratedCoverLetterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedCoverLetter.
     */
    data: XOR<GeneratedCoverLetterCreateInput, GeneratedCoverLetterUncheckedCreateInput>
  }

  /**
   * GeneratedCoverLetter createMany
   */
  export type GeneratedCoverLetterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedCoverLetters.
     */
    data: GeneratedCoverLetterCreateManyInput | GeneratedCoverLetterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedCoverLetter createManyAndReturn
   */
  export type GeneratedCoverLetterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * The data used to create many GeneratedCoverLetters.
     */
    data: GeneratedCoverLetterCreateManyInput | GeneratedCoverLetterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedCoverLetter update
   */
  export type GeneratedCoverLetterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedCoverLetter.
     */
    data: XOR<GeneratedCoverLetterUpdateInput, GeneratedCoverLetterUncheckedUpdateInput>
    /**
     * Choose, which GeneratedCoverLetter to update.
     */
    where: GeneratedCoverLetterWhereUniqueInput
  }

  /**
   * GeneratedCoverLetter updateMany
   */
  export type GeneratedCoverLetterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedCoverLetters.
     */
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedCoverLetters to update
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * Limit how many GeneratedCoverLetters to update.
     */
    limit?: number
  }

  /**
   * GeneratedCoverLetter updateManyAndReturn
   */
  export type GeneratedCoverLetterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * The data used to update GeneratedCoverLetters.
     */
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedCoverLetters to update
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * Limit how many GeneratedCoverLetters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedCoverLetter upsert
   */
  export type GeneratedCoverLetterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedCoverLetter to update in case it exists.
     */
    where: GeneratedCoverLetterWhereUniqueInput
    /**
     * In case the GeneratedCoverLetter found by the `where` argument doesn't exist, create a new GeneratedCoverLetter with this data.
     */
    create: XOR<GeneratedCoverLetterCreateInput, GeneratedCoverLetterUncheckedCreateInput>
    /**
     * In case the GeneratedCoverLetter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedCoverLetterUpdateInput, GeneratedCoverLetterUncheckedUpdateInput>
  }

  /**
   * GeneratedCoverLetter delete
   */
  export type GeneratedCoverLetterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
    /**
     * Filter which GeneratedCoverLetter to delete.
     */
    where: GeneratedCoverLetterWhereUniqueInput
  }

  /**
   * GeneratedCoverLetter deleteMany
   */
  export type GeneratedCoverLetterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedCoverLetters to delete
     */
    where?: GeneratedCoverLetterWhereInput
    /**
     * Limit how many GeneratedCoverLetters to delete.
     */
    limit?: number
  }

  /**
   * GeneratedCoverLetter.user
   */
  export type GeneratedCoverLetter$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GeneratedCoverLetter.resume
   */
  export type GeneratedCoverLetter$resumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resume
     */
    select?: ResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Resume
     */
    omit?: ResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResumeInclude<ExtArgs> | null
    where?: ResumeWhereInput
  }

  /**
   * GeneratedCoverLetter.roast
   */
  export type GeneratedCoverLetter$roastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
  }

  /**
   * GeneratedCoverLetter.extractedResume
   */
  export type GeneratedCoverLetter$extractedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    where?: ExtractedResumeWhereInput
  }

  /**
   * GeneratedCoverLetter.extractedJob
   */
  export type GeneratedCoverLetter$extractedJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    where?: ExtractedJobDescriptionWhereInput
  }

  /**
   * GeneratedCoverLetter.llmCalls
   */
  export type GeneratedCoverLetter$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * GeneratedCoverLetter without action
   */
  export type GeneratedCoverLetterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedCoverLetter
     */
    select?: GeneratedCoverLetterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedCoverLetter
     */
    omit?: GeneratedCoverLetterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedCoverLetterInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedResume
   */

  export type AggregateGeneratedResume = {
    _count: GeneratedResumeCountAggregateOutputType | null
    _avg: GeneratedResumeAvgAggregateOutputType | null
    _sum: GeneratedResumeSumAggregateOutputType | null
    _min: GeneratedResumeMinAggregateOutputType | null
    _max: GeneratedResumeMaxAggregateOutputType | null
  }

  export type GeneratedResumeAvgAggregateOutputType = {
    atsScore: number | null
  }

  export type GeneratedResumeSumAggregateOutputType = {
    atsScore: number | null
  }

  export type GeneratedResumeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    templateId: string | null
    contentHash: string | null
    content: string | null
    atsScore: number | null
    createdAt: Date | null
  }

  export type GeneratedResumeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    templateId: string | null
    contentHash: string | null
    content: string | null
    atsScore: number | null
    createdAt: Date | null
  }

  export type GeneratedResumeCountAggregateOutputType = {
    id: number
    userId: number
    roastId: number
    extractedResumeId: number
    extractedJobId: number
    templateId: number
    contentHash: number
    content: number
    data: number
    atsScore: number
    keywordsMatched: number
    createdAt: number
    _all: number
  }


  export type GeneratedResumeAvgAggregateInputType = {
    atsScore?: true
  }

  export type GeneratedResumeSumAggregateInputType = {
    atsScore?: true
  }

  export type GeneratedResumeMinAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    templateId?: true
    contentHash?: true
    content?: true
    atsScore?: true
    createdAt?: true
  }

  export type GeneratedResumeMaxAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    templateId?: true
    contentHash?: true
    content?: true
    atsScore?: true
    createdAt?: true
  }

  export type GeneratedResumeCountAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    templateId?: true
    contentHash?: true
    content?: true
    data?: true
    atsScore?: true
    keywordsMatched?: true
    createdAt?: true
    _all?: true
  }

  export type GeneratedResumeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedResume to aggregate.
     */
    where?: GeneratedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResumes to fetch.
     */
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedResumes
    **/
    _count?: true | GeneratedResumeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneratedResumeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneratedResumeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedResumeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedResumeMaxAggregateInputType
  }

  export type GetGeneratedResumeAggregateType<T extends GeneratedResumeAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedResume]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedResume[P]>
      : GetScalarType<T[P], AggregateGeneratedResume[P]>
  }




  export type GeneratedResumeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedResumeWhereInput
    orderBy?: GeneratedResumeOrderByWithAggregationInput | GeneratedResumeOrderByWithAggregationInput[]
    by: GeneratedResumeScalarFieldEnum[] | GeneratedResumeScalarFieldEnum
    having?: GeneratedResumeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedResumeCountAggregateInputType | true
    _avg?: GeneratedResumeAvgAggregateInputType
    _sum?: GeneratedResumeSumAggregateInputType
    _min?: GeneratedResumeMinAggregateInputType
    _max?: GeneratedResumeMaxAggregateInputType
  }

  export type GeneratedResumeGroupByOutputType = {
    id: string
    userId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonValue
    atsScore: number | null
    keywordsMatched: string[]
    createdAt: Date
    _count: GeneratedResumeCountAggregateOutputType | null
    _avg: GeneratedResumeAvgAggregateOutputType | null
    _sum: GeneratedResumeSumAggregateOutputType | null
    _min: GeneratedResumeMinAggregateOutputType | null
    _max: GeneratedResumeMaxAggregateOutputType | null
  }

  type GetGeneratedResumeGroupByPayload<T extends GeneratedResumeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedResumeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedResumeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedResumeGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedResumeGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedResumeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    templateId?: boolean
    contentHash?: boolean
    content?: boolean
    data?: boolean
    atsScore?: boolean
    keywordsMatched?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedResume$userArgs<ExtArgs>
    roast?: boolean | GeneratedResume$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedResume$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedResume$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedResume$llmCallsArgs<ExtArgs>
    _count?: boolean | GeneratedResumeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedResume"]>

  export type GeneratedResumeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    templateId?: boolean
    contentHash?: boolean
    content?: boolean
    data?: boolean
    atsScore?: boolean
    keywordsMatched?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedResume$userArgs<ExtArgs>
    roast?: boolean | GeneratedResume$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedResume$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedResume$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedResume"]>

  export type GeneratedResumeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    templateId?: boolean
    contentHash?: boolean
    content?: boolean
    data?: boolean
    atsScore?: boolean
    keywordsMatched?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedResume$userArgs<ExtArgs>
    roast?: boolean | GeneratedResume$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedResume$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedResume$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedResume"]>

  export type GeneratedResumeSelectScalar = {
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    templateId?: boolean
    contentHash?: boolean
    content?: boolean
    data?: boolean
    atsScore?: boolean
    keywordsMatched?: boolean
    createdAt?: boolean
  }

  export type GeneratedResumeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roastId" | "extractedResumeId" | "extractedJobId" | "templateId" | "contentHash" | "content" | "data" | "atsScore" | "keywordsMatched" | "createdAt", ExtArgs["result"]["generatedResume"]>
  export type GeneratedResumeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedResume$userArgs<ExtArgs>
    roast?: boolean | GeneratedResume$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedResume$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedResume$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedResume$llmCallsArgs<ExtArgs>
    _count?: boolean | GeneratedResumeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneratedResumeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedResume$userArgs<ExtArgs>
    roast?: boolean | GeneratedResume$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedResume$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedResume$extractedJobArgs<ExtArgs>
  }
  export type GeneratedResumeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedResume$userArgs<ExtArgs>
    roast?: boolean | GeneratedResume$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedResume$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedResume$extractedJobArgs<ExtArgs>
  }

  export type $GeneratedResumePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedResume"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      roast: Prisma.$GeneratedRoastPayload<ExtArgs> | null
      extractedResume: Prisma.$ExtractedResumePayload<ExtArgs> | null
      extractedJob: Prisma.$ExtractedJobDescriptionPayload<ExtArgs> | null
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      roastId: string | null
      extractedResumeId: string | null
      extractedJobId: string | null
      templateId: string
      contentHash: string
      content: string
      data: Prisma.JsonValue
      atsScore: number | null
      keywordsMatched: string[]
      createdAt: Date
    }, ExtArgs["result"]["generatedResume"]>
    composites: {}
  }

  type GeneratedResumeGetPayload<S extends boolean | null | undefined | GeneratedResumeDefaultArgs> = $Result.GetResult<Prisma.$GeneratedResumePayload, S>

  type GeneratedResumeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneratedResumeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneratedResumeCountAggregateInputType | true
    }

  export interface GeneratedResumeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedResume'], meta: { name: 'GeneratedResume' } }
    /**
     * Find zero or one GeneratedResume that matches the filter.
     * @param {GeneratedResumeFindUniqueArgs} args - Arguments to find a GeneratedResume
     * @example
     * // Get one GeneratedResume
     * const generatedResume = await prisma.generatedResume.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedResumeFindUniqueArgs>(args: SelectSubset<T, GeneratedResumeFindUniqueArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneratedResume that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedResumeFindUniqueOrThrowArgs} args - Arguments to find a GeneratedResume
     * @example
     * // Get one GeneratedResume
     * const generatedResume = await prisma.generatedResume.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedResumeFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedResumeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedResume that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeFindFirstArgs} args - Arguments to find a GeneratedResume
     * @example
     * // Get one GeneratedResume
     * const generatedResume = await prisma.generatedResume.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedResumeFindFirstArgs>(args?: SelectSubset<T, GeneratedResumeFindFirstArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedResume that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeFindFirstOrThrowArgs} args - Arguments to find a GeneratedResume
     * @example
     * // Get one GeneratedResume
     * const generatedResume = await prisma.generatedResume.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedResumeFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedResumeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneratedResumes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedResumes
     * const generatedResumes = await prisma.generatedResume.findMany()
     * 
     * // Get first 10 GeneratedResumes
     * const generatedResumes = await prisma.generatedResume.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedResumeWithIdOnly = await prisma.generatedResume.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedResumeFindManyArgs>(args?: SelectSubset<T, GeneratedResumeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneratedResume.
     * @param {GeneratedResumeCreateArgs} args - Arguments to create a GeneratedResume.
     * @example
     * // Create one GeneratedResume
     * const GeneratedResume = await prisma.generatedResume.create({
     *   data: {
     *     // ... data to create a GeneratedResume
     *   }
     * })
     * 
     */
    create<T extends GeneratedResumeCreateArgs>(args: SelectSubset<T, GeneratedResumeCreateArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneratedResumes.
     * @param {GeneratedResumeCreateManyArgs} args - Arguments to create many GeneratedResumes.
     * @example
     * // Create many GeneratedResumes
     * const generatedResume = await prisma.generatedResume.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedResumeCreateManyArgs>(args?: SelectSubset<T, GeneratedResumeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedResumes and returns the data saved in the database.
     * @param {GeneratedResumeCreateManyAndReturnArgs} args - Arguments to create many GeneratedResumes.
     * @example
     * // Create many GeneratedResumes
     * const generatedResume = await prisma.generatedResume.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedResumes and only return the `id`
     * const generatedResumeWithIdOnly = await prisma.generatedResume.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedResumeCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedResumeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneratedResume.
     * @param {GeneratedResumeDeleteArgs} args - Arguments to delete one GeneratedResume.
     * @example
     * // Delete one GeneratedResume
     * const GeneratedResume = await prisma.generatedResume.delete({
     *   where: {
     *     // ... filter to delete one GeneratedResume
     *   }
     * })
     * 
     */
    delete<T extends GeneratedResumeDeleteArgs>(args: SelectSubset<T, GeneratedResumeDeleteArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneratedResume.
     * @param {GeneratedResumeUpdateArgs} args - Arguments to update one GeneratedResume.
     * @example
     * // Update one GeneratedResume
     * const generatedResume = await prisma.generatedResume.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedResumeUpdateArgs>(args: SelectSubset<T, GeneratedResumeUpdateArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneratedResumes.
     * @param {GeneratedResumeDeleteManyArgs} args - Arguments to filter GeneratedResumes to delete.
     * @example
     * // Delete a few GeneratedResumes
     * const { count } = await prisma.generatedResume.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedResumeDeleteManyArgs>(args?: SelectSubset<T, GeneratedResumeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedResumes
     * const generatedResume = await prisma.generatedResume.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedResumeUpdateManyArgs>(args: SelectSubset<T, GeneratedResumeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedResumes and returns the data updated in the database.
     * @param {GeneratedResumeUpdateManyAndReturnArgs} args - Arguments to update many GeneratedResumes.
     * @example
     * // Update many GeneratedResumes
     * const generatedResume = await prisma.generatedResume.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeneratedResumes and only return the `id`
     * const generatedResumeWithIdOnly = await prisma.generatedResume.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneratedResumeUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneratedResumeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeneratedResume.
     * @param {GeneratedResumeUpsertArgs} args - Arguments to update or create a GeneratedResume.
     * @example
     * // Update or create a GeneratedResume
     * const generatedResume = await prisma.generatedResume.upsert({
     *   create: {
     *     // ... data to create a GeneratedResume
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedResume we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedResumeUpsertArgs>(args: SelectSubset<T, GeneratedResumeUpsertArgs<ExtArgs>>): Prisma__GeneratedResumeClient<$Result.GetResult<Prisma.$GeneratedResumePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneratedResumes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeCountArgs} args - Arguments to filter GeneratedResumes to count.
     * @example
     * // Count the number of GeneratedResumes
     * const count = await prisma.generatedResume.count({
     *   where: {
     *     // ... the filter for the GeneratedResumes we want to count
     *   }
     * })
    **/
    count<T extends GeneratedResumeCountArgs>(
      args?: Subset<T, GeneratedResumeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedResumeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedResumeAggregateArgs>(args: Subset<T, GeneratedResumeAggregateArgs>): Prisma.PrismaPromise<GetGeneratedResumeAggregateType<T>>

    /**
     * Group by GeneratedResume.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedResumeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedResumeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedResumeGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedResumeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedResumeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedResumeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedResume model
   */
  readonly fields: GeneratedResumeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedResume.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedResumeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends GeneratedResume$userArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedResume$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roast<T extends GeneratedResume$roastArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedResume$roastArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedResume<T extends GeneratedResume$extractedResumeArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedResume$extractedResumeArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedJob<T extends GeneratedResume$extractedJobArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedResume$extractedJobArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    llmCalls<T extends GeneratedResume$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedResume$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedResume model
   */
  interface GeneratedResumeFieldRefs {
    readonly id: FieldRef<"GeneratedResume", 'String'>
    readonly userId: FieldRef<"GeneratedResume", 'String'>
    readonly roastId: FieldRef<"GeneratedResume", 'String'>
    readonly extractedResumeId: FieldRef<"GeneratedResume", 'String'>
    readonly extractedJobId: FieldRef<"GeneratedResume", 'String'>
    readonly templateId: FieldRef<"GeneratedResume", 'String'>
    readonly contentHash: FieldRef<"GeneratedResume", 'String'>
    readonly content: FieldRef<"GeneratedResume", 'String'>
    readonly data: FieldRef<"GeneratedResume", 'Json'>
    readonly atsScore: FieldRef<"GeneratedResume", 'Int'>
    readonly keywordsMatched: FieldRef<"GeneratedResume", 'String[]'>
    readonly createdAt: FieldRef<"GeneratedResume", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedResume findUnique
   */
  export type GeneratedResumeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResume to fetch.
     */
    where: GeneratedResumeWhereUniqueInput
  }

  /**
   * GeneratedResume findUniqueOrThrow
   */
  export type GeneratedResumeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResume to fetch.
     */
    where: GeneratedResumeWhereUniqueInput
  }

  /**
   * GeneratedResume findFirst
   */
  export type GeneratedResumeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResume to fetch.
     */
    where?: GeneratedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResumes to fetch.
     */
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedResumes.
     */
    cursor?: GeneratedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedResumes.
     */
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * GeneratedResume findFirstOrThrow
   */
  export type GeneratedResumeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResume to fetch.
     */
    where?: GeneratedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResumes to fetch.
     */
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedResumes.
     */
    cursor?: GeneratedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResumes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedResumes.
     */
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * GeneratedResume findMany
   */
  export type GeneratedResumeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedResumes to fetch.
     */
    where?: GeneratedResumeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedResumes to fetch.
     */
    orderBy?: GeneratedResumeOrderByWithRelationInput | GeneratedResumeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedResumes.
     */
    cursor?: GeneratedResumeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedResumes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedResumes.
     */
    skip?: number
    distinct?: GeneratedResumeScalarFieldEnum | GeneratedResumeScalarFieldEnum[]
  }

  /**
   * GeneratedResume create
   */
  export type GeneratedResumeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedResume.
     */
    data: XOR<GeneratedResumeCreateInput, GeneratedResumeUncheckedCreateInput>
  }

  /**
   * GeneratedResume createMany
   */
  export type GeneratedResumeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedResumes.
     */
    data: GeneratedResumeCreateManyInput | GeneratedResumeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedResume createManyAndReturn
   */
  export type GeneratedResumeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * The data used to create many GeneratedResumes.
     */
    data: GeneratedResumeCreateManyInput | GeneratedResumeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedResume update
   */
  export type GeneratedResumeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedResume.
     */
    data: XOR<GeneratedResumeUpdateInput, GeneratedResumeUncheckedUpdateInput>
    /**
     * Choose, which GeneratedResume to update.
     */
    where: GeneratedResumeWhereUniqueInput
  }

  /**
   * GeneratedResume updateMany
   */
  export type GeneratedResumeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedResumes.
     */
    data: XOR<GeneratedResumeUpdateManyMutationInput, GeneratedResumeUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedResumes to update
     */
    where?: GeneratedResumeWhereInput
    /**
     * Limit how many GeneratedResumes to update.
     */
    limit?: number
  }

  /**
   * GeneratedResume updateManyAndReturn
   */
  export type GeneratedResumeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * The data used to update GeneratedResumes.
     */
    data: XOR<GeneratedResumeUpdateManyMutationInput, GeneratedResumeUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedResumes to update
     */
    where?: GeneratedResumeWhereInput
    /**
     * Limit how many GeneratedResumes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedResume upsert
   */
  export type GeneratedResumeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedResume to update in case it exists.
     */
    where: GeneratedResumeWhereUniqueInput
    /**
     * In case the GeneratedResume found by the `where` argument doesn't exist, create a new GeneratedResume with this data.
     */
    create: XOR<GeneratedResumeCreateInput, GeneratedResumeUncheckedCreateInput>
    /**
     * In case the GeneratedResume was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedResumeUpdateInput, GeneratedResumeUncheckedUpdateInput>
  }

  /**
   * GeneratedResume delete
   */
  export type GeneratedResumeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
    /**
     * Filter which GeneratedResume to delete.
     */
    where: GeneratedResumeWhereUniqueInput
  }

  /**
   * GeneratedResume deleteMany
   */
  export type GeneratedResumeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedResumes to delete
     */
    where?: GeneratedResumeWhereInput
    /**
     * Limit how many GeneratedResumes to delete.
     */
    limit?: number
  }

  /**
   * GeneratedResume.user
   */
  export type GeneratedResume$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GeneratedResume.roast
   */
  export type GeneratedResume$roastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
  }

  /**
   * GeneratedResume.extractedResume
   */
  export type GeneratedResume$extractedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    where?: ExtractedResumeWhereInput
  }

  /**
   * GeneratedResume.extractedJob
   */
  export type GeneratedResume$extractedJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    where?: ExtractedJobDescriptionWhereInput
  }

  /**
   * GeneratedResume.llmCalls
   */
  export type GeneratedResume$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * GeneratedResume without action
   */
  export type GeneratedResumeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedResume
     */
    select?: GeneratedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedResume
     */
    omit?: GeneratedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedResumeInclude<ExtArgs> | null
  }


  /**
   * Model GeneratedInterviewPrep
   */

  export type AggregateGeneratedInterviewPrep = {
    _count: GeneratedInterviewPrepCountAggregateOutputType | null
    _min: GeneratedInterviewPrepMinAggregateOutputType | null
    _max: GeneratedInterviewPrepMaxAggregateOutputType | null
  }

  export type GeneratedInterviewPrepMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string | null
    difficulty: string | null
    category: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type GeneratedInterviewPrepMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string | null
    difficulty: string | null
    category: string | null
    modelName: string | null
    createdAt: Date | null
  }

  export type GeneratedInterviewPrepCountAggregateOutputType = {
    id: number
    userId: number
    roastId: number
    extractedResumeId: number
    extractedJobId: number
    contentHash: number
    data: number
    difficulty: number
    category: number
    modelName: number
    createdAt: number
    _all: number
  }


  export type GeneratedInterviewPrepMinAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    difficulty?: true
    category?: true
    modelName?: true
    createdAt?: true
  }

  export type GeneratedInterviewPrepMaxAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    difficulty?: true
    category?: true
    modelName?: true
    createdAt?: true
  }

  export type GeneratedInterviewPrepCountAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    extractedResumeId?: true
    extractedJobId?: true
    contentHash?: true
    data?: true
    difficulty?: true
    category?: true
    modelName?: true
    createdAt?: true
    _all?: true
  }

  export type GeneratedInterviewPrepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedInterviewPrep to aggregate.
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedInterviewPreps to fetch.
     */
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedInterviewPreps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedInterviewPreps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GeneratedInterviewPreps
    **/
    _count?: true | GeneratedInterviewPrepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneratedInterviewPrepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneratedInterviewPrepMaxAggregateInputType
  }

  export type GetGeneratedInterviewPrepAggregateType<T extends GeneratedInterviewPrepAggregateArgs> = {
        [P in keyof T & keyof AggregateGeneratedInterviewPrep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGeneratedInterviewPrep[P]>
      : GetScalarType<T[P], AggregateGeneratedInterviewPrep[P]>
  }




  export type GeneratedInterviewPrepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneratedInterviewPrepWhereInput
    orderBy?: GeneratedInterviewPrepOrderByWithAggregationInput | GeneratedInterviewPrepOrderByWithAggregationInput[]
    by: GeneratedInterviewPrepScalarFieldEnum[] | GeneratedInterviewPrepScalarFieldEnum
    having?: GeneratedInterviewPrepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneratedInterviewPrepCountAggregateInputType | true
    _min?: GeneratedInterviewPrepMinAggregateInputType
    _max?: GeneratedInterviewPrepMaxAggregateInputType
  }

  export type GeneratedInterviewPrepGroupByOutputType = {
    id: string
    userId: string | null
    roastId: string | null
    extractedResumeId: string | null
    extractedJobId: string | null
    contentHash: string
    data: JsonValue
    difficulty: string
    category: string
    modelName: string | null
    createdAt: Date
    _count: GeneratedInterviewPrepCountAggregateOutputType | null
    _min: GeneratedInterviewPrepMinAggregateOutputType | null
    _max: GeneratedInterviewPrepMaxAggregateOutputType | null
  }

  type GetGeneratedInterviewPrepGroupByPayload<T extends GeneratedInterviewPrepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneratedInterviewPrepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneratedInterviewPrepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneratedInterviewPrepGroupByOutputType[P]>
            : GetScalarType<T[P], GeneratedInterviewPrepGroupByOutputType[P]>
        }
      >
    >


  export type GeneratedInterviewPrepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    difficulty?: boolean
    category?: boolean
    modelName?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedInterviewPrep$userArgs<ExtArgs>
    roast?: boolean | GeneratedInterviewPrep$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedInterviewPrep$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedInterviewPrep$llmCallsArgs<ExtArgs>
    evaluations?: boolean | GeneratedInterviewPrep$evaluationsArgs<ExtArgs>
    _count?: boolean | GeneratedInterviewPrepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["generatedInterviewPrep"]>

  export type GeneratedInterviewPrepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    difficulty?: boolean
    category?: boolean
    modelName?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedInterviewPrep$userArgs<ExtArgs>
    roast?: boolean | GeneratedInterviewPrep$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedInterviewPrep$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedInterviewPrep"]>

  export type GeneratedInterviewPrepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    difficulty?: boolean
    category?: boolean
    modelName?: boolean
    createdAt?: boolean
    user?: boolean | GeneratedInterviewPrep$userArgs<ExtArgs>
    roast?: boolean | GeneratedInterviewPrep$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedInterviewPrep$extractedJobArgs<ExtArgs>
  }, ExtArgs["result"]["generatedInterviewPrep"]>

  export type GeneratedInterviewPrepSelectScalar = {
    id?: boolean
    userId?: boolean
    roastId?: boolean
    extractedResumeId?: boolean
    extractedJobId?: boolean
    contentHash?: boolean
    data?: boolean
    difficulty?: boolean
    category?: boolean
    modelName?: boolean
    createdAt?: boolean
  }

  export type GeneratedInterviewPrepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roastId" | "extractedResumeId" | "extractedJobId" | "contentHash" | "data" | "difficulty" | "category" | "modelName" | "createdAt", ExtArgs["result"]["generatedInterviewPrep"]>
  export type GeneratedInterviewPrepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedInterviewPrep$userArgs<ExtArgs>
    roast?: boolean | GeneratedInterviewPrep$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedInterviewPrep$extractedJobArgs<ExtArgs>
    llmCalls?: boolean | GeneratedInterviewPrep$llmCallsArgs<ExtArgs>
    evaluations?: boolean | GeneratedInterviewPrep$evaluationsArgs<ExtArgs>
    _count?: boolean | GeneratedInterviewPrepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneratedInterviewPrepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedInterviewPrep$userArgs<ExtArgs>
    roast?: boolean | GeneratedInterviewPrep$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedInterviewPrep$extractedJobArgs<ExtArgs>
  }
  export type GeneratedInterviewPrepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | GeneratedInterviewPrep$userArgs<ExtArgs>
    roast?: boolean | GeneratedInterviewPrep$roastArgs<ExtArgs>
    extractedResume?: boolean | GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>
    extractedJob?: boolean | GeneratedInterviewPrep$extractedJobArgs<ExtArgs>
  }

  export type $GeneratedInterviewPrepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GeneratedInterviewPrep"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      roast: Prisma.$GeneratedRoastPayload<ExtArgs> | null
      extractedResume: Prisma.$ExtractedResumePayload<ExtArgs> | null
      extractedJob: Prisma.$ExtractedJobDescriptionPayload<ExtArgs> | null
      llmCalls: Prisma.$LlmCallPayload<ExtArgs>[]
      evaluations: Prisma.$InterviewEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      roastId: string | null
      extractedResumeId: string | null
      extractedJobId: string | null
      contentHash: string
      data: Prisma.JsonValue
      difficulty: string
      category: string
      modelName: string | null
      createdAt: Date
    }, ExtArgs["result"]["generatedInterviewPrep"]>
    composites: {}
  }

  type GeneratedInterviewPrepGetPayload<S extends boolean | null | undefined | GeneratedInterviewPrepDefaultArgs> = $Result.GetResult<Prisma.$GeneratedInterviewPrepPayload, S>

  type GeneratedInterviewPrepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneratedInterviewPrepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneratedInterviewPrepCountAggregateInputType | true
    }

  export interface GeneratedInterviewPrepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GeneratedInterviewPrep'], meta: { name: 'GeneratedInterviewPrep' } }
    /**
     * Find zero or one GeneratedInterviewPrep that matches the filter.
     * @param {GeneratedInterviewPrepFindUniqueArgs} args - Arguments to find a GeneratedInterviewPrep
     * @example
     * // Get one GeneratedInterviewPrep
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneratedInterviewPrepFindUniqueArgs>(args: SelectSubset<T, GeneratedInterviewPrepFindUniqueArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GeneratedInterviewPrep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneratedInterviewPrepFindUniqueOrThrowArgs} args - Arguments to find a GeneratedInterviewPrep
     * @example
     * // Get one GeneratedInterviewPrep
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneratedInterviewPrepFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneratedInterviewPrepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedInterviewPrep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepFindFirstArgs} args - Arguments to find a GeneratedInterviewPrep
     * @example
     * // Get one GeneratedInterviewPrep
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneratedInterviewPrepFindFirstArgs>(args?: SelectSubset<T, GeneratedInterviewPrepFindFirstArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GeneratedInterviewPrep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepFindFirstOrThrowArgs} args - Arguments to find a GeneratedInterviewPrep
     * @example
     * // Get one GeneratedInterviewPrep
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneratedInterviewPrepFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneratedInterviewPrepFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GeneratedInterviewPreps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GeneratedInterviewPreps
     * const generatedInterviewPreps = await prisma.generatedInterviewPrep.findMany()
     * 
     * // Get first 10 GeneratedInterviewPreps
     * const generatedInterviewPreps = await prisma.generatedInterviewPrep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generatedInterviewPrepWithIdOnly = await prisma.generatedInterviewPrep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneratedInterviewPrepFindManyArgs>(args?: SelectSubset<T, GeneratedInterviewPrepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GeneratedInterviewPrep.
     * @param {GeneratedInterviewPrepCreateArgs} args - Arguments to create a GeneratedInterviewPrep.
     * @example
     * // Create one GeneratedInterviewPrep
     * const GeneratedInterviewPrep = await prisma.generatedInterviewPrep.create({
     *   data: {
     *     // ... data to create a GeneratedInterviewPrep
     *   }
     * })
     * 
     */
    create<T extends GeneratedInterviewPrepCreateArgs>(args: SelectSubset<T, GeneratedInterviewPrepCreateArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GeneratedInterviewPreps.
     * @param {GeneratedInterviewPrepCreateManyArgs} args - Arguments to create many GeneratedInterviewPreps.
     * @example
     * // Create many GeneratedInterviewPreps
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneratedInterviewPrepCreateManyArgs>(args?: SelectSubset<T, GeneratedInterviewPrepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GeneratedInterviewPreps and returns the data saved in the database.
     * @param {GeneratedInterviewPrepCreateManyAndReturnArgs} args - Arguments to create many GeneratedInterviewPreps.
     * @example
     * // Create many GeneratedInterviewPreps
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GeneratedInterviewPreps and only return the `id`
     * const generatedInterviewPrepWithIdOnly = await prisma.generatedInterviewPrep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneratedInterviewPrepCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneratedInterviewPrepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GeneratedInterviewPrep.
     * @param {GeneratedInterviewPrepDeleteArgs} args - Arguments to delete one GeneratedInterviewPrep.
     * @example
     * // Delete one GeneratedInterviewPrep
     * const GeneratedInterviewPrep = await prisma.generatedInterviewPrep.delete({
     *   where: {
     *     // ... filter to delete one GeneratedInterviewPrep
     *   }
     * })
     * 
     */
    delete<T extends GeneratedInterviewPrepDeleteArgs>(args: SelectSubset<T, GeneratedInterviewPrepDeleteArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GeneratedInterviewPrep.
     * @param {GeneratedInterviewPrepUpdateArgs} args - Arguments to update one GeneratedInterviewPrep.
     * @example
     * // Update one GeneratedInterviewPrep
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneratedInterviewPrepUpdateArgs>(args: SelectSubset<T, GeneratedInterviewPrepUpdateArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GeneratedInterviewPreps.
     * @param {GeneratedInterviewPrepDeleteManyArgs} args - Arguments to filter GeneratedInterviewPreps to delete.
     * @example
     * // Delete a few GeneratedInterviewPreps
     * const { count } = await prisma.generatedInterviewPrep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneratedInterviewPrepDeleteManyArgs>(args?: SelectSubset<T, GeneratedInterviewPrepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedInterviewPreps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GeneratedInterviewPreps
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneratedInterviewPrepUpdateManyArgs>(args: SelectSubset<T, GeneratedInterviewPrepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GeneratedInterviewPreps and returns the data updated in the database.
     * @param {GeneratedInterviewPrepUpdateManyAndReturnArgs} args - Arguments to update many GeneratedInterviewPreps.
     * @example
     * // Update many GeneratedInterviewPreps
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GeneratedInterviewPreps and only return the `id`
     * const generatedInterviewPrepWithIdOnly = await prisma.generatedInterviewPrep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneratedInterviewPrepUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneratedInterviewPrepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GeneratedInterviewPrep.
     * @param {GeneratedInterviewPrepUpsertArgs} args - Arguments to update or create a GeneratedInterviewPrep.
     * @example
     * // Update or create a GeneratedInterviewPrep
     * const generatedInterviewPrep = await prisma.generatedInterviewPrep.upsert({
     *   create: {
     *     // ... data to create a GeneratedInterviewPrep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GeneratedInterviewPrep we want to update
     *   }
     * })
     */
    upsert<T extends GeneratedInterviewPrepUpsertArgs>(args: SelectSubset<T, GeneratedInterviewPrepUpsertArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GeneratedInterviewPreps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepCountArgs} args - Arguments to filter GeneratedInterviewPreps to count.
     * @example
     * // Count the number of GeneratedInterviewPreps
     * const count = await prisma.generatedInterviewPrep.count({
     *   where: {
     *     // ... the filter for the GeneratedInterviewPreps we want to count
     *   }
     * })
    **/
    count<T extends GeneratedInterviewPrepCountArgs>(
      args?: Subset<T, GeneratedInterviewPrepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneratedInterviewPrepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GeneratedInterviewPrep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneratedInterviewPrepAggregateArgs>(args: Subset<T, GeneratedInterviewPrepAggregateArgs>): Prisma.PrismaPromise<GetGeneratedInterviewPrepAggregateType<T>>

    /**
     * Group by GeneratedInterviewPrep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneratedInterviewPrepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneratedInterviewPrepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneratedInterviewPrepGroupByArgs['orderBy'] }
        : { orderBy?: GeneratedInterviewPrepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneratedInterviewPrepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneratedInterviewPrepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GeneratedInterviewPrep model
   */
  readonly fields: GeneratedInterviewPrepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GeneratedInterviewPrep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneratedInterviewPrepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends GeneratedInterviewPrep$userArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrep$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roast<T extends GeneratedInterviewPrep$roastArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrep$roastArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedResume<T extends GeneratedInterviewPrep$extractedResumeArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrep$extractedResumeArgs<ExtArgs>>): Prisma__ExtractedResumeClient<$Result.GetResult<Prisma.$ExtractedResumePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    extractedJob<T extends GeneratedInterviewPrep$extractedJobArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrep$extractedJobArgs<ExtArgs>>): Prisma__ExtractedJobDescriptionClient<$Result.GetResult<Prisma.$ExtractedJobDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    llmCalls<T extends GeneratedInterviewPrep$llmCallsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrep$llmCallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LlmCallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluations<T extends GeneratedInterviewPrep$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrep$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GeneratedInterviewPrep model
   */
  interface GeneratedInterviewPrepFieldRefs {
    readonly id: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly userId: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly roastId: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly extractedResumeId: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly extractedJobId: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly contentHash: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly data: FieldRef<"GeneratedInterviewPrep", 'Json'>
    readonly difficulty: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly category: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly modelName: FieldRef<"GeneratedInterviewPrep", 'String'>
    readonly createdAt: FieldRef<"GeneratedInterviewPrep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GeneratedInterviewPrep findUnique
   */
  export type GeneratedInterviewPrepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedInterviewPrep to fetch.
     */
    where: GeneratedInterviewPrepWhereUniqueInput
  }

  /**
   * GeneratedInterviewPrep findUniqueOrThrow
   */
  export type GeneratedInterviewPrepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedInterviewPrep to fetch.
     */
    where: GeneratedInterviewPrepWhereUniqueInput
  }

  /**
   * GeneratedInterviewPrep findFirst
   */
  export type GeneratedInterviewPrepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedInterviewPrep to fetch.
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedInterviewPreps to fetch.
     */
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedInterviewPreps.
     */
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedInterviewPreps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedInterviewPreps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedInterviewPreps.
     */
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * GeneratedInterviewPrep findFirstOrThrow
   */
  export type GeneratedInterviewPrepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedInterviewPrep to fetch.
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedInterviewPreps to fetch.
     */
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GeneratedInterviewPreps.
     */
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedInterviewPreps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedInterviewPreps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GeneratedInterviewPreps.
     */
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * GeneratedInterviewPrep findMany
   */
  export type GeneratedInterviewPrepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * Filter, which GeneratedInterviewPreps to fetch.
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GeneratedInterviewPreps to fetch.
     */
    orderBy?: GeneratedInterviewPrepOrderByWithRelationInput | GeneratedInterviewPrepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GeneratedInterviewPreps.
     */
    cursor?: GeneratedInterviewPrepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GeneratedInterviewPreps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GeneratedInterviewPreps.
     */
    skip?: number
    distinct?: GeneratedInterviewPrepScalarFieldEnum | GeneratedInterviewPrepScalarFieldEnum[]
  }

  /**
   * GeneratedInterviewPrep create
   */
  export type GeneratedInterviewPrepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * The data needed to create a GeneratedInterviewPrep.
     */
    data: XOR<GeneratedInterviewPrepCreateInput, GeneratedInterviewPrepUncheckedCreateInput>
  }

  /**
   * GeneratedInterviewPrep createMany
   */
  export type GeneratedInterviewPrepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GeneratedInterviewPreps.
     */
    data: GeneratedInterviewPrepCreateManyInput | GeneratedInterviewPrepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GeneratedInterviewPrep createManyAndReturn
   */
  export type GeneratedInterviewPrepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * The data used to create many GeneratedInterviewPreps.
     */
    data: GeneratedInterviewPrepCreateManyInput | GeneratedInterviewPrepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedInterviewPrep update
   */
  export type GeneratedInterviewPrepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * The data needed to update a GeneratedInterviewPrep.
     */
    data: XOR<GeneratedInterviewPrepUpdateInput, GeneratedInterviewPrepUncheckedUpdateInput>
    /**
     * Choose, which GeneratedInterviewPrep to update.
     */
    where: GeneratedInterviewPrepWhereUniqueInput
  }

  /**
   * GeneratedInterviewPrep updateMany
   */
  export type GeneratedInterviewPrepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GeneratedInterviewPreps.
     */
    data: XOR<GeneratedInterviewPrepUpdateManyMutationInput, GeneratedInterviewPrepUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedInterviewPreps to update
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * Limit how many GeneratedInterviewPreps to update.
     */
    limit?: number
  }

  /**
   * GeneratedInterviewPrep updateManyAndReturn
   */
  export type GeneratedInterviewPrepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * The data used to update GeneratedInterviewPreps.
     */
    data: XOR<GeneratedInterviewPrepUpdateManyMutationInput, GeneratedInterviewPrepUncheckedUpdateManyInput>
    /**
     * Filter which GeneratedInterviewPreps to update
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * Limit how many GeneratedInterviewPreps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GeneratedInterviewPrep upsert
   */
  export type GeneratedInterviewPrepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * The filter to search for the GeneratedInterviewPrep to update in case it exists.
     */
    where: GeneratedInterviewPrepWhereUniqueInput
    /**
     * In case the GeneratedInterviewPrep found by the `where` argument doesn't exist, create a new GeneratedInterviewPrep with this data.
     */
    create: XOR<GeneratedInterviewPrepCreateInput, GeneratedInterviewPrepUncheckedCreateInput>
    /**
     * In case the GeneratedInterviewPrep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneratedInterviewPrepUpdateInput, GeneratedInterviewPrepUncheckedUpdateInput>
  }

  /**
   * GeneratedInterviewPrep delete
   */
  export type GeneratedInterviewPrepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
    /**
     * Filter which GeneratedInterviewPrep to delete.
     */
    where: GeneratedInterviewPrepWhereUniqueInput
  }

  /**
   * GeneratedInterviewPrep deleteMany
   */
  export type GeneratedInterviewPrepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GeneratedInterviewPreps to delete
     */
    where?: GeneratedInterviewPrepWhereInput
    /**
     * Limit how many GeneratedInterviewPreps to delete.
     */
    limit?: number
  }

  /**
   * GeneratedInterviewPrep.user
   */
  export type GeneratedInterviewPrep$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * GeneratedInterviewPrep.roast
   */
  export type GeneratedInterviewPrep$roastArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedRoast
     */
    select?: GeneratedRoastSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedRoast
     */
    omit?: GeneratedRoastOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedRoastInclude<ExtArgs> | null
    where?: GeneratedRoastWhereInput
  }

  /**
   * GeneratedInterviewPrep.extractedResume
   */
  export type GeneratedInterviewPrep$extractedResumeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedResume
     */
    select?: ExtractedResumeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedResume
     */
    omit?: ExtractedResumeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedResumeInclude<ExtArgs> | null
    where?: ExtractedResumeWhereInput
  }

  /**
   * GeneratedInterviewPrep.extractedJob
   */
  export type GeneratedInterviewPrep$extractedJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtractedJobDescription
     */
    select?: ExtractedJobDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtractedJobDescription
     */
    omit?: ExtractedJobDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtractedJobDescriptionInclude<ExtArgs> | null
    where?: ExtractedJobDescriptionWhereInput
  }

  /**
   * GeneratedInterviewPrep.llmCalls
   */
  export type GeneratedInterviewPrep$llmCallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LlmCall
     */
    select?: LlmCallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LlmCall
     */
    omit?: LlmCallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LlmCallInclude<ExtArgs> | null
    where?: LlmCallWhereInput
    orderBy?: LlmCallOrderByWithRelationInput | LlmCallOrderByWithRelationInput[]
    cursor?: LlmCallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LlmCallScalarFieldEnum | LlmCallScalarFieldEnum[]
  }

  /**
   * GeneratedInterviewPrep.evaluations
   */
  export type GeneratedInterviewPrep$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    where?: InterviewEvaluationWhereInput
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    cursor?: InterviewEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * GeneratedInterviewPrep without action
   */
  export type GeneratedInterviewPrepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneratedInterviewPrep
     */
    select?: GeneratedInterviewPrepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GeneratedInterviewPrep
     */
    omit?: GeneratedInterviewPrepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneratedInterviewPrepInclude<ExtArgs> | null
  }


  /**
   * Model InterviewEvaluation
   */

  export type AggregateInterviewEvaluation = {
    _count: InterviewEvaluationCountAggregateOutputType | null
    _avg: InterviewEvaluationAvgAggregateOutputType | null
    _sum: InterviewEvaluationSumAggregateOutputType | null
    _min: InterviewEvaluationMinAggregateOutputType | null
    _max: InterviewEvaluationMaxAggregateOutputType | null
  }

  export type InterviewEvaluationAvgAggregateOutputType = {
    questionsCount: number | null
    overallScore: number | null
  }

  export type InterviewEvaluationSumAggregateOutputType = {
    questionsCount: number | null
    overallScore: number | null
  }

  export type InterviewEvaluationMinAggregateOutputType = {
    id: string | null
    interviewPrepId: string | null
    userId: string | null
    evaluationType: string | null
    questionsCount: number | null
    overallScore: number | null
    createdAt: Date | null
  }

  export type InterviewEvaluationMaxAggregateOutputType = {
    id: string | null
    interviewPrepId: string | null
    userId: string | null
    evaluationType: string | null
    questionsCount: number | null
    overallScore: number | null
    createdAt: Date | null
  }

  export type InterviewEvaluationCountAggregateOutputType = {
    id: number
    interviewPrepId: number
    userId: number
    evaluationType: number
    data: number
    questionsCount: number
    overallScore: number
    createdAt: number
    _all: number
  }


  export type InterviewEvaluationAvgAggregateInputType = {
    questionsCount?: true
    overallScore?: true
  }

  export type InterviewEvaluationSumAggregateInputType = {
    questionsCount?: true
    overallScore?: true
  }

  export type InterviewEvaluationMinAggregateInputType = {
    id?: true
    interviewPrepId?: true
    userId?: true
    evaluationType?: true
    questionsCount?: true
    overallScore?: true
    createdAt?: true
  }

  export type InterviewEvaluationMaxAggregateInputType = {
    id?: true
    interviewPrepId?: true
    userId?: true
    evaluationType?: true
    questionsCount?: true
    overallScore?: true
    createdAt?: true
  }

  export type InterviewEvaluationCountAggregateInputType = {
    id?: true
    interviewPrepId?: true
    userId?: true
    evaluationType?: true
    data?: true
    questionsCount?: true
    overallScore?: true
    createdAt?: true
    _all?: true
  }

  export type InterviewEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewEvaluation to aggregate.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewEvaluations
    **/
    _count?: true | InterviewEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewEvaluationMaxAggregateInputType
  }

  export type GetInterviewEvaluationAggregateType<T extends InterviewEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewEvaluation[P]>
      : GetScalarType<T[P], AggregateInterviewEvaluation[P]>
  }




  export type InterviewEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewEvaluationWhereInput
    orderBy?: InterviewEvaluationOrderByWithAggregationInput | InterviewEvaluationOrderByWithAggregationInput[]
    by: InterviewEvaluationScalarFieldEnum[] | InterviewEvaluationScalarFieldEnum
    having?: InterviewEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewEvaluationCountAggregateInputType | true
    _avg?: InterviewEvaluationAvgAggregateInputType
    _sum?: InterviewEvaluationSumAggregateInputType
    _min?: InterviewEvaluationMinAggregateInputType
    _max?: InterviewEvaluationMaxAggregateInputType
  }

  export type InterviewEvaluationGroupByOutputType = {
    id: string
    interviewPrepId: string
    userId: string | null
    evaluationType: string
    data: JsonValue
    questionsCount: number
    overallScore: number
    createdAt: Date
    _count: InterviewEvaluationCountAggregateOutputType | null
    _avg: InterviewEvaluationAvgAggregateOutputType | null
    _sum: InterviewEvaluationSumAggregateOutputType | null
    _min: InterviewEvaluationMinAggregateOutputType | null
    _max: InterviewEvaluationMaxAggregateOutputType | null
  }

  type GetInterviewEvaluationGroupByPayload<T extends InterviewEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type InterviewEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewPrepId?: boolean
    userId?: boolean
    evaluationType?: boolean
    data?: boolean
    questionsCount?: boolean
    overallScore?: boolean
    createdAt?: boolean
    user?: boolean | InterviewEvaluation$userArgs<ExtArgs>
    interviewPrep?: boolean | GeneratedInterviewPrepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewEvaluation"]>

  export type InterviewEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewPrepId?: boolean
    userId?: boolean
    evaluationType?: boolean
    data?: boolean
    questionsCount?: boolean
    overallScore?: boolean
    createdAt?: boolean
    user?: boolean | InterviewEvaluation$userArgs<ExtArgs>
    interviewPrep?: boolean | GeneratedInterviewPrepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewEvaluation"]>

  export type InterviewEvaluationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    interviewPrepId?: boolean
    userId?: boolean
    evaluationType?: boolean
    data?: boolean
    questionsCount?: boolean
    overallScore?: boolean
    createdAt?: boolean
    user?: boolean | InterviewEvaluation$userArgs<ExtArgs>
    interviewPrep?: boolean | GeneratedInterviewPrepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewEvaluation"]>

  export type InterviewEvaluationSelectScalar = {
    id?: boolean
    interviewPrepId?: boolean
    userId?: boolean
    evaluationType?: boolean
    data?: boolean
    questionsCount?: boolean
    overallScore?: boolean
    createdAt?: boolean
  }

  export type InterviewEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "interviewPrepId" | "userId" | "evaluationType" | "data" | "questionsCount" | "overallScore" | "createdAt", ExtArgs["result"]["interviewEvaluation"]>
  export type InterviewEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | InterviewEvaluation$userArgs<ExtArgs>
    interviewPrep?: boolean | GeneratedInterviewPrepDefaultArgs<ExtArgs>
  }
  export type InterviewEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | InterviewEvaluation$userArgs<ExtArgs>
    interviewPrep?: boolean | GeneratedInterviewPrepDefaultArgs<ExtArgs>
  }
  export type InterviewEvaluationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | InterviewEvaluation$userArgs<ExtArgs>
    interviewPrep?: boolean | GeneratedInterviewPrepDefaultArgs<ExtArgs>
  }

  export type $InterviewEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewEvaluation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      interviewPrep: Prisma.$GeneratedInterviewPrepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      interviewPrepId: string
      userId: string | null
      evaluationType: string
      data: Prisma.JsonValue
      questionsCount: number
      overallScore: number
      createdAt: Date
    }, ExtArgs["result"]["interviewEvaluation"]>
    composites: {}
  }

  type InterviewEvaluationGetPayload<S extends boolean | null | undefined | InterviewEvaluationDefaultArgs> = $Result.GetResult<Prisma.$InterviewEvaluationPayload, S>

  type InterviewEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterviewEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterviewEvaluationCountAggregateInputType | true
    }

  export interface InterviewEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewEvaluation'], meta: { name: 'InterviewEvaluation' } }
    /**
     * Find zero or one InterviewEvaluation that matches the filter.
     * @param {InterviewEvaluationFindUniqueArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewEvaluationFindUniqueArgs>(args: SelectSubset<T, InterviewEvaluationFindUniqueArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InterviewEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterviewEvaluationFindUniqueOrThrowArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationFindFirstArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewEvaluationFindFirstArgs>(args?: SelectSubset<T, InterviewEvaluationFindFirstArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InterviewEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationFindFirstOrThrowArgs} args - Arguments to find a InterviewEvaluation
     * @example
     * // Get one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InterviewEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewEvaluations
     * const interviewEvaluations = await prisma.interviewEvaluation.findMany()
     * 
     * // Get first 10 InterviewEvaluations
     * const interviewEvaluations = await prisma.interviewEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewEvaluationWithIdOnly = await prisma.interviewEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewEvaluationFindManyArgs>(args?: SelectSubset<T, InterviewEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InterviewEvaluation.
     * @param {InterviewEvaluationCreateArgs} args - Arguments to create a InterviewEvaluation.
     * @example
     * // Create one InterviewEvaluation
     * const InterviewEvaluation = await prisma.interviewEvaluation.create({
     *   data: {
     *     // ... data to create a InterviewEvaluation
     *   }
     * })
     * 
     */
    create<T extends InterviewEvaluationCreateArgs>(args: SelectSubset<T, InterviewEvaluationCreateArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InterviewEvaluations.
     * @param {InterviewEvaluationCreateManyArgs} args - Arguments to create many InterviewEvaluations.
     * @example
     * // Create many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewEvaluationCreateManyArgs>(args?: SelectSubset<T, InterviewEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewEvaluations and returns the data saved in the database.
     * @param {InterviewEvaluationCreateManyAndReturnArgs} args - Arguments to create many InterviewEvaluations.
     * @example
     * // Create many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewEvaluations and only return the `id`
     * const interviewEvaluationWithIdOnly = await prisma.interviewEvaluation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InterviewEvaluation.
     * @param {InterviewEvaluationDeleteArgs} args - Arguments to delete one InterviewEvaluation.
     * @example
     * // Delete one InterviewEvaluation
     * const InterviewEvaluation = await prisma.interviewEvaluation.delete({
     *   where: {
     *     // ... filter to delete one InterviewEvaluation
     *   }
     * })
     * 
     */
    delete<T extends InterviewEvaluationDeleteArgs>(args: SelectSubset<T, InterviewEvaluationDeleteArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InterviewEvaluation.
     * @param {InterviewEvaluationUpdateArgs} args - Arguments to update one InterviewEvaluation.
     * @example
     * // Update one InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewEvaluationUpdateArgs>(args: SelectSubset<T, InterviewEvaluationUpdateArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InterviewEvaluations.
     * @param {InterviewEvaluationDeleteManyArgs} args - Arguments to filter InterviewEvaluations to delete.
     * @example
     * // Delete a few InterviewEvaluations
     * const { count } = await prisma.interviewEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewEvaluationDeleteManyArgs>(args?: SelectSubset<T, InterviewEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewEvaluationUpdateManyArgs>(args: SelectSubset<T, InterviewEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewEvaluations and returns the data updated in the database.
     * @param {InterviewEvaluationUpdateManyAndReturnArgs} args - Arguments to update many InterviewEvaluations.
     * @example
     * // Update many InterviewEvaluations
     * const interviewEvaluation = await prisma.interviewEvaluation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InterviewEvaluations and only return the `id`
     * const interviewEvaluationWithIdOnly = await prisma.interviewEvaluation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterviewEvaluationUpdateManyAndReturnArgs>(args: SelectSubset<T, InterviewEvaluationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InterviewEvaluation.
     * @param {InterviewEvaluationUpsertArgs} args - Arguments to update or create a InterviewEvaluation.
     * @example
     * // Update or create a InterviewEvaluation
     * const interviewEvaluation = await prisma.interviewEvaluation.upsert({
     *   create: {
     *     // ... data to create a InterviewEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends InterviewEvaluationUpsertArgs>(args: SelectSubset<T, InterviewEvaluationUpsertArgs<ExtArgs>>): Prisma__InterviewEvaluationClient<$Result.GetResult<Prisma.$InterviewEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InterviewEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationCountArgs} args - Arguments to filter InterviewEvaluations to count.
     * @example
     * // Count the number of InterviewEvaluations
     * const count = await prisma.interviewEvaluation.count({
     *   where: {
     *     // ... the filter for the InterviewEvaluations we want to count
     *   }
     * })
    **/
    count<T extends InterviewEvaluationCountArgs>(
      args?: Subset<T, InterviewEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewEvaluationAggregateArgs>(args: Subset<T, InterviewEvaluationAggregateArgs>): Prisma.PrismaPromise<GetInterviewEvaluationAggregateType<T>>

    /**
     * Group by InterviewEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: InterviewEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewEvaluation model
   */
  readonly fields: InterviewEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends InterviewEvaluation$userArgs<ExtArgs> = {}>(args?: Subset<T, InterviewEvaluation$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    interviewPrep<T extends GeneratedInterviewPrepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedInterviewPrepDefaultArgs<ExtArgs>>): Prisma__GeneratedInterviewPrepClient<$Result.GetResult<Prisma.$GeneratedInterviewPrepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewEvaluation model
   */
  interface InterviewEvaluationFieldRefs {
    readonly id: FieldRef<"InterviewEvaluation", 'String'>
    readonly interviewPrepId: FieldRef<"InterviewEvaluation", 'String'>
    readonly userId: FieldRef<"InterviewEvaluation", 'String'>
    readonly evaluationType: FieldRef<"InterviewEvaluation", 'String'>
    readonly data: FieldRef<"InterviewEvaluation", 'Json'>
    readonly questionsCount: FieldRef<"InterviewEvaluation", 'Int'>
    readonly overallScore: FieldRef<"InterviewEvaluation", 'Int'>
    readonly createdAt: FieldRef<"InterviewEvaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewEvaluation findUnique
   */
  export type InterviewEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation findUniqueOrThrow
   */
  export type InterviewEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation findFirst
   */
  export type InterviewEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewEvaluations.
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewEvaluations.
     */
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * InterviewEvaluation findFirstOrThrow
   */
  export type InterviewEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluation to fetch.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewEvaluations.
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewEvaluations.
     */
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * InterviewEvaluation findMany
   */
  export type InterviewEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InterviewEvaluations to fetch.
     */
    where?: InterviewEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewEvaluations to fetch.
     */
    orderBy?: InterviewEvaluationOrderByWithRelationInput | InterviewEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewEvaluations.
     */
    cursor?: InterviewEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewEvaluations.
     */
    skip?: number
    distinct?: InterviewEvaluationScalarFieldEnum | InterviewEvaluationScalarFieldEnum[]
  }

  /**
   * InterviewEvaluation create
   */
  export type InterviewEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewEvaluation.
     */
    data: XOR<InterviewEvaluationCreateInput, InterviewEvaluationUncheckedCreateInput>
  }

  /**
   * InterviewEvaluation createMany
   */
  export type InterviewEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewEvaluations.
     */
    data: InterviewEvaluationCreateManyInput | InterviewEvaluationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewEvaluation createManyAndReturn
   */
  export type InterviewEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * The data used to create many InterviewEvaluations.
     */
    data: InterviewEvaluationCreateManyInput | InterviewEvaluationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewEvaluation update
   */
  export type InterviewEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewEvaluation.
     */
    data: XOR<InterviewEvaluationUpdateInput, InterviewEvaluationUncheckedUpdateInput>
    /**
     * Choose, which InterviewEvaluation to update.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation updateMany
   */
  export type InterviewEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewEvaluations.
     */
    data: XOR<InterviewEvaluationUpdateManyMutationInput, InterviewEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which InterviewEvaluations to update
     */
    where?: InterviewEvaluationWhereInput
    /**
     * Limit how many InterviewEvaluations to update.
     */
    limit?: number
  }

  /**
   * InterviewEvaluation updateManyAndReturn
   */
  export type InterviewEvaluationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * The data used to update InterviewEvaluations.
     */
    data: XOR<InterviewEvaluationUpdateManyMutationInput, InterviewEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which InterviewEvaluations to update
     */
    where?: InterviewEvaluationWhereInput
    /**
     * Limit how many InterviewEvaluations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewEvaluation upsert
   */
  export type InterviewEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewEvaluation to update in case it exists.
     */
    where: InterviewEvaluationWhereUniqueInput
    /**
     * In case the InterviewEvaluation found by the `where` argument doesn't exist, create a new InterviewEvaluation with this data.
     */
    create: XOR<InterviewEvaluationCreateInput, InterviewEvaluationUncheckedCreateInput>
    /**
     * In case the InterviewEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewEvaluationUpdateInput, InterviewEvaluationUncheckedUpdateInput>
  }

  /**
   * InterviewEvaluation delete
   */
  export type InterviewEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
    /**
     * Filter which InterviewEvaluation to delete.
     */
    where: InterviewEvaluationWhereUniqueInput
  }

  /**
   * InterviewEvaluation deleteMany
   */
  export type InterviewEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewEvaluations to delete
     */
    where?: InterviewEvaluationWhereInput
    /**
     * Limit how many InterviewEvaluations to delete.
     */
    limit?: number
  }

  /**
   * InterviewEvaluation.user
   */
  export type InterviewEvaluation$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InterviewEvaluation without action
   */
  export type InterviewEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewEvaluation
     */
    select?: InterviewEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InterviewEvaluation
     */
    omit?: InterviewEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model SharedAnalysis
   */

  export type AggregateSharedAnalysis = {
    _count: SharedAnalysisCountAggregateOutputType | null
    _avg: SharedAnalysisAvgAggregateOutputType | null
    _sum: SharedAnalysisSumAggregateOutputType | null
    _min: SharedAnalysisMinAggregateOutputType | null
    _max: SharedAnalysisMaxAggregateOutputType | null
  }

  export type SharedAnalysisAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type SharedAnalysisSumAggregateOutputType = {
    viewCount: number | null
  }

  export type SharedAnalysisMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roastId: string | null
    viewCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SharedAnalysisMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roastId: string | null
    viewCount: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SharedAnalysisCountAggregateOutputType = {
    id: number
    userId: number
    roastId: number
    settings: number
    viewCount: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SharedAnalysisAvgAggregateInputType = {
    viewCount?: true
  }

  export type SharedAnalysisSumAggregateInputType = {
    viewCount?: true
  }

  export type SharedAnalysisMinAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    viewCount?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SharedAnalysisMaxAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    viewCount?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SharedAnalysisCountAggregateInputType = {
    id?: true
    userId?: true
    roastId?: true
    settings?: true
    viewCount?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SharedAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAnalysis to aggregate.
     */
    where?: SharedAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAnalyses to fetch.
     */
    orderBy?: SharedAnalysisOrderByWithRelationInput | SharedAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedAnalyses
    **/
    _count?: true | SharedAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharedAnalysisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharedAnalysisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedAnalysisMaxAggregateInputType
  }

  export type GetSharedAnalysisAggregateType<T extends SharedAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedAnalysis[P]>
      : GetScalarType<T[P], AggregateSharedAnalysis[P]>
  }




  export type SharedAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedAnalysisWhereInput
    orderBy?: SharedAnalysisOrderByWithAggregationInput | SharedAnalysisOrderByWithAggregationInput[]
    by: SharedAnalysisScalarFieldEnum[] | SharedAnalysisScalarFieldEnum
    having?: SharedAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedAnalysisCountAggregateInputType | true
    _avg?: SharedAnalysisAvgAggregateInputType
    _sum?: SharedAnalysisSumAggregateInputType
    _min?: SharedAnalysisMinAggregateInputType
    _max?: SharedAnalysisMaxAggregateInputType
  }

  export type SharedAnalysisGroupByOutputType = {
    id: string
    userId: string
    roastId: string
    settings: JsonValue | null
    viewCount: number
    expiresAt: Date
    createdAt: Date
    _count: SharedAnalysisCountAggregateOutputType | null
    _avg: SharedAnalysisAvgAggregateOutputType | null
    _sum: SharedAnalysisSumAggregateOutputType | null
    _min: SharedAnalysisMinAggregateOutputType | null
    _max: SharedAnalysisMaxAggregateOutputType | null
  }

  type GetSharedAnalysisGroupByPayload<T extends SharedAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], SharedAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type SharedAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    settings?: boolean
    viewCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roast?: boolean | GeneratedRoastDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAnalysis"]>

  export type SharedAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    settings?: boolean
    viewCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roast?: boolean | GeneratedRoastDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAnalysis"]>

  export type SharedAnalysisSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roastId?: boolean
    settings?: boolean
    viewCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roast?: boolean | GeneratedRoastDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedAnalysis"]>

  export type SharedAnalysisSelectScalar = {
    id?: boolean
    userId?: boolean
    roastId?: boolean
    settings?: boolean
    viewCount?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SharedAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roastId" | "settings" | "viewCount" | "expiresAt" | "createdAt", ExtArgs["result"]["sharedAnalysis"]>
  export type SharedAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roast?: boolean | GeneratedRoastDefaultArgs<ExtArgs>
  }
  export type SharedAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roast?: boolean | GeneratedRoastDefaultArgs<ExtArgs>
  }
  export type SharedAnalysisIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roast?: boolean | GeneratedRoastDefaultArgs<ExtArgs>
  }

  export type $SharedAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedAnalysis"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      roast: Prisma.$GeneratedRoastPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roastId: string
      settings: Prisma.JsonValue | null
      viewCount: number
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["sharedAnalysis"]>
    composites: {}
  }

  type SharedAnalysisGetPayload<S extends boolean | null | undefined | SharedAnalysisDefaultArgs> = $Result.GetResult<Prisma.$SharedAnalysisPayload, S>

  type SharedAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SharedAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SharedAnalysisCountAggregateInputType | true
    }

  export interface SharedAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedAnalysis'], meta: { name: 'SharedAnalysis' } }
    /**
     * Find zero or one SharedAnalysis that matches the filter.
     * @param {SharedAnalysisFindUniqueArgs} args - Arguments to find a SharedAnalysis
     * @example
     * // Get one SharedAnalysis
     * const sharedAnalysis = await prisma.sharedAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedAnalysisFindUniqueArgs>(args: SelectSubset<T, SharedAnalysisFindUniqueArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SharedAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SharedAnalysisFindUniqueOrThrowArgs} args - Arguments to find a SharedAnalysis
     * @example
     * // Get one SharedAnalysis
     * const sharedAnalysis = await prisma.sharedAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisFindFirstArgs} args - Arguments to find a SharedAnalysis
     * @example
     * // Get one SharedAnalysis
     * const sharedAnalysis = await prisma.sharedAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedAnalysisFindFirstArgs>(args?: SelectSubset<T, SharedAnalysisFindFirstArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SharedAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisFindFirstOrThrowArgs} args - Arguments to find a SharedAnalysis
     * @example
     * // Get one SharedAnalysis
     * const sharedAnalysis = await prisma.sharedAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SharedAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedAnalyses
     * const sharedAnalyses = await prisma.sharedAnalysis.findMany()
     * 
     * // Get first 10 SharedAnalyses
     * const sharedAnalyses = await prisma.sharedAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedAnalysisWithIdOnly = await prisma.sharedAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedAnalysisFindManyArgs>(args?: SelectSubset<T, SharedAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SharedAnalysis.
     * @param {SharedAnalysisCreateArgs} args - Arguments to create a SharedAnalysis.
     * @example
     * // Create one SharedAnalysis
     * const SharedAnalysis = await prisma.sharedAnalysis.create({
     *   data: {
     *     // ... data to create a SharedAnalysis
     *   }
     * })
     * 
     */
    create<T extends SharedAnalysisCreateArgs>(args: SelectSubset<T, SharedAnalysisCreateArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SharedAnalyses.
     * @param {SharedAnalysisCreateManyArgs} args - Arguments to create many SharedAnalyses.
     * @example
     * // Create many SharedAnalyses
     * const sharedAnalysis = await prisma.sharedAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedAnalysisCreateManyArgs>(args?: SelectSubset<T, SharedAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedAnalyses and returns the data saved in the database.
     * @param {SharedAnalysisCreateManyAndReturnArgs} args - Arguments to create many SharedAnalyses.
     * @example
     * // Create many SharedAnalyses
     * const sharedAnalysis = await prisma.sharedAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedAnalyses and only return the `id`
     * const sharedAnalysisWithIdOnly = await prisma.sharedAnalysis.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SharedAnalysis.
     * @param {SharedAnalysisDeleteArgs} args - Arguments to delete one SharedAnalysis.
     * @example
     * // Delete one SharedAnalysis
     * const SharedAnalysis = await prisma.sharedAnalysis.delete({
     *   where: {
     *     // ... filter to delete one SharedAnalysis
     *   }
     * })
     * 
     */
    delete<T extends SharedAnalysisDeleteArgs>(args: SelectSubset<T, SharedAnalysisDeleteArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SharedAnalysis.
     * @param {SharedAnalysisUpdateArgs} args - Arguments to update one SharedAnalysis.
     * @example
     * // Update one SharedAnalysis
     * const sharedAnalysis = await prisma.sharedAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedAnalysisUpdateArgs>(args: SelectSubset<T, SharedAnalysisUpdateArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SharedAnalyses.
     * @param {SharedAnalysisDeleteManyArgs} args - Arguments to filter SharedAnalyses to delete.
     * @example
     * // Delete a few SharedAnalyses
     * const { count } = await prisma.sharedAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedAnalysisDeleteManyArgs>(args?: SelectSubset<T, SharedAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedAnalyses
     * const sharedAnalysis = await prisma.sharedAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedAnalysisUpdateManyArgs>(args: SelectSubset<T, SharedAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedAnalyses and returns the data updated in the database.
     * @param {SharedAnalysisUpdateManyAndReturnArgs} args - Arguments to update many SharedAnalyses.
     * @example
     * // Update many SharedAnalyses
     * const sharedAnalysis = await prisma.sharedAnalysis.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SharedAnalyses and only return the `id`
     * const sharedAnalysisWithIdOnly = await prisma.sharedAnalysis.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SharedAnalysisUpdateManyAndReturnArgs>(args: SelectSubset<T, SharedAnalysisUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SharedAnalysis.
     * @param {SharedAnalysisUpsertArgs} args - Arguments to update or create a SharedAnalysis.
     * @example
     * // Update or create a SharedAnalysis
     * const sharedAnalysis = await prisma.sharedAnalysis.upsert({
     *   create: {
     *     // ... data to create a SharedAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends SharedAnalysisUpsertArgs>(args: SelectSubset<T, SharedAnalysisUpsertArgs<ExtArgs>>): Prisma__SharedAnalysisClient<$Result.GetResult<Prisma.$SharedAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SharedAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisCountArgs} args - Arguments to filter SharedAnalyses to count.
     * @example
     * // Count the number of SharedAnalyses
     * const count = await prisma.sharedAnalysis.count({
     *   where: {
     *     // ... the filter for the SharedAnalyses we want to count
     *   }
     * })
    **/
    count<T extends SharedAnalysisCountArgs>(
      args?: Subset<T, SharedAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedAnalysisAggregateArgs>(args: Subset<T, SharedAnalysisAggregateArgs>): Prisma.PrismaPromise<GetSharedAnalysisAggregateType<T>>

    /**
     * Group by SharedAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: SharedAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedAnalysis model
   */
  readonly fields: SharedAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roast<T extends GeneratedRoastDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GeneratedRoastDefaultArgs<ExtArgs>>): Prisma__GeneratedRoastClient<$Result.GetResult<Prisma.$GeneratedRoastPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedAnalysis model
   */
  interface SharedAnalysisFieldRefs {
    readonly id: FieldRef<"SharedAnalysis", 'String'>
    readonly userId: FieldRef<"SharedAnalysis", 'String'>
    readonly roastId: FieldRef<"SharedAnalysis", 'String'>
    readonly settings: FieldRef<"SharedAnalysis", 'Json'>
    readonly viewCount: FieldRef<"SharedAnalysis", 'Int'>
    readonly expiresAt: FieldRef<"SharedAnalysis", 'DateTime'>
    readonly createdAt: FieldRef<"SharedAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedAnalysis findUnique
   */
  export type SharedAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SharedAnalysis to fetch.
     */
    where: SharedAnalysisWhereUniqueInput
  }

  /**
   * SharedAnalysis findUniqueOrThrow
   */
  export type SharedAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SharedAnalysis to fetch.
     */
    where: SharedAnalysisWhereUniqueInput
  }

  /**
   * SharedAnalysis findFirst
   */
  export type SharedAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SharedAnalysis to fetch.
     */
    where?: SharedAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAnalyses to fetch.
     */
    orderBy?: SharedAnalysisOrderByWithRelationInput | SharedAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAnalyses.
     */
    cursor?: SharedAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAnalyses.
     */
    distinct?: SharedAnalysisScalarFieldEnum | SharedAnalysisScalarFieldEnum[]
  }

  /**
   * SharedAnalysis findFirstOrThrow
   */
  export type SharedAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SharedAnalysis to fetch.
     */
    where?: SharedAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAnalyses to fetch.
     */
    orderBy?: SharedAnalysisOrderByWithRelationInput | SharedAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedAnalyses.
     */
    cursor?: SharedAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedAnalyses.
     */
    distinct?: SharedAnalysisScalarFieldEnum | SharedAnalysisScalarFieldEnum[]
  }

  /**
   * SharedAnalysis findMany
   */
  export type SharedAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which SharedAnalyses to fetch.
     */
    where?: SharedAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedAnalyses to fetch.
     */
    orderBy?: SharedAnalysisOrderByWithRelationInput | SharedAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedAnalyses.
     */
    cursor?: SharedAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedAnalyses.
     */
    skip?: number
    distinct?: SharedAnalysisScalarFieldEnum | SharedAnalysisScalarFieldEnum[]
  }

  /**
   * SharedAnalysis create
   */
  export type SharedAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedAnalysis.
     */
    data: XOR<SharedAnalysisCreateInput, SharedAnalysisUncheckedCreateInput>
  }

  /**
   * SharedAnalysis createMany
   */
  export type SharedAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedAnalyses.
     */
    data: SharedAnalysisCreateManyInput | SharedAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedAnalysis createManyAndReturn
   */
  export type SharedAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * The data used to create many SharedAnalyses.
     */
    data: SharedAnalysisCreateManyInput | SharedAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAnalysis update
   */
  export type SharedAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedAnalysis.
     */
    data: XOR<SharedAnalysisUpdateInput, SharedAnalysisUncheckedUpdateInput>
    /**
     * Choose, which SharedAnalysis to update.
     */
    where: SharedAnalysisWhereUniqueInput
  }

  /**
   * SharedAnalysis updateMany
   */
  export type SharedAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedAnalyses.
     */
    data: XOR<SharedAnalysisUpdateManyMutationInput, SharedAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which SharedAnalyses to update
     */
    where?: SharedAnalysisWhereInput
    /**
     * Limit how many SharedAnalyses to update.
     */
    limit?: number
  }

  /**
   * SharedAnalysis updateManyAndReturn
   */
  export type SharedAnalysisUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * The data used to update SharedAnalyses.
     */
    data: XOR<SharedAnalysisUpdateManyMutationInput, SharedAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which SharedAnalyses to update
     */
    where?: SharedAnalysisWhereInput
    /**
     * Limit how many SharedAnalyses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedAnalysis upsert
   */
  export type SharedAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedAnalysis to update in case it exists.
     */
    where: SharedAnalysisWhereUniqueInput
    /**
     * In case the SharedAnalysis found by the `where` argument doesn't exist, create a new SharedAnalysis with this data.
     */
    create: XOR<SharedAnalysisCreateInput, SharedAnalysisUncheckedCreateInput>
    /**
     * In case the SharedAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedAnalysisUpdateInput, SharedAnalysisUncheckedUpdateInput>
  }

  /**
   * SharedAnalysis delete
   */
  export type SharedAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
    /**
     * Filter which SharedAnalysis to delete.
     */
    where: SharedAnalysisWhereUniqueInput
  }

  /**
   * SharedAnalysis deleteMany
   */
  export type SharedAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedAnalyses to delete
     */
    where?: SharedAnalysisWhereInput
    /**
     * Limit how many SharedAnalyses to delete.
     */
    limit?: number
  }

  /**
   * SharedAnalysis without action
   */
  export type SharedAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedAnalysis
     */
    select?: SharedAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SharedAnalysis
     */
    omit?: SharedAnalysisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
    itemCount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
    itemCount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    stripeInvoiceId: string | null
    stripePaymentId: string | null
    itemCount: number | null
    generatedAt: Date | null
    paidAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    billingPeriodStart: Date | null
    billingPeriodEnd: Date | null
    stripeInvoiceId: string | null
    stripePaymentId: string | null
    itemCount: number | null
    generatedAt: Date | null
    paidAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    status: number
    billingPeriodStart: number
    billingPeriodEnd: number
    stripeInvoiceId: number
    stripePaymentId: number
    itemCount: number
    generatedAt: number
    paidAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
    itemCount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
    itemCount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    stripeInvoiceId?: true
    stripePaymentId?: true
    itemCount?: true
    generatedAt?: true
    paidAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    stripeInvoiceId?: true
    stripePaymentId?: true
    itemCount?: true
    generatedAt?: true
    paidAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    billingPeriodStart?: true
    billingPeriodEnd?: true
    stripeInvoiceId?: true
    stripePaymentId?: true
    itemCount?: true
    generatedAt?: true
    paidAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    userId: string
    amount: Decimal
    currency: string
    status: $Enums.InvoiceStatus
    billingPeriodStart: Date
    billingPeriodEnd: Date
    stripeInvoiceId: string | null
    stripePaymentId: string | null
    itemCount: number
    generatedAt: Date
    paidAt: Date | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    stripeInvoiceId?: boolean
    stripePaymentId?: boolean
    itemCount?: boolean
    generatedAt?: boolean
    paidAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    stripeInvoiceId?: boolean
    stripePaymentId?: boolean
    itemCount?: boolean
    generatedAt?: boolean
    paidAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    stripeInvoiceId?: boolean
    stripePaymentId?: boolean
    itemCount?: boolean
    generatedAt?: boolean
    paidAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    billingPeriodStart?: boolean
    billingPeriodEnd?: boolean
    stripeInvoiceId?: boolean
    stripePaymentId?: boolean
    itemCount?: boolean
    generatedAt?: boolean
    paidAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "currency" | "status" | "billingPeriodStart" | "billingPeriodEnd" | "stripeInvoiceId" | "stripePaymentId" | "itemCount" | "generatedAt" | "paidAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: Prisma.Decimal
      currency: string
      status: $Enums.InvoiceStatus
      billingPeriodStart: Date
      billingPeriodEnd: Date
      stripeInvoiceId: string | null
      stripePaymentId: string | null
      itemCount: number
      generatedAt: Date
      paidAt: Date | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly billingPeriodStart: FieldRef<"Invoice", 'DateTime'>
    readonly billingPeriodEnd: FieldRef<"Invoice", 'DateTime'>
    readonly stripeInvoiceId: FieldRef<"Invoice", 'String'>
    readonly stripePaymentId: FieldRef<"Invoice", 'String'>
    readonly itemCount: FieldRef<"Invoice", 'Int'>
    readonly generatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  export type AnnouncementMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    featureName: string | null
    estimatedDate: string | null
    type: $Enums.AnnouncementType | null
    ctaText: string | null
    ctaUrl: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    featureName: string | null
    estimatedDate: string | null
    type: $Enums.AnnouncementType | null
    ctaText: string | null
    ctaUrl: string | null
    isActive: boolean | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnouncementCountAggregateOutputType = {
    id: number
    title: number
    description: number
    featureName: number
    estimatedDate: number
    type: number
    ctaText: number
    ctaUrl: number
    isActive: number
    startDate: number
    endDate: number
    targetTiers: number
    dismissedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnouncementMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    featureName?: true
    estimatedDate?: true
    type?: true
    ctaText?: true
    ctaUrl?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    featureName?: true
    estimatedDate?: true
    type?: true
    ctaText?: true
    ctaUrl?: true
    isActive?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnouncementCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    featureName?: true
    estimatedDate?: true
    type?: true
    ctaText?: true
    ctaUrl?: true
    isActive?: true
    startDate?: true
    endDate?: true
    targetTiers?: true
    dismissedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnouncementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Announcements
    **/
    _count?: true | AnnouncementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnouncementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnouncementMaxAggregateInputType
  }

  export type GetAnnouncementAggregateType<T extends AnnouncementAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>
  }




  export type AnnouncementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnouncementWhereInput
    orderBy?: AnnouncementOrderByWithAggregationInput | AnnouncementOrderByWithAggregationInput[]
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum
    having?: AnnouncementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnouncementCountAggregateInputType | true
    _min?: AnnouncementMinAggregateInputType
    _max?: AnnouncementMaxAggregateInputType
  }

  export type AnnouncementGroupByOutputType = {
    id: string
    title: string
    description: string
    featureName: string | null
    estimatedDate: string | null
    type: $Enums.AnnouncementType
    ctaText: string | null
    ctaUrl: string | null
    isActive: boolean
    startDate: Date | null
    endDate: Date | null
    targetTiers: $Enums.SubscriptionTier[]
    dismissedBy: string[]
    createdAt: Date
    updatedAt: Date
    _count: AnnouncementCountAggregateOutputType | null
    _min: AnnouncementMinAggregateOutputType | null
    _max: AnnouncementMaxAggregateOutputType | null
  }

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnouncementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
        }
      >
    >


  export type AnnouncementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    featureName?: boolean
    estimatedDate?: boolean
    type?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    targetTiers?: boolean
    dismissedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    featureName?: boolean
    estimatedDate?: boolean
    type?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    targetTiers?: boolean
    dismissedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    featureName?: boolean
    estimatedDate?: boolean
    type?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    targetTiers?: boolean
    dismissedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["announcement"]>

  export type AnnouncementSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    featureName?: boolean
    estimatedDate?: boolean
    type?: boolean
    ctaText?: boolean
    ctaUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    endDate?: boolean
    targetTiers?: boolean
    dismissedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnouncementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "featureName" | "estimatedDate" | "type" | "ctaText" | "ctaUrl" | "isActive" | "startDate" | "endDate" | "targetTiers" | "dismissedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["announcement"]>

  export type $AnnouncementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Announcement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      featureName: string | null
      estimatedDate: string | null
      type: $Enums.AnnouncementType
      ctaText: string | null
      ctaUrl: string | null
      isActive: boolean
      startDate: Date | null
      endDate: Date | null
      targetTiers: $Enums.SubscriptionTier[]
      dismissedBy: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["announcement"]>
    composites: {}
  }

  type AnnouncementGetPayload<S extends boolean | null | undefined | AnnouncementDefaultArgs> = $Result.GetResult<Prisma.$AnnouncementPayload, S>

  type AnnouncementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnouncementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnouncementCountAggregateInputType | true
    }

  export interface AnnouncementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Announcement'], meta: { name: 'Announcement' } }
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     * 
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnouncementFindManyArgs>(args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     * 
     */
    create<T extends AnnouncementCreateArgs>(args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnouncementCreateManyArgs>(args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Announcements and returns the data saved in the database.
     * @param {AnnouncementCreateManyAndReturnArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnouncementCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnouncementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     * 
     */
    delete<T extends AnnouncementDeleteArgs>(args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnouncementUpdateArgs>(args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Announcements and returns the data updated in the database.
     * @param {AnnouncementUpdateManyAndReturnArgs} args - Arguments to update many Announcements.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Announcements and only return the `id`
     * const announcementWithIdOnly = await prisma.announcement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnouncementUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnouncementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>): Prisma__AnnouncementClient<$Result.GetResult<Prisma.$AnnouncementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
    **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnouncementAggregateArgs>(args: Subset<T, AnnouncementAggregateArgs>): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnouncementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Announcement model
   */
  readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<"Announcement", 'String'>
    readonly title: FieldRef<"Announcement", 'String'>
    readonly description: FieldRef<"Announcement", 'String'>
    readonly featureName: FieldRef<"Announcement", 'String'>
    readonly estimatedDate: FieldRef<"Announcement", 'String'>
    readonly type: FieldRef<"Announcement", 'AnnouncementType'>
    readonly ctaText: FieldRef<"Announcement", 'String'>
    readonly ctaUrl: FieldRef<"Announcement", 'String'>
    readonly isActive: FieldRef<"Announcement", 'Boolean'>
    readonly startDate: FieldRef<"Announcement", 'DateTime'>
    readonly endDate: FieldRef<"Announcement", 'DateTime'>
    readonly targetTiers: FieldRef<"Announcement", 'SubscriptionTier[]'>
    readonly dismissedBy: FieldRef<"Announcement", 'String[]'>
    readonly createdAt: FieldRef<"Announcement", 'DateTime'>
    readonly updatedAt: FieldRef<"Announcement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Announcements to fetch.
     */
    orderBy?: AnnouncementOrderByWithRelationInput | AnnouncementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Announcements.
     */
    skip?: number
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[]
  }

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
  }

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement createManyAndReturn
   */
  export type AnnouncementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement updateManyAndReturn
   */
  export type AnnouncementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The data used to update Announcements.
     */
    data: XOR<AnnouncementUpdateManyMutationInput, AnnouncementUncheckedUpdateManyInput>
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to update.
     */
    limit?: number
  }

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>
  }

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput
  }

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number
  }

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null
  }


  /**
   * Model Chatbot
   */

  export type AggregateChatbot = {
    _count: ChatbotCountAggregateOutputType | null
    _min: ChatbotMinAggregateOutputType | null
    _max: ChatbotMaxAggregateOutputType | null
  }

  export type ChatbotMinAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    conversationId: string | null
    message: string | null
    role: string | null
    llmMessageId: string | null
    createdAt: Date | null
  }

  export type ChatbotMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    anonymousId: string | null
    conversationId: string | null
    message: string | null
    role: string | null
    llmMessageId: string | null
    createdAt: Date | null
  }

  export type ChatbotCountAggregateOutputType = {
    id: number
    userId: number
    anonymousId: number
    conversationId: number
    message: number
    role: number
    llmMessageId: number
    createdAt: number
    _all: number
  }


  export type ChatbotMinAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    conversationId?: true
    message?: true
    role?: true
    llmMessageId?: true
    createdAt?: true
  }

  export type ChatbotMaxAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    conversationId?: true
    message?: true
    role?: true
    llmMessageId?: true
    createdAt?: true
  }

  export type ChatbotCountAggregateInputType = {
    id?: true
    userId?: true
    anonymousId?: true
    conversationId?: true
    message?: true
    role?: true
    llmMessageId?: true
    createdAt?: true
    _all?: true
  }

  export type ChatbotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatbot to aggregate.
     */
    where?: ChatbotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatbots to fetch.
     */
    orderBy?: ChatbotOrderByWithRelationInput | ChatbotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatbotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatbots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatbots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chatbots
    **/
    _count?: true | ChatbotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatbotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatbotMaxAggregateInputType
  }

  export type GetChatbotAggregateType<T extends ChatbotAggregateArgs> = {
        [P in keyof T & keyof AggregateChatbot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatbot[P]>
      : GetScalarType<T[P], AggregateChatbot[P]>
  }




  export type ChatbotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatbotWhereInput
    orderBy?: ChatbotOrderByWithAggregationInput | ChatbotOrderByWithAggregationInput[]
    by: ChatbotScalarFieldEnum[] | ChatbotScalarFieldEnum
    having?: ChatbotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatbotCountAggregateInputType | true
    _min?: ChatbotMinAggregateInputType
    _max?: ChatbotMaxAggregateInputType
  }

  export type ChatbotGroupByOutputType = {
    id: string
    userId: string | null
    anonymousId: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId: string | null
    createdAt: Date
    _count: ChatbotCountAggregateOutputType | null
    _min: ChatbotMinAggregateOutputType | null
    _max: ChatbotMaxAggregateOutputType | null
  }

  type GetChatbotGroupByPayload<T extends ChatbotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatbotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatbotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatbotGroupByOutputType[P]>
            : GetScalarType<T[P], ChatbotGroupByOutputType[P]>
        }
      >
    >


  export type ChatbotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    conversationId?: boolean
    message?: boolean
    role?: boolean
    llmMessageId?: boolean
    createdAt?: boolean
    user?: boolean | Chatbot$userArgs<ExtArgs>
  }, ExtArgs["result"]["chatbot"]>

  export type ChatbotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    conversationId?: boolean
    message?: boolean
    role?: boolean
    llmMessageId?: boolean
    createdAt?: boolean
    user?: boolean | Chatbot$userArgs<ExtArgs>
  }, ExtArgs["result"]["chatbot"]>

  export type ChatbotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    conversationId?: boolean
    message?: boolean
    role?: boolean
    llmMessageId?: boolean
    createdAt?: boolean
    user?: boolean | Chatbot$userArgs<ExtArgs>
  }, ExtArgs["result"]["chatbot"]>

  export type ChatbotSelectScalar = {
    id?: boolean
    userId?: boolean
    anonymousId?: boolean
    conversationId?: boolean
    message?: boolean
    role?: boolean
    llmMessageId?: boolean
    createdAt?: boolean
  }

  export type ChatbotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "anonymousId" | "conversationId" | "message" | "role" | "llmMessageId" | "createdAt", ExtArgs["result"]["chatbot"]>
  export type ChatbotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Chatbot$userArgs<ExtArgs>
  }
  export type ChatbotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Chatbot$userArgs<ExtArgs>
  }
  export type ChatbotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Chatbot$userArgs<ExtArgs>
  }

  export type $ChatbotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chatbot"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      anonymousId: string | null
      conversationId: string
      message: string
      role: string
      llmMessageId: string | null
      createdAt: Date
    }, ExtArgs["result"]["chatbot"]>
    composites: {}
  }

  type ChatbotGetPayload<S extends boolean | null | undefined | ChatbotDefaultArgs> = $Result.GetResult<Prisma.$ChatbotPayload, S>

  type ChatbotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatbotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatbotCountAggregateInputType | true
    }

  export interface ChatbotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chatbot'], meta: { name: 'Chatbot' } }
    /**
     * Find zero or one Chatbot that matches the filter.
     * @param {ChatbotFindUniqueArgs} args - Arguments to find a Chatbot
     * @example
     * // Get one Chatbot
     * const chatbot = await prisma.chatbot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatbotFindUniqueArgs>(args: SelectSubset<T, ChatbotFindUniqueArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatbot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatbotFindUniqueOrThrowArgs} args - Arguments to find a Chatbot
     * @example
     * // Get one Chatbot
     * const chatbot = await prisma.chatbot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatbotFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatbotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatbot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFindFirstArgs} args - Arguments to find a Chatbot
     * @example
     * // Get one Chatbot
     * const chatbot = await prisma.chatbot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatbotFindFirstArgs>(args?: SelectSubset<T, ChatbotFindFirstArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatbot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFindFirstOrThrowArgs} args - Arguments to find a Chatbot
     * @example
     * // Get one Chatbot
     * const chatbot = await prisma.chatbot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatbotFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatbotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatbots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatbots
     * const chatbots = await prisma.chatbot.findMany()
     * 
     * // Get first 10 Chatbots
     * const chatbots = await prisma.chatbot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatbotWithIdOnly = await prisma.chatbot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatbotFindManyArgs>(args?: SelectSubset<T, ChatbotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatbot.
     * @param {ChatbotCreateArgs} args - Arguments to create a Chatbot.
     * @example
     * // Create one Chatbot
     * const Chatbot = await prisma.chatbot.create({
     *   data: {
     *     // ... data to create a Chatbot
     *   }
     * })
     * 
     */
    create<T extends ChatbotCreateArgs>(args: SelectSubset<T, ChatbotCreateArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatbots.
     * @param {ChatbotCreateManyArgs} args - Arguments to create many Chatbots.
     * @example
     * // Create many Chatbots
     * const chatbot = await prisma.chatbot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatbotCreateManyArgs>(args?: SelectSubset<T, ChatbotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatbots and returns the data saved in the database.
     * @param {ChatbotCreateManyAndReturnArgs} args - Arguments to create many Chatbots.
     * @example
     * // Create many Chatbots
     * const chatbot = await prisma.chatbot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatbots and only return the `id`
     * const chatbotWithIdOnly = await prisma.chatbot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatbotCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatbotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatbot.
     * @param {ChatbotDeleteArgs} args - Arguments to delete one Chatbot.
     * @example
     * // Delete one Chatbot
     * const Chatbot = await prisma.chatbot.delete({
     *   where: {
     *     // ... filter to delete one Chatbot
     *   }
     * })
     * 
     */
    delete<T extends ChatbotDeleteArgs>(args: SelectSubset<T, ChatbotDeleteArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatbot.
     * @param {ChatbotUpdateArgs} args - Arguments to update one Chatbot.
     * @example
     * // Update one Chatbot
     * const chatbot = await prisma.chatbot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatbotUpdateArgs>(args: SelectSubset<T, ChatbotUpdateArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatbots.
     * @param {ChatbotDeleteManyArgs} args - Arguments to filter Chatbots to delete.
     * @example
     * // Delete a few Chatbots
     * const { count } = await prisma.chatbot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatbotDeleteManyArgs>(args?: SelectSubset<T, ChatbotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatbots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatbots
     * const chatbot = await prisma.chatbot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatbotUpdateManyArgs>(args: SelectSubset<T, ChatbotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatbots and returns the data updated in the database.
     * @param {ChatbotUpdateManyAndReturnArgs} args - Arguments to update many Chatbots.
     * @example
     * // Update many Chatbots
     * const chatbot = await prisma.chatbot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatbots and only return the `id`
     * const chatbotWithIdOnly = await prisma.chatbot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatbotUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatbotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatbot.
     * @param {ChatbotUpsertArgs} args - Arguments to update or create a Chatbot.
     * @example
     * // Update or create a Chatbot
     * const chatbot = await prisma.chatbot.upsert({
     *   create: {
     *     // ... data to create a Chatbot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatbot we want to update
     *   }
     * })
     */
    upsert<T extends ChatbotUpsertArgs>(args: SelectSubset<T, ChatbotUpsertArgs<ExtArgs>>): Prisma__ChatbotClient<$Result.GetResult<Prisma.$ChatbotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatbots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotCountArgs} args - Arguments to filter Chatbots to count.
     * @example
     * // Count the number of Chatbots
     * const count = await prisma.chatbot.count({
     *   where: {
     *     // ... the filter for the Chatbots we want to count
     *   }
     * })
    **/
    count<T extends ChatbotCountArgs>(
      args?: Subset<T, ChatbotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatbotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatbot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatbotAggregateArgs>(args: Subset<T, ChatbotAggregateArgs>): Prisma.PrismaPromise<GetChatbotAggregateType<T>>

    /**
     * Group by Chatbot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatbotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatbotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatbotGroupByArgs['orderBy'] }
        : { orderBy?: ChatbotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatbotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatbotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chatbot model
   */
  readonly fields: ChatbotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chatbot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatbotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Chatbot$userArgs<ExtArgs> = {}>(args?: Subset<T, Chatbot$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chatbot model
   */
  interface ChatbotFieldRefs {
    readonly id: FieldRef<"Chatbot", 'String'>
    readonly userId: FieldRef<"Chatbot", 'String'>
    readonly anonymousId: FieldRef<"Chatbot", 'String'>
    readonly conversationId: FieldRef<"Chatbot", 'String'>
    readonly message: FieldRef<"Chatbot", 'String'>
    readonly role: FieldRef<"Chatbot", 'String'>
    readonly llmMessageId: FieldRef<"Chatbot", 'String'>
    readonly createdAt: FieldRef<"Chatbot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chatbot findUnique
   */
  export type ChatbotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * Filter, which Chatbot to fetch.
     */
    where: ChatbotWhereUniqueInput
  }

  /**
   * Chatbot findUniqueOrThrow
   */
  export type ChatbotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * Filter, which Chatbot to fetch.
     */
    where: ChatbotWhereUniqueInput
  }

  /**
   * Chatbot findFirst
   */
  export type ChatbotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * Filter, which Chatbot to fetch.
     */
    where?: ChatbotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatbots to fetch.
     */
    orderBy?: ChatbotOrderByWithRelationInput | ChatbotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatbots.
     */
    cursor?: ChatbotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatbots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatbots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatbots.
     */
    distinct?: ChatbotScalarFieldEnum | ChatbotScalarFieldEnum[]
  }

  /**
   * Chatbot findFirstOrThrow
   */
  export type ChatbotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * Filter, which Chatbot to fetch.
     */
    where?: ChatbotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatbots to fetch.
     */
    orderBy?: ChatbotOrderByWithRelationInput | ChatbotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chatbots.
     */
    cursor?: ChatbotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatbots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatbots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chatbots.
     */
    distinct?: ChatbotScalarFieldEnum | ChatbotScalarFieldEnum[]
  }

  /**
   * Chatbot findMany
   */
  export type ChatbotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * Filter, which Chatbots to fetch.
     */
    where?: ChatbotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chatbots to fetch.
     */
    orderBy?: ChatbotOrderByWithRelationInput | ChatbotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chatbots.
     */
    cursor?: ChatbotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chatbots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chatbots.
     */
    skip?: number
    distinct?: ChatbotScalarFieldEnum | ChatbotScalarFieldEnum[]
  }

  /**
   * Chatbot create
   */
  export type ChatbotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * The data needed to create a Chatbot.
     */
    data: XOR<ChatbotCreateInput, ChatbotUncheckedCreateInput>
  }

  /**
   * Chatbot createMany
   */
  export type ChatbotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chatbots.
     */
    data: ChatbotCreateManyInput | ChatbotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chatbot createManyAndReturn
   */
  export type ChatbotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * The data used to create many Chatbots.
     */
    data: ChatbotCreateManyInput | ChatbotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chatbot update
   */
  export type ChatbotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * The data needed to update a Chatbot.
     */
    data: XOR<ChatbotUpdateInput, ChatbotUncheckedUpdateInput>
    /**
     * Choose, which Chatbot to update.
     */
    where: ChatbotWhereUniqueInput
  }

  /**
   * Chatbot updateMany
   */
  export type ChatbotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chatbots.
     */
    data: XOR<ChatbotUpdateManyMutationInput, ChatbotUncheckedUpdateManyInput>
    /**
     * Filter which Chatbots to update
     */
    where?: ChatbotWhereInput
    /**
     * Limit how many Chatbots to update.
     */
    limit?: number
  }

  /**
   * Chatbot updateManyAndReturn
   */
  export type ChatbotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * The data used to update Chatbots.
     */
    data: XOR<ChatbotUpdateManyMutationInput, ChatbotUncheckedUpdateManyInput>
    /**
     * Filter which Chatbots to update
     */
    where?: ChatbotWhereInput
    /**
     * Limit how many Chatbots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chatbot upsert
   */
  export type ChatbotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * The filter to search for the Chatbot to update in case it exists.
     */
    where: ChatbotWhereUniqueInput
    /**
     * In case the Chatbot found by the `where` argument doesn't exist, create a new Chatbot with this data.
     */
    create: XOR<ChatbotCreateInput, ChatbotUncheckedCreateInput>
    /**
     * In case the Chatbot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatbotUpdateInput, ChatbotUncheckedUpdateInput>
  }

  /**
   * Chatbot delete
   */
  export type ChatbotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
    /**
     * Filter which Chatbot to delete.
     */
    where: ChatbotWhereUniqueInput
  }

  /**
   * Chatbot deleteMany
   */
  export type ChatbotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chatbots to delete
     */
    where?: ChatbotWhereInput
    /**
     * Limit how many Chatbots to delete.
     */
    limit?: number
  }

  /**
   * Chatbot.user
   */
  export type Chatbot$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Chatbot without action
   */
  export type ChatbotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chatbot
     */
    select?: ChatbotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chatbot
     */
    omit?: ChatbotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatbotInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    messageCount: number | null
  }

  export type ConversationSumAggregateOutputType = {
    messageCount: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    lastMessageAt: Date | null
    messageCount: number | null
    selectedTemplate: string | null
    selectedModel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    lastMessageAt: Date | null
    messageCount: number | null
    selectedTemplate: string | null
    selectedModel: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    lastMessageAt: number
    messageCount: number
    selectedTemplate: number
    selectedModel: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    messageCount?: true
  }

  export type ConversationSumAggregateInputType = {
    messageCount?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    lastMessageAt?: true
    messageCount?: true
    selectedTemplate?: true
    selectedModel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    lastMessageAt?: true
    messageCount?: true
    selectedTemplate?: true
    selectedModel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    lastMessageAt?: true
    messageCount?: true
    selectedTemplate?: true
    selectedModel?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: string
    title: string
    lastMessageAt: Date
    messageCount: number
    selectedTemplate: string | null
    selectedModel: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    lastMessageAt?: boolean
    messageCount?: boolean
    selectedTemplate?: boolean
    selectedModel?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    lastMessageAt?: boolean
    messageCount?: boolean
    selectedTemplate?: boolean
    selectedModel?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    lastMessageAt?: boolean
    messageCount?: boolean
    selectedTemplate?: boolean
    selectedModel?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    lastMessageAt?: boolean
    messageCount?: boolean
    selectedTemplate?: boolean
    selectedModel?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "lastMessageAt" | "messageCount" | "selectedTemplate" | "selectedModel" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$ConversationMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      lastMessageAt: Date
      messageCount: number
      selectedTemplate: string | null
      selectedModel: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly messageCount: FieldRef<"Conversation", 'Int'>
    readonly selectedTemplate: FieldRef<"Conversation", 'String'>
    readonly selectedModel: FieldRef<"Conversation", 'String'>
    readonly metadata: FieldRef<"Conversation", 'Json'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    cursor?: ConversationMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationMessage
   */

  export type AggregateConversationMessage = {
    _count: ConversationMessageCountAggregateOutputType | null
    _avg: ConversationMessageAvgAggregateOutputType | null
    _sum: ConversationMessageSumAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  export type ConversationMessageAvgAggregateOutputType = {
    messageIndex: number | null
    tokensUsed: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
  }

  export type ConversationMessageSumAggregateOutputType = {
    messageIndex: number | null
    tokensUsed: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
  }

  export type ConversationMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    messageIndex: number | null
    model: string | null
    template: string | null
    tokensUsed: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    hasLatexCode: boolean | null
    createdAt: Date | null
  }

  export type ConversationMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: $Enums.MessageRole | null
    content: string | null
    messageIndex: number | null
    model: string | null
    template: string | null
    tokensUsed: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    hasLatexCode: boolean | null
    createdAt: Date | null
  }

  export type ConversationMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    messageIndex: number
    model: number
    template: number
    tokensUsed: number
    costUsd: number
    processingTimeMs: number
    hasLatexCode: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ConversationMessageAvgAggregateInputType = {
    messageIndex?: true
    tokensUsed?: true
    costUsd?: true
    processingTimeMs?: true
  }

  export type ConversationMessageSumAggregateInputType = {
    messageIndex?: true
    tokensUsed?: true
    costUsd?: true
    processingTimeMs?: true
  }

  export type ConversationMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    messageIndex?: true
    model?: true
    template?: true
    tokensUsed?: true
    costUsd?: true
    processingTimeMs?: true
    hasLatexCode?: true
    createdAt?: true
  }

  export type ConversationMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    messageIndex?: true
    model?: true
    template?: true
    tokensUsed?: true
    costUsd?: true
    processingTimeMs?: true
    hasLatexCode?: true
    createdAt?: true
  }

  export type ConversationMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    messageIndex?: true
    model?: true
    template?: true
    tokensUsed?: true
    costUsd?: true
    processingTimeMs?: true
    hasLatexCode?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMessage to aggregate.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationMessages
    **/
    _count?: true | ConversationMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type GetConversationMessageAggregateType<T extends ConversationMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationMessage[P]>
      : GetScalarType<T[P], AggregateConversationMessage[P]>
  }




  export type ConversationMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationMessageWhereInput
    orderBy?: ConversationMessageOrderByWithAggregationInput | ConversationMessageOrderByWithAggregationInput[]
    by: ConversationMessageScalarFieldEnum[] | ConversationMessageScalarFieldEnum
    having?: ConversationMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationMessageCountAggregateInputType | true
    _avg?: ConversationMessageAvgAggregateInputType
    _sum?: ConversationMessageSumAggregateInputType
    _min?: ConversationMessageMinAggregateInputType
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type ConversationMessageGroupByOutputType = {
    id: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model: string | null
    template: string | null
    tokensUsed: number | null
    costUsd: Decimal | null
    processingTimeMs: number | null
    hasLatexCode: boolean
    metadata: JsonValue | null
    createdAt: Date
    _count: ConversationMessageCountAggregateOutputType | null
    _avg: ConversationMessageAvgAggregateOutputType | null
    _sum: ConversationMessageSumAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  type GetConversationMessageGroupByPayload<T extends ConversationMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
        }
      >
    >


  export type ConversationMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    model?: boolean
    template?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    hasLatexCode?: boolean
    metadata?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    model?: boolean
    template?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    hasLatexCode?: boolean
    metadata?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    model?: boolean
    template?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    hasLatexCode?: boolean
    metadata?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationMessage"]>

  export type ConversationMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    messageIndex?: boolean
    model?: boolean
    template?: boolean
    tokensUsed?: boolean
    costUsd?: boolean
    processingTimeMs?: boolean
    hasLatexCode?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ConversationMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "role" | "content" | "messageIndex" | "model" | "template" | "tokensUsed" | "costUsd" | "processingTimeMs" | "hasLatexCode" | "metadata" | "createdAt", ExtArgs["result"]["conversationMessage"]>
  export type ConversationMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type ConversationMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $ConversationMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationMessage"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: $Enums.MessageRole
      content: string
      messageIndex: number
      model: string | null
      template: string | null
      tokensUsed: number | null
      costUsd: Prisma.Decimal | null
      processingTimeMs: number | null
      hasLatexCode: boolean
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["conversationMessage"]>
    composites: {}
  }

  type ConversationMessageGetPayload<S extends boolean | null | undefined | ConversationMessageDefaultArgs> = $Result.GetResult<Prisma.$ConversationMessagePayload, S>

  type ConversationMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationMessageCountAggregateInputType | true
    }

  export interface ConversationMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationMessage'], meta: { name: 'ConversationMessage' } }
    /**
     * Find zero or one ConversationMessage that matches the filter.
     * @param {ConversationMessageFindUniqueArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationMessageFindUniqueArgs>(args: SelectSubset<T, ConversationMessageFindUniqueArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationMessageFindUniqueOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationMessageFindFirstArgs>(args?: SelectSubset<T, ConversationMessageFindFirstArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany()
     * 
     * // Get first 10 ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationMessageFindManyArgs>(args?: SelectSubset<T, ConversationMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationMessage.
     * @param {ConversationMessageCreateArgs} args - Arguments to create a ConversationMessage.
     * @example
     * // Create one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.create({
     *   data: {
     *     // ... data to create a ConversationMessage
     *   }
     * })
     * 
     */
    create<T extends ConversationMessageCreateArgs>(args: SelectSubset<T, ConversationMessageCreateArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationMessages.
     * @param {ConversationMessageCreateManyArgs} args - Arguments to create many ConversationMessages.
     * @example
     * // Create many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationMessageCreateManyArgs>(args?: SelectSubset<T, ConversationMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationMessages and returns the data saved in the database.
     * @param {ConversationMessageCreateManyAndReturnArgs} args - Arguments to create many ConversationMessages.
     * @example
     * // Create many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationMessages and only return the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationMessage.
     * @param {ConversationMessageDeleteArgs} args - Arguments to delete one ConversationMessage.
     * @example
     * // Delete one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.delete({
     *   where: {
     *     // ... filter to delete one ConversationMessage
     *   }
     * })
     * 
     */
    delete<T extends ConversationMessageDeleteArgs>(args: SelectSubset<T, ConversationMessageDeleteArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationMessage.
     * @param {ConversationMessageUpdateArgs} args - Arguments to update one ConversationMessage.
     * @example
     * // Update one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationMessageUpdateArgs>(args: SelectSubset<T, ConversationMessageUpdateArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationMessages.
     * @param {ConversationMessageDeleteManyArgs} args - Arguments to filter ConversationMessages to delete.
     * @example
     * // Delete a few ConversationMessages
     * const { count } = await prisma.conversationMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationMessageDeleteManyArgs>(args?: SelectSubset<T, ConversationMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationMessageUpdateManyArgs>(args: SelectSubset<T, ConversationMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages and returns the data updated in the database.
     * @param {ConversationMessageUpdateManyAndReturnArgs} args - Arguments to update many ConversationMessages.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationMessages and only return the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationMessage.
     * @param {ConversationMessageUpsertArgs} args - Arguments to update or create a ConversationMessage.
     * @example
     * // Update or create a ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.upsert({
     *   create: {
     *     // ... data to create a ConversationMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationMessage we want to update
     *   }
     * })
     */
    upsert<T extends ConversationMessageUpsertArgs>(args: SelectSubset<T, ConversationMessageUpsertArgs<ExtArgs>>): Prisma__ConversationMessageClient<$Result.GetResult<Prisma.$ConversationMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageCountArgs} args - Arguments to filter ConversationMessages to count.
     * @example
     * // Count the number of ConversationMessages
     * const count = await prisma.conversationMessage.count({
     *   where: {
     *     // ... the filter for the ConversationMessages we want to count
     *   }
     * })
    **/
    count<T extends ConversationMessageCountArgs>(
      args?: Subset<T, ConversationMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationMessageAggregateArgs>(args: Subset<T, ConversationMessageAggregateArgs>): Prisma.PrismaPromise<GetConversationMessageAggregateType<T>>

    /**
     * Group by ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationMessageGroupByArgs['orderBy'] }
        : { orderBy?: ConversationMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationMessage model
   */
  readonly fields: ConversationMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationMessage model
   */
  interface ConversationMessageFieldRefs {
    readonly id: FieldRef<"ConversationMessage", 'String'>
    readonly conversationId: FieldRef<"ConversationMessage", 'String'>
    readonly role: FieldRef<"ConversationMessage", 'MessageRole'>
    readonly content: FieldRef<"ConversationMessage", 'String'>
    readonly messageIndex: FieldRef<"ConversationMessage", 'Int'>
    readonly model: FieldRef<"ConversationMessage", 'String'>
    readonly template: FieldRef<"ConversationMessage", 'String'>
    readonly tokensUsed: FieldRef<"ConversationMessage", 'Int'>
    readonly costUsd: FieldRef<"ConversationMessage", 'Decimal'>
    readonly processingTimeMs: FieldRef<"ConversationMessage", 'Int'>
    readonly hasLatexCode: FieldRef<"ConversationMessage", 'Boolean'>
    readonly metadata: FieldRef<"ConversationMessage", 'Json'>
    readonly createdAt: FieldRef<"ConversationMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationMessage findUnique
   */
  export type ConversationMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage findUniqueOrThrow
   */
  export type ConversationMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage findFirst
   */
  export type ConversationMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     */
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage findFirstOrThrow
   */
  export type ConversationMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessage to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     */
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage findMany
   */
  export type ConversationMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter, which ConversationMessages to fetch.
     */
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     */
    orderBy?: ConversationMessageOrderByWithRelationInput | ConversationMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationMessages.
     */
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     */
    skip?: number
    distinct?: ConversationMessageScalarFieldEnum | ConversationMessageScalarFieldEnum[]
  }

  /**
   * ConversationMessage create
   */
  export type ConversationMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationMessage.
     */
    data: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
  }

  /**
   * ConversationMessage createMany
   */
  export type ConversationMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationMessages.
     */
    data: ConversationMessageCreateManyInput | ConversationMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationMessage createManyAndReturn
   */
  export type ConversationMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationMessages.
     */
    data: ConversationMessageCreateManyInput | ConversationMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMessage update
   */
  export type ConversationMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationMessage.
     */
    data: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
    /**
     * Choose, which ConversationMessage to update.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage updateMany
   */
  export type ConversationMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationMessages.
     */
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to update.
     */
    limit?: number
  }

  /**
   * ConversationMessage updateManyAndReturn
   */
  export type ConversationMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * The data used to update ConversationMessages.
     */
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationMessage upsert
   */
  export type ConversationMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationMessage to update in case it exists.
     */
    where: ConversationMessageWhereUniqueInput
    /**
     * In case the ConversationMessage found by the `where` argument doesn't exist, create a new ConversationMessage with this data.
     */
    create: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
    /**
     * In case the ConversationMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
  }

  /**
   * ConversationMessage delete
   */
  export type ConversationMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
    /**
     * Filter which ConversationMessage to delete.
     */
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage deleteMany
   */
  export type ConversationMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationMessages to delete
     */
    where?: ConversationMessageWhereInput
    /**
     * Limit how many ConversationMessages to delete.
     */
    limit?: number
  }

  /**
   * ConversationMessage without action
   */
  export type ConversationMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     */
    select?: ConversationMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationMessage
     */
    omit?: ConversationMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationMessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    emailVerified: 'emailVerified',
    image: 'image',
    hashedPassword: 'hashedPassword',
    subscriptionTier: 'subscriptionTier',
    subscriptionId: 'subscriptionId',
    customerId: 'customerId',
    subscriptionEndsAt: 'subscriptionEndsAt',
    monthlyRoasts: 'monthlyRoasts',
    totalRoasts: 'totalRoasts',
    bonusCredits: 'bonusCredits',
    lastRoastReset: 'lastRoastReset',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    type: 'type',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    usedAt: 'usedAt'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const LlmCallScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    model: 'model',
    operationType: 'operationType',
    totalInputTokens: 'totalInputTokens',
    totalOutputTokens: 'totalOutputTokens',
    totalTokens: 'totalTokens',
    totalCostUsd: 'totalCostUsd',
    totalProcessingTimeMs: 'totalProcessingTimeMs',
    status: 'status',
    errorMessage: 'errorMessage',
    resumeId: 'resumeId',
    extractedResumeId: 'extractedResumeId',
    extractedJobId: 'extractedJobId',
    generatedRoastId: 'generatedRoastId',
    generatedCoverLetterId: 'generatedCoverLetterId',
    generatedResumeId: 'generatedResumeId',
    generatedInterviewPrepId: 'generatedInterviewPrepId',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type LlmCallScalarFieldEnum = (typeof LlmCallScalarFieldEnum)[keyof typeof LlmCallScalarFieldEnum]


  export const LlmMessageScalarFieldEnum: {
    id: 'id',
    llmCallId: 'llmCallId',
    role: 'role',
    content: 'content',
    messageIndex: 'messageIndex',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    totalTokens: 'totalTokens',
    costUsd: 'costUsd',
    processingTimeMs: 'processingTimeMs',
    finishReason: 'finishReason',
    temperature: 'temperature',
    maxTokens: 'maxTokens',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type LlmMessageScalarFieldEnum = (typeof LlmMessageScalarFieldEnum)[keyof typeof LlmMessageScalarFieldEnum]


  export const ResumeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    filename: 'filename',
    fileHash: 'fileHash',
    mimeType: 'mimeType',
    images: 'images',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ResumeScalarFieldEnum = (typeof ResumeScalarFieldEnum)[keyof typeof ResumeScalarFieldEnum]


  export const ExtractedResumeScalarFieldEnum: {
    id: 'id',
    resumeId: 'resumeId',
    contentHash: 'contentHash',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type ExtractedResumeScalarFieldEnum = (typeof ExtractedResumeScalarFieldEnum)[keyof typeof ExtractedResumeScalarFieldEnum]


  export const ExtractedJobDescriptionScalarFieldEnum: {
    id: 'id',
    contentHash: 'contentHash',
    originalText: 'originalText',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type ExtractedJobDescriptionScalarFieldEnum = (typeof ExtractedJobDescriptionScalarFieldEnum)[keyof typeof ExtractedJobDescriptionScalarFieldEnum]


  export const SummarizedResumeScalarFieldEnum: {
    id: 'id',
    extractedResumeId: 'extractedResumeId',
    contentHash: 'contentHash',
    summary: 'summary',
    createdAt: 'createdAt'
  };

  export type SummarizedResumeScalarFieldEnum = (typeof SummarizedResumeScalarFieldEnum)[keyof typeof SummarizedResumeScalarFieldEnum]


  export const SummarizedJobDescriptionScalarFieldEnum: {
    id: 'id',
    extractedJobId: 'extractedJobId',
    contentHash: 'contentHash',
    summary: 'summary',
    createdAt: 'createdAt'
  };

  export type SummarizedJobDescriptionScalarFieldEnum = (typeof SummarizedJobDescriptionScalarFieldEnum)[keyof typeof SummarizedJobDescriptionScalarFieldEnum]


  export const GeneratedRoastScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    extractedResumeId: 'extractedResumeId',
    extractedJobId: 'extractedJobId',
    contentHash: 'contentHash',
    data: 'data',
    overallScore: 'overallScore',
    createdAt: 'createdAt'
  };

  export type GeneratedRoastScalarFieldEnum = (typeof GeneratedRoastScalarFieldEnum)[keyof typeof GeneratedRoastScalarFieldEnum]


  export const GeneratedCoverLetterScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    resumeId: 'resumeId',
    roastId: 'roastId',
    extractedResumeId: 'extractedResumeId',
    extractedJobId: 'extractedJobId',
    contentHash: 'contentHash',
    content: 'content',
    tone: 'tone',
    modelName: 'modelName',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type GeneratedCoverLetterScalarFieldEnum = (typeof GeneratedCoverLetterScalarFieldEnum)[keyof typeof GeneratedCoverLetterScalarFieldEnum]


  export const GeneratedResumeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roastId: 'roastId',
    extractedResumeId: 'extractedResumeId',
    extractedJobId: 'extractedJobId',
    templateId: 'templateId',
    contentHash: 'contentHash',
    content: 'content',
    data: 'data',
    atsScore: 'atsScore',
    keywordsMatched: 'keywordsMatched',
    createdAt: 'createdAt'
  };

  export type GeneratedResumeScalarFieldEnum = (typeof GeneratedResumeScalarFieldEnum)[keyof typeof GeneratedResumeScalarFieldEnum]


  export const GeneratedInterviewPrepScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roastId: 'roastId',
    extractedResumeId: 'extractedResumeId',
    extractedJobId: 'extractedJobId',
    contentHash: 'contentHash',
    data: 'data',
    difficulty: 'difficulty',
    category: 'category',
    modelName: 'modelName',
    createdAt: 'createdAt'
  };

  export type GeneratedInterviewPrepScalarFieldEnum = (typeof GeneratedInterviewPrepScalarFieldEnum)[keyof typeof GeneratedInterviewPrepScalarFieldEnum]


  export const InterviewEvaluationScalarFieldEnum: {
    id: 'id',
    interviewPrepId: 'interviewPrepId',
    userId: 'userId',
    evaluationType: 'evaluationType',
    data: 'data',
    questionsCount: 'questionsCount',
    overallScore: 'overallScore',
    createdAt: 'createdAt'
  };

  export type InterviewEvaluationScalarFieldEnum = (typeof InterviewEvaluationScalarFieldEnum)[keyof typeof InterviewEvaluationScalarFieldEnum]


  export const SharedAnalysisScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roastId: 'roastId',
    settings: 'settings',
    viewCount: 'viewCount',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SharedAnalysisScalarFieldEnum = (typeof SharedAnalysisScalarFieldEnum)[keyof typeof SharedAnalysisScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    billingPeriodStart: 'billingPeriodStart',
    billingPeriodEnd: 'billingPeriodEnd',
    stripeInvoiceId: 'stripeInvoiceId',
    stripePaymentId: 'stripePaymentId',
    itemCount: 'itemCount',
    generatedAt: 'generatedAt',
    paidAt: 'paidAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const AnnouncementScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    featureName: 'featureName',
    estimatedDate: 'estimatedDate',
    type: 'type',
    ctaText: 'ctaText',
    ctaUrl: 'ctaUrl',
    isActive: 'isActive',
    startDate: 'startDate',
    endDate: 'endDate',
    targetTiers: 'targetTiers',
    dismissedBy: 'dismissedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


  export const ChatbotScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    anonymousId: 'anonymousId',
    conversationId: 'conversationId',
    message: 'message',
    role: 'role',
    llmMessageId: 'llmMessageId',
    createdAt: 'createdAt'
  };

  export type ChatbotScalarFieldEnum = (typeof ChatbotScalarFieldEnum)[keyof typeof ChatbotScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    lastMessageAt: 'lastMessageAt',
    messageCount: 'messageCount',
    selectedTemplate: 'selectedTemplate',
    selectedModel: 'selectedModel',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    messageIndex: 'messageIndex',
    model: 'model',
    template: 'template',
    tokensUsed: 'tokensUsed',
    costUsd: 'costUsd',
    processingTimeMs: 'processingTimeMs',
    hasLatexCode: 'hasLatexCode',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ConversationMessageScalarFieldEnum = (typeof ConversationMessageScalarFieldEnum)[keyof typeof ConversationMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SubscriptionTier'
   */
  export type EnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier'>
    


  /**
   * Reference to a field of type 'SubscriptionTier[]'
   */
  export type ListEnumSubscriptionTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionTier[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VerificationTokenType'
   */
  export type EnumVerificationTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationTokenType'>
    


  /**
   * Reference to a field of type 'VerificationTokenType[]'
   */
  export type ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationTokenType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LlmCallStatus'
   */
  export type EnumLlmCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LlmCallStatus'>
    


  /**
   * Reference to a field of type 'LlmCallStatus[]'
   */
  export type ListEnumLlmCallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LlmCallStatus[]'>
    


  /**
   * Reference to a field of type 'MessageRole'
   */
  export type EnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole'>
    


  /**
   * Reference to a field of type 'MessageRole[]'
   */
  export type ListEnumMessageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'AnnouncementType'
   */
  export type EnumAnnouncementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementType'>
    


  /**
   * Reference to a field of type 'AnnouncementType[]'
   */
  export type ListEnumAnnouncementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnnouncementType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    subscriptionId?: StringNullableFilter<"User"> | string | null
    customerId?: StringNullableFilter<"User"> | string | null
    subscriptionEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    monthlyRoasts?: IntFilter<"User"> | number
    totalRoasts?: IntFilter<"User"> | number
    bonusCredits?: IntFilter<"User"> | number
    lastRoastReset?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    llmCalls?: LlmCallListRelationFilter
    resumes?: ResumeListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
    interviewEvaluations?: InterviewEvaluationListRelationFilter
    sharedAnalyses?: SharedAnalysisListRelationFilter
    invoices?: InvoiceListRelationFilter
    chatbot?: ChatbotListRelationFilter
    verificationTokens?: VerificationTokenListRelationFilter
    conversations?: ConversationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    subscriptionEndsAt?: SortOrderInput | SortOrder
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
    lastRoastReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
    resumes?: ResumeOrderByRelationAggregateInput
    generatedRoasts?: GeneratedRoastOrderByRelationAggregateInput
    generatedCoverLetters?: GeneratedCoverLetterOrderByRelationAggregateInput
    generatedResumes?: GeneratedResumeOrderByRelationAggregateInput
    generatedInterviewPreps?: GeneratedInterviewPrepOrderByRelationAggregateInput
    interviewEvaluations?: InterviewEvaluationOrderByRelationAggregateInput
    sharedAnalyses?: SharedAnalysisOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    chatbot?: ChatbotOrderByRelationAggregateInput
    verificationTokens?: VerificationTokenOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierFilter<"User"> | $Enums.SubscriptionTier
    subscriptionId?: StringNullableFilter<"User"> | string | null
    customerId?: StringNullableFilter<"User"> | string | null
    subscriptionEndsAt?: DateTimeNullableFilter<"User"> | Date | string | null
    monthlyRoasts?: IntFilter<"User"> | number
    totalRoasts?: IntFilter<"User"> | number
    bonusCredits?: IntFilter<"User"> | number
    lastRoastReset?: DateTimeFilter<"User"> | Date | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    llmCalls?: LlmCallListRelationFilter
    resumes?: ResumeListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
    interviewEvaluations?: InterviewEvaluationListRelationFilter
    sharedAnalyses?: SharedAnalysisListRelationFilter
    invoices?: InvoiceListRelationFilter
    chatbot?: ChatbotListRelationFilter
    verificationTokens?: VerificationTokenListRelationFilter
    conversations?: ConversationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    subscriptionEndsAt?: SortOrderInput | SortOrder
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
    lastRoastReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    hashedPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionTier?: EnumSubscriptionTierWithAggregatesFilter<"User"> | $Enums.SubscriptionTier
    subscriptionId?: StringNullableWithAggregatesFilter<"User"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    subscriptionEndsAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    monthlyRoasts?: IntWithAggregatesFilter<"User"> | number
    totalRoasts?: IntWithAggregatesFilter<"User"> | number
    bonusCredits?: IntWithAggregatesFilter<"User"> | number
    lastRoastReset?: DateTimeWithAggregatesFilter<"User"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    userId?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    type?: EnumVerificationTokenTypeFilter<"VerificationToken"> | $Enums.VerificationTokenType
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"VerificationToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    userId?: StringFilter<"VerificationToken"> | string
    type?: EnumVerificationTokenTypeFilter<"VerificationToken"> | $Enums.VerificationTokenType
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"VerificationToken"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    userId?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    type?: EnumVerificationTokenTypeWithAggregatesFilter<"VerificationToken"> | $Enums.VerificationTokenType
    expiresAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"VerificationToken"> | Date | string | null
  }

  export type LlmCallWhereInput = {
    AND?: LlmCallWhereInput | LlmCallWhereInput[]
    OR?: LlmCallWhereInput[]
    NOT?: LlmCallWhereInput | LlmCallWhereInput[]
    id?: StringFilter<"LlmCall"> | string
    userId?: StringNullableFilter<"LlmCall"> | string | null
    provider?: StringFilter<"LlmCall"> | string
    model?: StringFilter<"LlmCall"> | string
    operationType?: StringFilter<"LlmCall"> | string
    totalInputTokens?: IntFilter<"LlmCall"> | number
    totalOutputTokens?: IntFilter<"LlmCall"> | number
    totalTokens?: IntFilter<"LlmCall"> | number
    totalCostUsd?: DecimalFilter<"LlmCall"> | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: IntNullableFilter<"LlmCall"> | number | null
    status?: EnumLlmCallStatusFilter<"LlmCall"> | $Enums.LlmCallStatus
    errorMessage?: StringNullableFilter<"LlmCall"> | string | null
    resumeId?: StringNullableFilter<"LlmCall"> | string | null
    extractedResumeId?: StringNullableFilter<"LlmCall"> | string | null
    extractedJobId?: StringNullableFilter<"LlmCall"> | string | null
    generatedRoastId?: StringNullableFilter<"LlmCall"> | string | null
    generatedCoverLetterId?: StringNullableFilter<"LlmCall"> | string | null
    generatedResumeId?: StringNullableFilter<"LlmCall"> | string | null
    generatedInterviewPrepId?: StringNullableFilter<"LlmCall"> | string | null
    createdAt?: DateTimeFilter<"LlmCall"> | Date | string
    completedAt?: DateTimeNullableFilter<"LlmCall"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    resume?: XOR<ResumeNullableScalarRelationFilter, ResumeWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    generatedRoast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    generatedCoverLetter?: XOR<GeneratedCoverLetterNullableScalarRelationFilter, GeneratedCoverLetterWhereInput> | null
    generatedResume?: XOR<GeneratedResumeNullableScalarRelationFilter, GeneratedResumeWhereInput> | null
    generatedInterviewPrep?: XOR<GeneratedInterviewPrepNullableScalarRelationFilter, GeneratedInterviewPrepWhereInput> | null
    messages?: LlmMessageListRelationFilter
  }

  export type LlmCallOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    resumeId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    generatedRoastId?: SortOrderInput | SortOrder
    generatedCoverLetterId?: SortOrderInput | SortOrder
    generatedResumeId?: SortOrderInput | SortOrder
    generatedInterviewPrepId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
    extractedResume?: ExtractedResumeOrderByWithRelationInput
    extractedJob?: ExtractedJobDescriptionOrderByWithRelationInput
    generatedRoast?: GeneratedRoastOrderByWithRelationInput
    generatedCoverLetter?: GeneratedCoverLetterOrderByWithRelationInput
    generatedResume?: GeneratedResumeOrderByWithRelationInput
    generatedInterviewPrep?: GeneratedInterviewPrepOrderByWithRelationInput
    messages?: LlmMessageOrderByRelationAggregateInput
  }

  export type LlmCallWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LlmCallWhereInput | LlmCallWhereInput[]
    OR?: LlmCallWhereInput[]
    NOT?: LlmCallWhereInput | LlmCallWhereInput[]
    userId?: StringNullableFilter<"LlmCall"> | string | null
    provider?: StringFilter<"LlmCall"> | string
    model?: StringFilter<"LlmCall"> | string
    operationType?: StringFilter<"LlmCall"> | string
    totalInputTokens?: IntFilter<"LlmCall"> | number
    totalOutputTokens?: IntFilter<"LlmCall"> | number
    totalTokens?: IntFilter<"LlmCall"> | number
    totalCostUsd?: DecimalFilter<"LlmCall"> | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: IntNullableFilter<"LlmCall"> | number | null
    status?: EnumLlmCallStatusFilter<"LlmCall"> | $Enums.LlmCallStatus
    errorMessage?: StringNullableFilter<"LlmCall"> | string | null
    resumeId?: StringNullableFilter<"LlmCall"> | string | null
    extractedResumeId?: StringNullableFilter<"LlmCall"> | string | null
    extractedJobId?: StringNullableFilter<"LlmCall"> | string | null
    generatedRoastId?: StringNullableFilter<"LlmCall"> | string | null
    generatedCoverLetterId?: StringNullableFilter<"LlmCall"> | string | null
    generatedResumeId?: StringNullableFilter<"LlmCall"> | string | null
    generatedInterviewPrepId?: StringNullableFilter<"LlmCall"> | string | null
    createdAt?: DateTimeFilter<"LlmCall"> | Date | string
    completedAt?: DateTimeNullableFilter<"LlmCall"> | Date | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    resume?: XOR<ResumeNullableScalarRelationFilter, ResumeWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    generatedRoast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    generatedCoverLetter?: XOR<GeneratedCoverLetterNullableScalarRelationFilter, GeneratedCoverLetterWhereInput> | null
    generatedResume?: XOR<GeneratedResumeNullableScalarRelationFilter, GeneratedResumeWhereInput> | null
    generatedInterviewPrep?: XOR<GeneratedInterviewPrepNullableScalarRelationFilter, GeneratedInterviewPrepWhereInput> | null
    messages?: LlmMessageListRelationFilter
  }, "id">

  export type LlmCallOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrderInput | SortOrder
    status?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    resumeId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    generatedRoastId?: SortOrderInput | SortOrder
    generatedCoverLetterId?: SortOrderInput | SortOrder
    generatedResumeId?: SortOrderInput | SortOrder
    generatedInterviewPrepId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: LlmCallCountOrderByAggregateInput
    _avg?: LlmCallAvgOrderByAggregateInput
    _max?: LlmCallMaxOrderByAggregateInput
    _min?: LlmCallMinOrderByAggregateInput
    _sum?: LlmCallSumOrderByAggregateInput
  }

  export type LlmCallScalarWhereWithAggregatesInput = {
    AND?: LlmCallScalarWhereWithAggregatesInput | LlmCallScalarWhereWithAggregatesInput[]
    OR?: LlmCallScalarWhereWithAggregatesInput[]
    NOT?: LlmCallScalarWhereWithAggregatesInput | LlmCallScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LlmCall"> | string
    userId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    provider?: StringWithAggregatesFilter<"LlmCall"> | string
    model?: StringWithAggregatesFilter<"LlmCall"> | string
    operationType?: StringWithAggregatesFilter<"LlmCall"> | string
    totalInputTokens?: IntWithAggregatesFilter<"LlmCall"> | number
    totalOutputTokens?: IntWithAggregatesFilter<"LlmCall"> | number
    totalTokens?: IntWithAggregatesFilter<"LlmCall"> | number
    totalCostUsd?: DecimalWithAggregatesFilter<"LlmCall"> | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: IntNullableWithAggregatesFilter<"LlmCall"> | number | null
    status?: EnumLlmCallStatusWithAggregatesFilter<"LlmCall"> | $Enums.LlmCallStatus
    errorMessage?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    resumeId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    extractedResumeId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    extractedJobId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    generatedRoastId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    generatedCoverLetterId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    generatedResumeId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    generatedInterviewPrepId?: StringNullableWithAggregatesFilter<"LlmCall"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LlmCall"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"LlmCall"> | Date | string | null
  }

  export type LlmMessageWhereInput = {
    AND?: LlmMessageWhereInput | LlmMessageWhereInput[]
    OR?: LlmMessageWhereInput[]
    NOT?: LlmMessageWhereInput | LlmMessageWhereInput[]
    id?: StringFilter<"LlmMessage"> | string
    llmCallId?: StringFilter<"LlmMessage"> | string
    role?: EnumMessageRoleFilter<"LlmMessage"> | $Enums.MessageRole
    content?: StringFilter<"LlmMessage"> | string
    messageIndex?: IntFilter<"LlmMessage"> | number
    inputTokens?: IntNullableFilter<"LlmMessage"> | number | null
    outputTokens?: IntNullableFilter<"LlmMessage"> | number | null
    totalTokens?: IntNullableFilter<"LlmMessage"> | number | null
    costUsd?: DecimalFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string
    processingTimeMs?: IntNullableFilter<"LlmMessage"> | number | null
    finishReason?: StringNullableFilter<"LlmMessage"> | string | null
    temperature?: DecimalNullableFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string | null
    maxTokens?: IntNullableFilter<"LlmMessage"> | number | null
    metadata?: JsonNullableFilter<"LlmMessage">
    createdAt?: DateTimeFilter<"LlmMessage"> | Date | string
    llmCall?: XOR<LlmCallScalarRelationFilter, LlmCallWhereInput>
  }

  export type LlmMessageOrderByWithRelationInput = {
    id?: SortOrder
    llmCallId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    inputTokens?: SortOrderInput | SortOrder
    outputTokens?: SortOrderInput | SortOrder
    totalTokens?: SortOrderInput | SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrderInput | SortOrder
    finishReason?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    maxTokens?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    llmCall?: LlmCallOrderByWithRelationInput
  }

  export type LlmMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    llmCallId_messageIndex?: LlmMessageLlmCallIdMessageIndexCompoundUniqueInput
    AND?: LlmMessageWhereInput | LlmMessageWhereInput[]
    OR?: LlmMessageWhereInput[]
    NOT?: LlmMessageWhereInput | LlmMessageWhereInput[]
    llmCallId?: StringFilter<"LlmMessage"> | string
    role?: EnumMessageRoleFilter<"LlmMessage"> | $Enums.MessageRole
    content?: StringFilter<"LlmMessage"> | string
    messageIndex?: IntFilter<"LlmMessage"> | number
    inputTokens?: IntNullableFilter<"LlmMessage"> | number | null
    outputTokens?: IntNullableFilter<"LlmMessage"> | number | null
    totalTokens?: IntNullableFilter<"LlmMessage"> | number | null
    costUsd?: DecimalFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string
    processingTimeMs?: IntNullableFilter<"LlmMessage"> | number | null
    finishReason?: StringNullableFilter<"LlmMessage"> | string | null
    temperature?: DecimalNullableFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string | null
    maxTokens?: IntNullableFilter<"LlmMessage"> | number | null
    metadata?: JsonNullableFilter<"LlmMessage">
    createdAt?: DateTimeFilter<"LlmMessage"> | Date | string
    llmCall?: XOR<LlmCallScalarRelationFilter, LlmCallWhereInput>
  }, "id" | "llmCallId_messageIndex">

  export type LlmMessageOrderByWithAggregationInput = {
    id?: SortOrder
    llmCallId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    inputTokens?: SortOrderInput | SortOrder
    outputTokens?: SortOrderInput | SortOrder
    totalTokens?: SortOrderInput | SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrderInput | SortOrder
    finishReason?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    maxTokens?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LlmMessageCountOrderByAggregateInput
    _avg?: LlmMessageAvgOrderByAggregateInput
    _max?: LlmMessageMaxOrderByAggregateInput
    _min?: LlmMessageMinOrderByAggregateInput
    _sum?: LlmMessageSumOrderByAggregateInput
  }

  export type LlmMessageScalarWhereWithAggregatesInput = {
    AND?: LlmMessageScalarWhereWithAggregatesInput | LlmMessageScalarWhereWithAggregatesInput[]
    OR?: LlmMessageScalarWhereWithAggregatesInput[]
    NOT?: LlmMessageScalarWhereWithAggregatesInput | LlmMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LlmMessage"> | string
    llmCallId?: StringWithAggregatesFilter<"LlmMessage"> | string
    role?: EnumMessageRoleWithAggregatesFilter<"LlmMessage"> | $Enums.MessageRole
    content?: StringWithAggregatesFilter<"LlmMessage"> | string
    messageIndex?: IntWithAggregatesFilter<"LlmMessage"> | number
    inputTokens?: IntNullableWithAggregatesFilter<"LlmMessage"> | number | null
    outputTokens?: IntNullableWithAggregatesFilter<"LlmMessage"> | number | null
    totalTokens?: IntNullableWithAggregatesFilter<"LlmMessage"> | number | null
    costUsd?: DecimalWithAggregatesFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string
    processingTimeMs?: IntNullableWithAggregatesFilter<"LlmMessage"> | number | null
    finishReason?: StringNullableWithAggregatesFilter<"LlmMessage"> | string | null
    temperature?: DecimalNullableWithAggregatesFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string | null
    maxTokens?: IntNullableWithAggregatesFilter<"LlmMessage"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"LlmMessage">
    createdAt?: DateTimeWithAggregatesFilter<"LlmMessage"> | Date | string
  }

  export type ResumeWhereInput = {
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    id?: StringFilter<"Resume"> | string
    userId?: StringNullableFilter<"Resume"> | string | null
    filename?: StringFilter<"Resume"> | string
    fileHash?: StringFilter<"Resume"> | string
    mimeType?: StringFilter<"Resume"> | string
    images?: StringNullableListFilter<"Resume">
    metadata?: JsonNullableFilter<"Resume">
    createdAt?: DateTimeFilter<"Resume"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
    extractedResumes?: ExtractedResumeListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
  }

  export type ResumeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    filename?: SortOrder
    fileHash?: SortOrder
    mimeType?: SortOrder
    images?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
    extractedResumes?: ExtractedResumeOrderByRelationAggregateInput
    generatedRoasts?: GeneratedRoastOrderByRelationAggregateInput
    generatedCoverLetters?: GeneratedCoverLetterOrderByRelationAggregateInput
  }

  export type ResumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileHash?: string
    AND?: ResumeWhereInput | ResumeWhereInput[]
    OR?: ResumeWhereInput[]
    NOT?: ResumeWhereInput | ResumeWhereInput[]
    userId?: StringNullableFilter<"Resume"> | string | null
    filename?: StringFilter<"Resume"> | string
    mimeType?: StringFilter<"Resume"> | string
    images?: StringNullableListFilter<"Resume">
    metadata?: JsonNullableFilter<"Resume">
    createdAt?: DateTimeFilter<"Resume"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
    extractedResumes?: ExtractedResumeListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
  }, "id" | "fileHash">

  export type ResumeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    filename?: SortOrder
    fileHash?: SortOrder
    mimeType?: SortOrder
    images?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ResumeCountOrderByAggregateInput
    _max?: ResumeMaxOrderByAggregateInput
    _min?: ResumeMinOrderByAggregateInput
  }

  export type ResumeScalarWhereWithAggregatesInput = {
    AND?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    OR?: ResumeScalarWhereWithAggregatesInput[]
    NOT?: ResumeScalarWhereWithAggregatesInput | ResumeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Resume"> | string
    userId?: StringNullableWithAggregatesFilter<"Resume"> | string | null
    filename?: StringWithAggregatesFilter<"Resume"> | string
    fileHash?: StringWithAggregatesFilter<"Resume"> | string
    mimeType?: StringWithAggregatesFilter<"Resume"> | string
    images?: StringNullableListFilter<"Resume">
    metadata?: JsonNullableWithAggregatesFilter<"Resume">
    createdAt?: DateTimeWithAggregatesFilter<"Resume"> | Date | string
  }

  export type ExtractedResumeWhereInput = {
    AND?: ExtractedResumeWhereInput | ExtractedResumeWhereInput[]
    OR?: ExtractedResumeWhereInput[]
    NOT?: ExtractedResumeWhereInput | ExtractedResumeWhereInput[]
    id?: StringFilter<"ExtractedResume"> | string
    resumeId?: StringFilter<"ExtractedResume"> | string
    contentHash?: StringFilter<"ExtractedResume"> | string
    data?: JsonFilter<"ExtractedResume">
    createdAt?: DateTimeFilter<"ExtractedResume"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
    llmCalls?: LlmCallListRelationFilter
    summarizedResumes?: SummarizedResumeListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
  }

  export type ExtractedResumeOrderByWithRelationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    resume?: ResumeOrderByWithRelationInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
    summarizedResumes?: SummarizedResumeOrderByRelationAggregateInput
    generatedRoasts?: GeneratedRoastOrderByRelationAggregateInput
    generatedCoverLetters?: GeneratedCoverLetterOrderByRelationAggregateInput
    generatedResumes?: GeneratedResumeOrderByRelationAggregateInput
    generatedInterviewPreps?: GeneratedInterviewPrepOrderByRelationAggregateInput
  }

  export type ExtractedResumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: ExtractedResumeWhereInput | ExtractedResumeWhereInput[]
    OR?: ExtractedResumeWhereInput[]
    NOT?: ExtractedResumeWhereInput | ExtractedResumeWhereInput[]
    resumeId?: StringFilter<"ExtractedResume"> | string
    data?: JsonFilter<"ExtractedResume">
    createdAt?: DateTimeFilter<"ExtractedResume"> | Date | string
    resume?: XOR<ResumeScalarRelationFilter, ResumeWhereInput>
    llmCalls?: LlmCallListRelationFilter
    summarizedResumes?: SummarizedResumeListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
  }, "id" | "contentHash">

  export type ExtractedResumeOrderByWithAggregationInput = {
    id?: SortOrder
    resumeId?: SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: ExtractedResumeCountOrderByAggregateInput
    _max?: ExtractedResumeMaxOrderByAggregateInput
    _min?: ExtractedResumeMinOrderByAggregateInput
  }

  export type ExtractedResumeScalarWhereWithAggregatesInput = {
    AND?: ExtractedResumeScalarWhereWithAggregatesInput | ExtractedResumeScalarWhereWithAggregatesInput[]
    OR?: ExtractedResumeScalarWhereWithAggregatesInput[]
    NOT?: ExtractedResumeScalarWhereWithAggregatesInput | ExtractedResumeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExtractedResume"> | string
    resumeId?: StringWithAggregatesFilter<"ExtractedResume"> | string
    contentHash?: StringWithAggregatesFilter<"ExtractedResume"> | string
    data?: JsonWithAggregatesFilter<"ExtractedResume">
    createdAt?: DateTimeWithAggregatesFilter<"ExtractedResume"> | Date | string
  }

  export type ExtractedJobDescriptionWhereInput = {
    AND?: ExtractedJobDescriptionWhereInput | ExtractedJobDescriptionWhereInput[]
    OR?: ExtractedJobDescriptionWhereInput[]
    NOT?: ExtractedJobDescriptionWhereInput | ExtractedJobDescriptionWhereInput[]
    id?: StringFilter<"ExtractedJobDescription"> | string
    contentHash?: StringFilter<"ExtractedJobDescription"> | string
    originalText?: StringFilter<"ExtractedJobDescription"> | string
    data?: JsonFilter<"ExtractedJobDescription">
    createdAt?: DateTimeFilter<"ExtractedJobDescription"> | Date | string
    llmCalls?: LlmCallListRelationFilter
    summarizedJobDescriptions?: SummarizedJobDescriptionListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
  }

  export type ExtractedJobDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    contentHash?: SortOrder
    originalText?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    llmCalls?: LlmCallOrderByRelationAggregateInput
    summarizedJobDescriptions?: SummarizedJobDescriptionOrderByRelationAggregateInput
    generatedRoasts?: GeneratedRoastOrderByRelationAggregateInput
    generatedCoverLetters?: GeneratedCoverLetterOrderByRelationAggregateInput
    generatedResumes?: GeneratedResumeOrderByRelationAggregateInput
    generatedInterviewPreps?: GeneratedInterviewPrepOrderByRelationAggregateInput
  }

  export type ExtractedJobDescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: ExtractedJobDescriptionWhereInput | ExtractedJobDescriptionWhereInput[]
    OR?: ExtractedJobDescriptionWhereInput[]
    NOT?: ExtractedJobDescriptionWhereInput | ExtractedJobDescriptionWhereInput[]
    originalText?: StringFilter<"ExtractedJobDescription"> | string
    data?: JsonFilter<"ExtractedJobDescription">
    createdAt?: DateTimeFilter<"ExtractedJobDescription"> | Date | string
    llmCalls?: LlmCallListRelationFilter
    summarizedJobDescriptions?: SummarizedJobDescriptionListRelationFilter
    generatedRoasts?: GeneratedRoastListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
  }, "id" | "contentHash">

  export type ExtractedJobDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    contentHash?: SortOrder
    originalText?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: ExtractedJobDescriptionCountOrderByAggregateInput
    _max?: ExtractedJobDescriptionMaxOrderByAggregateInput
    _min?: ExtractedJobDescriptionMinOrderByAggregateInput
  }

  export type ExtractedJobDescriptionScalarWhereWithAggregatesInput = {
    AND?: ExtractedJobDescriptionScalarWhereWithAggregatesInput | ExtractedJobDescriptionScalarWhereWithAggregatesInput[]
    OR?: ExtractedJobDescriptionScalarWhereWithAggregatesInput[]
    NOT?: ExtractedJobDescriptionScalarWhereWithAggregatesInput | ExtractedJobDescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExtractedJobDescription"> | string
    contentHash?: StringWithAggregatesFilter<"ExtractedJobDescription"> | string
    originalText?: StringWithAggregatesFilter<"ExtractedJobDescription"> | string
    data?: JsonWithAggregatesFilter<"ExtractedJobDescription">
    createdAt?: DateTimeWithAggregatesFilter<"ExtractedJobDescription"> | Date | string
  }

  export type SummarizedResumeWhereInput = {
    AND?: SummarizedResumeWhereInput | SummarizedResumeWhereInput[]
    OR?: SummarizedResumeWhereInput[]
    NOT?: SummarizedResumeWhereInput | SummarizedResumeWhereInput[]
    id?: StringFilter<"SummarizedResume"> | string
    extractedResumeId?: StringFilter<"SummarizedResume"> | string
    contentHash?: StringFilter<"SummarizedResume"> | string
    summary?: JsonFilter<"SummarizedResume">
    createdAt?: DateTimeFilter<"SummarizedResume"> | Date | string
    extractedResume?: XOR<ExtractedResumeScalarRelationFilter, ExtractedResumeWhereInput>
  }

  export type SummarizedResumeOrderByWithRelationInput = {
    id?: SortOrder
    extractedResumeId?: SortOrder
    contentHash?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    extractedResume?: ExtractedResumeOrderByWithRelationInput
  }

  export type SummarizedResumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: SummarizedResumeWhereInput | SummarizedResumeWhereInput[]
    OR?: SummarizedResumeWhereInput[]
    NOT?: SummarizedResumeWhereInput | SummarizedResumeWhereInput[]
    extractedResumeId?: StringFilter<"SummarizedResume"> | string
    summary?: JsonFilter<"SummarizedResume">
    createdAt?: DateTimeFilter<"SummarizedResume"> | Date | string
    extractedResume?: XOR<ExtractedResumeScalarRelationFilter, ExtractedResumeWhereInput>
  }, "id" | "contentHash">

  export type SummarizedResumeOrderByWithAggregationInput = {
    id?: SortOrder
    extractedResumeId?: SortOrder
    contentHash?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    _count?: SummarizedResumeCountOrderByAggregateInput
    _max?: SummarizedResumeMaxOrderByAggregateInput
    _min?: SummarizedResumeMinOrderByAggregateInput
  }

  export type SummarizedResumeScalarWhereWithAggregatesInput = {
    AND?: SummarizedResumeScalarWhereWithAggregatesInput | SummarizedResumeScalarWhereWithAggregatesInput[]
    OR?: SummarizedResumeScalarWhereWithAggregatesInput[]
    NOT?: SummarizedResumeScalarWhereWithAggregatesInput | SummarizedResumeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SummarizedResume"> | string
    extractedResumeId?: StringWithAggregatesFilter<"SummarizedResume"> | string
    contentHash?: StringWithAggregatesFilter<"SummarizedResume"> | string
    summary?: JsonWithAggregatesFilter<"SummarizedResume">
    createdAt?: DateTimeWithAggregatesFilter<"SummarizedResume"> | Date | string
  }

  export type SummarizedJobDescriptionWhereInput = {
    AND?: SummarizedJobDescriptionWhereInput | SummarizedJobDescriptionWhereInput[]
    OR?: SummarizedJobDescriptionWhereInput[]
    NOT?: SummarizedJobDescriptionWhereInput | SummarizedJobDescriptionWhereInput[]
    id?: StringFilter<"SummarizedJobDescription"> | string
    extractedJobId?: StringFilter<"SummarizedJobDescription"> | string
    contentHash?: StringFilter<"SummarizedJobDescription"> | string
    summary?: JsonFilter<"SummarizedJobDescription">
    createdAt?: DateTimeFilter<"SummarizedJobDescription"> | Date | string
    extractedJob?: XOR<ExtractedJobDescriptionScalarRelationFilter, ExtractedJobDescriptionWhereInput>
  }

  export type SummarizedJobDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    extractedJob?: ExtractedJobDescriptionOrderByWithRelationInput
  }

  export type SummarizedJobDescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: SummarizedJobDescriptionWhereInput | SummarizedJobDescriptionWhereInput[]
    OR?: SummarizedJobDescriptionWhereInput[]
    NOT?: SummarizedJobDescriptionWhereInput | SummarizedJobDescriptionWhereInput[]
    extractedJobId?: StringFilter<"SummarizedJobDescription"> | string
    summary?: JsonFilter<"SummarizedJobDescription">
    createdAt?: DateTimeFilter<"SummarizedJobDescription"> | Date | string
    extractedJob?: XOR<ExtractedJobDescriptionScalarRelationFilter, ExtractedJobDescriptionWhereInput>
  }, "id" | "contentHash">

  export type SummarizedJobDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
    _count?: SummarizedJobDescriptionCountOrderByAggregateInput
    _max?: SummarizedJobDescriptionMaxOrderByAggregateInput
    _min?: SummarizedJobDescriptionMinOrderByAggregateInput
  }

  export type SummarizedJobDescriptionScalarWhereWithAggregatesInput = {
    AND?: SummarizedJobDescriptionScalarWhereWithAggregatesInput | SummarizedJobDescriptionScalarWhereWithAggregatesInput[]
    OR?: SummarizedJobDescriptionScalarWhereWithAggregatesInput[]
    NOT?: SummarizedJobDescriptionScalarWhereWithAggregatesInput | SummarizedJobDescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SummarizedJobDescription"> | string
    extractedJobId?: StringWithAggregatesFilter<"SummarizedJobDescription"> | string
    contentHash?: StringWithAggregatesFilter<"SummarizedJobDescription"> | string
    summary?: JsonWithAggregatesFilter<"SummarizedJobDescription">
    createdAt?: DateTimeWithAggregatesFilter<"SummarizedJobDescription"> | Date | string
  }

  export type GeneratedRoastWhereInput = {
    AND?: GeneratedRoastWhereInput | GeneratedRoastWhereInput[]
    OR?: GeneratedRoastWhereInput[]
    NOT?: GeneratedRoastWhereInput | GeneratedRoastWhereInput[]
    id?: StringFilter<"GeneratedRoast"> | string
    userId?: StringNullableFilter<"GeneratedRoast"> | string | null
    resumeId?: StringNullableFilter<"GeneratedRoast"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedRoast"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedRoast"> | string | null
    contentHash?: StringFilter<"GeneratedRoast"> | string
    data?: JsonFilter<"GeneratedRoast">
    overallScore?: IntNullableFilter<"GeneratedRoast"> | number | null
    createdAt?: DateTimeFilter<"GeneratedRoast"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    resume?: XOR<ResumeNullableScalarRelationFilter, ResumeWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
    sharedAnalyses?: SharedAnalysisListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
  }

  export type GeneratedRoastOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    resumeId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    overallScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
    extractedResume?: ExtractedResumeOrderByWithRelationInput
    extractedJob?: ExtractedJobDescriptionOrderByWithRelationInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
    sharedAnalyses?: SharedAnalysisOrderByRelationAggregateInput
    generatedCoverLetters?: GeneratedCoverLetterOrderByRelationAggregateInput
    generatedResumes?: GeneratedResumeOrderByRelationAggregateInput
    generatedInterviewPreps?: GeneratedInterviewPrepOrderByRelationAggregateInput
  }

  export type GeneratedRoastWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: GeneratedRoastWhereInput | GeneratedRoastWhereInput[]
    OR?: GeneratedRoastWhereInput[]
    NOT?: GeneratedRoastWhereInput | GeneratedRoastWhereInput[]
    userId?: StringNullableFilter<"GeneratedRoast"> | string | null
    resumeId?: StringNullableFilter<"GeneratedRoast"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedRoast"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedRoast"> | string | null
    data?: JsonFilter<"GeneratedRoast">
    overallScore?: IntNullableFilter<"GeneratedRoast"> | number | null
    createdAt?: DateTimeFilter<"GeneratedRoast"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    resume?: XOR<ResumeNullableScalarRelationFilter, ResumeWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
    sharedAnalyses?: SharedAnalysisListRelationFilter
    generatedCoverLetters?: GeneratedCoverLetterListRelationFilter
    generatedResumes?: GeneratedResumeListRelationFilter
    generatedInterviewPreps?: GeneratedInterviewPrepListRelationFilter
  }, "id" | "contentHash">

  export type GeneratedRoastOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    resumeId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    overallScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeneratedRoastCountOrderByAggregateInput
    _avg?: GeneratedRoastAvgOrderByAggregateInput
    _max?: GeneratedRoastMaxOrderByAggregateInput
    _min?: GeneratedRoastMinOrderByAggregateInput
    _sum?: GeneratedRoastSumOrderByAggregateInput
  }

  export type GeneratedRoastScalarWhereWithAggregatesInput = {
    AND?: GeneratedRoastScalarWhereWithAggregatesInput | GeneratedRoastScalarWhereWithAggregatesInput[]
    OR?: GeneratedRoastScalarWhereWithAggregatesInput[]
    NOT?: GeneratedRoastScalarWhereWithAggregatesInput | GeneratedRoastScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneratedRoast"> | string
    userId?: StringNullableWithAggregatesFilter<"GeneratedRoast"> | string | null
    resumeId?: StringNullableWithAggregatesFilter<"GeneratedRoast"> | string | null
    extractedResumeId?: StringNullableWithAggregatesFilter<"GeneratedRoast"> | string | null
    extractedJobId?: StringNullableWithAggregatesFilter<"GeneratedRoast"> | string | null
    contentHash?: StringWithAggregatesFilter<"GeneratedRoast"> | string
    data?: JsonWithAggregatesFilter<"GeneratedRoast">
    overallScore?: IntNullableWithAggregatesFilter<"GeneratedRoast"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedRoast"> | Date | string
  }

  export type GeneratedCoverLetterWhereInput = {
    AND?: GeneratedCoverLetterWhereInput | GeneratedCoverLetterWhereInput[]
    OR?: GeneratedCoverLetterWhereInput[]
    NOT?: GeneratedCoverLetterWhereInput | GeneratedCoverLetterWhereInput[]
    id?: StringFilter<"GeneratedCoverLetter"> | string
    userId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    resumeId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    roastId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    contentHash?: StringFilter<"GeneratedCoverLetter"> | string
    content?: StringFilter<"GeneratedCoverLetter"> | string
    tone?: StringFilter<"GeneratedCoverLetter"> | string
    modelName?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    metadata?: JsonNullableFilter<"GeneratedCoverLetter">
    createdAt?: DateTimeFilter<"GeneratedCoverLetter"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    resume?: XOR<ResumeNullableScalarRelationFilter, ResumeWhereInput> | null
    roast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
  }

  export type GeneratedCoverLetterOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    resumeId?: SortOrderInput | SortOrder
    roastId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    modelName?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    resume?: ResumeOrderByWithRelationInput
    roast?: GeneratedRoastOrderByWithRelationInput
    extractedResume?: ExtractedResumeOrderByWithRelationInput
    extractedJob?: ExtractedJobDescriptionOrderByWithRelationInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
  }

  export type GeneratedCoverLetterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: GeneratedCoverLetterWhereInput | GeneratedCoverLetterWhereInput[]
    OR?: GeneratedCoverLetterWhereInput[]
    NOT?: GeneratedCoverLetterWhereInput | GeneratedCoverLetterWhereInput[]
    userId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    resumeId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    roastId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    content?: StringFilter<"GeneratedCoverLetter"> | string
    tone?: StringFilter<"GeneratedCoverLetter"> | string
    modelName?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    metadata?: JsonNullableFilter<"GeneratedCoverLetter">
    createdAt?: DateTimeFilter<"GeneratedCoverLetter"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    resume?: XOR<ResumeNullableScalarRelationFilter, ResumeWhereInput> | null
    roast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
  }, "id" | "contentHash">

  export type GeneratedCoverLetterOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    resumeId?: SortOrderInput | SortOrder
    roastId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    modelName?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeneratedCoverLetterCountOrderByAggregateInput
    _max?: GeneratedCoverLetterMaxOrderByAggregateInput
    _min?: GeneratedCoverLetterMinOrderByAggregateInput
  }

  export type GeneratedCoverLetterScalarWhereWithAggregatesInput = {
    AND?: GeneratedCoverLetterScalarWhereWithAggregatesInput | GeneratedCoverLetterScalarWhereWithAggregatesInput[]
    OR?: GeneratedCoverLetterScalarWhereWithAggregatesInput[]
    NOT?: GeneratedCoverLetterScalarWhereWithAggregatesInput | GeneratedCoverLetterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneratedCoverLetter"> | string
    userId?: StringNullableWithAggregatesFilter<"GeneratedCoverLetter"> | string | null
    resumeId?: StringNullableWithAggregatesFilter<"GeneratedCoverLetter"> | string | null
    roastId?: StringNullableWithAggregatesFilter<"GeneratedCoverLetter"> | string | null
    extractedResumeId?: StringNullableWithAggregatesFilter<"GeneratedCoverLetter"> | string | null
    extractedJobId?: StringNullableWithAggregatesFilter<"GeneratedCoverLetter"> | string | null
    contentHash?: StringWithAggregatesFilter<"GeneratedCoverLetter"> | string
    content?: StringWithAggregatesFilter<"GeneratedCoverLetter"> | string
    tone?: StringWithAggregatesFilter<"GeneratedCoverLetter"> | string
    modelName?: StringNullableWithAggregatesFilter<"GeneratedCoverLetter"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"GeneratedCoverLetter">
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedCoverLetter"> | Date | string
  }

  export type GeneratedResumeWhereInput = {
    AND?: GeneratedResumeWhereInput | GeneratedResumeWhereInput[]
    OR?: GeneratedResumeWhereInput[]
    NOT?: GeneratedResumeWhereInput | GeneratedResumeWhereInput[]
    id?: StringFilter<"GeneratedResume"> | string
    userId?: StringNullableFilter<"GeneratedResume"> | string | null
    roastId?: StringNullableFilter<"GeneratedResume"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedResume"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedResume"> | string | null
    templateId?: StringFilter<"GeneratedResume"> | string
    contentHash?: StringFilter<"GeneratedResume"> | string
    content?: StringFilter<"GeneratedResume"> | string
    data?: JsonFilter<"GeneratedResume">
    atsScore?: IntNullableFilter<"GeneratedResume"> | number | null
    keywordsMatched?: StringNullableListFilter<"GeneratedResume">
    createdAt?: DateTimeFilter<"GeneratedResume"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    roast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
  }

  export type GeneratedResumeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    roastId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    templateId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    data?: SortOrder
    atsScore?: SortOrderInput | SortOrder
    keywordsMatched?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    roast?: GeneratedRoastOrderByWithRelationInput
    extractedResume?: ExtractedResumeOrderByWithRelationInput
    extractedJob?: ExtractedJobDescriptionOrderByWithRelationInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
  }

  export type GeneratedResumeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: GeneratedResumeWhereInput | GeneratedResumeWhereInput[]
    OR?: GeneratedResumeWhereInput[]
    NOT?: GeneratedResumeWhereInput | GeneratedResumeWhereInput[]
    userId?: StringNullableFilter<"GeneratedResume"> | string | null
    roastId?: StringNullableFilter<"GeneratedResume"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedResume"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedResume"> | string | null
    templateId?: StringFilter<"GeneratedResume"> | string
    content?: StringFilter<"GeneratedResume"> | string
    data?: JsonFilter<"GeneratedResume">
    atsScore?: IntNullableFilter<"GeneratedResume"> | number | null
    keywordsMatched?: StringNullableListFilter<"GeneratedResume">
    createdAt?: DateTimeFilter<"GeneratedResume"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    roast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
  }, "id" | "contentHash">

  export type GeneratedResumeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    roastId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    templateId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    data?: SortOrder
    atsScore?: SortOrderInput | SortOrder
    keywordsMatched?: SortOrder
    createdAt?: SortOrder
    _count?: GeneratedResumeCountOrderByAggregateInput
    _avg?: GeneratedResumeAvgOrderByAggregateInput
    _max?: GeneratedResumeMaxOrderByAggregateInput
    _min?: GeneratedResumeMinOrderByAggregateInput
    _sum?: GeneratedResumeSumOrderByAggregateInput
  }

  export type GeneratedResumeScalarWhereWithAggregatesInput = {
    AND?: GeneratedResumeScalarWhereWithAggregatesInput | GeneratedResumeScalarWhereWithAggregatesInput[]
    OR?: GeneratedResumeScalarWhereWithAggregatesInput[]
    NOT?: GeneratedResumeScalarWhereWithAggregatesInput | GeneratedResumeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneratedResume"> | string
    userId?: StringNullableWithAggregatesFilter<"GeneratedResume"> | string | null
    roastId?: StringNullableWithAggregatesFilter<"GeneratedResume"> | string | null
    extractedResumeId?: StringNullableWithAggregatesFilter<"GeneratedResume"> | string | null
    extractedJobId?: StringNullableWithAggregatesFilter<"GeneratedResume"> | string | null
    templateId?: StringWithAggregatesFilter<"GeneratedResume"> | string
    contentHash?: StringWithAggregatesFilter<"GeneratedResume"> | string
    content?: StringWithAggregatesFilter<"GeneratedResume"> | string
    data?: JsonWithAggregatesFilter<"GeneratedResume">
    atsScore?: IntNullableWithAggregatesFilter<"GeneratedResume"> | number | null
    keywordsMatched?: StringNullableListFilter<"GeneratedResume">
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedResume"> | Date | string
  }

  export type GeneratedInterviewPrepWhereInput = {
    AND?: GeneratedInterviewPrepWhereInput | GeneratedInterviewPrepWhereInput[]
    OR?: GeneratedInterviewPrepWhereInput[]
    NOT?: GeneratedInterviewPrepWhereInput | GeneratedInterviewPrepWhereInput[]
    id?: StringFilter<"GeneratedInterviewPrep"> | string
    userId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    roastId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    contentHash?: StringFilter<"GeneratedInterviewPrep"> | string
    data?: JsonFilter<"GeneratedInterviewPrep">
    difficulty?: StringFilter<"GeneratedInterviewPrep"> | string
    category?: StringFilter<"GeneratedInterviewPrep"> | string
    modelName?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    createdAt?: DateTimeFilter<"GeneratedInterviewPrep"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    roast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
    evaluations?: InterviewEvaluationListRelationFilter
  }

  export type GeneratedInterviewPrepOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    roastId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    modelName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    roast?: GeneratedRoastOrderByWithRelationInput
    extractedResume?: ExtractedResumeOrderByWithRelationInput
    extractedJob?: ExtractedJobDescriptionOrderByWithRelationInput
    llmCalls?: LlmCallOrderByRelationAggregateInput
    evaluations?: InterviewEvaluationOrderByRelationAggregateInput
  }

  export type GeneratedInterviewPrepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentHash?: string
    AND?: GeneratedInterviewPrepWhereInput | GeneratedInterviewPrepWhereInput[]
    OR?: GeneratedInterviewPrepWhereInput[]
    NOT?: GeneratedInterviewPrepWhereInput | GeneratedInterviewPrepWhereInput[]
    userId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    roastId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    data?: JsonFilter<"GeneratedInterviewPrep">
    difficulty?: StringFilter<"GeneratedInterviewPrep"> | string
    category?: StringFilter<"GeneratedInterviewPrep"> | string
    modelName?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    createdAt?: DateTimeFilter<"GeneratedInterviewPrep"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    roast?: XOR<GeneratedRoastNullableScalarRelationFilter, GeneratedRoastWhereInput> | null
    extractedResume?: XOR<ExtractedResumeNullableScalarRelationFilter, ExtractedResumeWhereInput> | null
    extractedJob?: XOR<ExtractedJobDescriptionNullableScalarRelationFilter, ExtractedJobDescriptionWhereInput> | null
    llmCalls?: LlmCallListRelationFilter
    evaluations?: InterviewEvaluationListRelationFilter
  }, "id" | "contentHash">

  export type GeneratedInterviewPrepOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    roastId?: SortOrderInput | SortOrder
    extractedResumeId?: SortOrderInput | SortOrder
    extractedJobId?: SortOrderInput | SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    modelName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GeneratedInterviewPrepCountOrderByAggregateInput
    _max?: GeneratedInterviewPrepMaxOrderByAggregateInput
    _min?: GeneratedInterviewPrepMinOrderByAggregateInput
  }

  export type GeneratedInterviewPrepScalarWhereWithAggregatesInput = {
    AND?: GeneratedInterviewPrepScalarWhereWithAggregatesInput | GeneratedInterviewPrepScalarWhereWithAggregatesInput[]
    OR?: GeneratedInterviewPrepScalarWhereWithAggregatesInput[]
    NOT?: GeneratedInterviewPrepScalarWhereWithAggregatesInput | GeneratedInterviewPrepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GeneratedInterviewPrep"> | string
    userId?: StringNullableWithAggregatesFilter<"GeneratedInterviewPrep"> | string | null
    roastId?: StringNullableWithAggregatesFilter<"GeneratedInterviewPrep"> | string | null
    extractedResumeId?: StringNullableWithAggregatesFilter<"GeneratedInterviewPrep"> | string | null
    extractedJobId?: StringNullableWithAggregatesFilter<"GeneratedInterviewPrep"> | string | null
    contentHash?: StringWithAggregatesFilter<"GeneratedInterviewPrep"> | string
    data?: JsonWithAggregatesFilter<"GeneratedInterviewPrep">
    difficulty?: StringWithAggregatesFilter<"GeneratedInterviewPrep"> | string
    category?: StringWithAggregatesFilter<"GeneratedInterviewPrep"> | string
    modelName?: StringNullableWithAggregatesFilter<"GeneratedInterviewPrep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"GeneratedInterviewPrep"> | Date | string
  }

  export type InterviewEvaluationWhereInput = {
    AND?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    OR?: InterviewEvaluationWhereInput[]
    NOT?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    id?: StringFilter<"InterviewEvaluation"> | string
    interviewPrepId?: StringFilter<"InterviewEvaluation"> | string
    userId?: StringNullableFilter<"InterviewEvaluation"> | string | null
    evaluationType?: StringFilter<"InterviewEvaluation"> | string
    data?: JsonFilter<"InterviewEvaluation">
    questionsCount?: IntFilter<"InterviewEvaluation"> | number
    overallScore?: IntFilter<"InterviewEvaluation"> | number
    createdAt?: DateTimeFilter<"InterviewEvaluation"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    interviewPrep?: XOR<GeneratedInterviewPrepScalarRelationFilter, GeneratedInterviewPrepWhereInput>
  }

  export type InterviewEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    interviewPrepId?: SortOrder
    userId?: SortOrderInput | SortOrder
    evaluationType?: SortOrder
    data?: SortOrder
    questionsCount?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    interviewPrep?: GeneratedInterviewPrepOrderByWithRelationInput
  }

  export type InterviewEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    OR?: InterviewEvaluationWhereInput[]
    NOT?: InterviewEvaluationWhereInput | InterviewEvaluationWhereInput[]
    interviewPrepId?: StringFilter<"InterviewEvaluation"> | string
    userId?: StringNullableFilter<"InterviewEvaluation"> | string | null
    evaluationType?: StringFilter<"InterviewEvaluation"> | string
    data?: JsonFilter<"InterviewEvaluation">
    questionsCount?: IntFilter<"InterviewEvaluation"> | number
    overallScore?: IntFilter<"InterviewEvaluation"> | number
    createdAt?: DateTimeFilter<"InterviewEvaluation"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    interviewPrep?: XOR<GeneratedInterviewPrepScalarRelationFilter, GeneratedInterviewPrepWhereInput>
  }, "id">

  export type InterviewEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    interviewPrepId?: SortOrder
    userId?: SortOrderInput | SortOrder
    evaluationType?: SortOrder
    data?: SortOrder
    questionsCount?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
    _count?: InterviewEvaluationCountOrderByAggregateInput
    _avg?: InterviewEvaluationAvgOrderByAggregateInput
    _max?: InterviewEvaluationMaxOrderByAggregateInput
    _min?: InterviewEvaluationMinOrderByAggregateInput
    _sum?: InterviewEvaluationSumOrderByAggregateInput
  }

  export type InterviewEvaluationScalarWhereWithAggregatesInput = {
    AND?: InterviewEvaluationScalarWhereWithAggregatesInput | InterviewEvaluationScalarWhereWithAggregatesInput[]
    OR?: InterviewEvaluationScalarWhereWithAggregatesInput[]
    NOT?: InterviewEvaluationScalarWhereWithAggregatesInput | InterviewEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewEvaluation"> | string
    interviewPrepId?: StringWithAggregatesFilter<"InterviewEvaluation"> | string
    userId?: StringNullableWithAggregatesFilter<"InterviewEvaluation"> | string | null
    evaluationType?: StringWithAggregatesFilter<"InterviewEvaluation"> | string
    data?: JsonWithAggregatesFilter<"InterviewEvaluation">
    questionsCount?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    overallScore?: IntWithAggregatesFilter<"InterviewEvaluation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InterviewEvaluation"> | Date | string
  }

  export type SharedAnalysisWhereInput = {
    AND?: SharedAnalysisWhereInput | SharedAnalysisWhereInput[]
    OR?: SharedAnalysisWhereInput[]
    NOT?: SharedAnalysisWhereInput | SharedAnalysisWhereInput[]
    id?: StringFilter<"SharedAnalysis"> | string
    userId?: StringFilter<"SharedAnalysis"> | string
    roastId?: StringFilter<"SharedAnalysis"> | string
    settings?: JsonNullableFilter<"SharedAnalysis">
    viewCount?: IntFilter<"SharedAnalysis"> | number
    expiresAt?: DateTimeFilter<"SharedAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"SharedAnalysis"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    roast?: XOR<GeneratedRoastScalarRelationFilter, GeneratedRoastWhereInput>
  }

  export type SharedAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    settings?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    roast?: GeneratedRoastOrderByWithRelationInput
  }

  export type SharedAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SharedAnalysisWhereInput | SharedAnalysisWhereInput[]
    OR?: SharedAnalysisWhereInput[]
    NOT?: SharedAnalysisWhereInput | SharedAnalysisWhereInput[]
    userId?: StringFilter<"SharedAnalysis"> | string
    roastId?: StringFilter<"SharedAnalysis"> | string
    settings?: JsonNullableFilter<"SharedAnalysis">
    viewCount?: IntFilter<"SharedAnalysis"> | number
    expiresAt?: DateTimeFilter<"SharedAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"SharedAnalysis"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    roast?: XOR<GeneratedRoastScalarRelationFilter, GeneratedRoastWhereInput>
  }, "id">

  export type SharedAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    settings?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SharedAnalysisCountOrderByAggregateInput
    _avg?: SharedAnalysisAvgOrderByAggregateInput
    _max?: SharedAnalysisMaxOrderByAggregateInput
    _min?: SharedAnalysisMinOrderByAggregateInput
    _sum?: SharedAnalysisSumOrderByAggregateInput
  }

  export type SharedAnalysisScalarWhereWithAggregatesInput = {
    AND?: SharedAnalysisScalarWhereWithAggregatesInput | SharedAnalysisScalarWhereWithAggregatesInput[]
    OR?: SharedAnalysisScalarWhereWithAggregatesInput[]
    NOT?: SharedAnalysisScalarWhereWithAggregatesInput | SharedAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedAnalysis"> | string
    userId?: StringWithAggregatesFilter<"SharedAnalysis"> | string
    roastId?: StringWithAggregatesFilter<"SharedAnalysis"> | string
    settings?: JsonNullableWithAggregatesFilter<"SharedAnalysis">
    viewCount?: IntWithAggregatesFilter<"SharedAnalysis"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"SharedAnalysis"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SharedAnalysis"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFilter<"Invoice"> | Date | string
    billingPeriodEnd?: DateTimeFilter<"Invoice"> | Date | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    stripePaymentId?: StringNullableFilter<"Invoice"> | string | null
    itemCount?: IntFilter<"Invoice"> | number
    generatedAt?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    itemCount?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripeInvoiceId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFilter<"Invoice"> | Date | string
    billingPeriodEnd?: DateTimeFilter<"Invoice"> | Date | string
    stripePaymentId?: StringNullableFilter<"Invoice"> | string | null
    itemCount?: IntFilter<"Invoice"> | number
    generatedAt?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "stripeInvoiceId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    stripeInvoiceId?: SortOrderInput | SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    itemCount?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    billingPeriodEnd?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    stripeInvoiceId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    stripePaymentId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    itemCount?: IntWithAggregatesFilter<"Invoice"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
  }

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    id?: StringFilter<"Announcement"> | string
    title?: StringFilter<"Announcement"> | string
    description?: StringFilter<"Announcement"> | string
    featureName?: StringNullableFilter<"Announcement"> | string | null
    estimatedDate?: StringNullableFilter<"Announcement"> | string | null
    type?: EnumAnnouncementTypeFilter<"Announcement"> | $Enums.AnnouncementType
    ctaText?: StringNullableFilter<"Announcement"> | string | null
    ctaUrl?: StringNullableFilter<"Announcement"> | string | null
    isActive?: BoolFilter<"Announcement"> | boolean
    startDate?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    targetTiers?: EnumSubscriptionTierNullableListFilter<"Announcement">
    dismissedBy?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    featureName?: SortOrderInput | SortOrder
    estimatedDate?: SortOrderInput | SortOrder
    type?: SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    targetTiers?: SortOrder
    dismissedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[]
    OR?: AnnouncementWhereInput[]
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[]
    title?: StringFilter<"Announcement"> | string
    description?: StringFilter<"Announcement"> | string
    featureName?: StringNullableFilter<"Announcement"> | string | null
    estimatedDate?: StringNullableFilter<"Announcement"> | string | null
    type?: EnumAnnouncementTypeFilter<"Announcement"> | $Enums.AnnouncementType
    ctaText?: StringNullableFilter<"Announcement"> | string | null
    ctaUrl?: StringNullableFilter<"Announcement"> | string | null
    isActive?: BoolFilter<"Announcement"> | boolean
    startDate?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Announcement"> | Date | string | null
    targetTiers?: EnumSubscriptionTierNullableListFilter<"Announcement">
    dismissedBy?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeFilter<"Announcement"> | Date | string
  }, "id">

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    featureName?: SortOrderInput | SortOrder
    estimatedDate?: SortOrderInput | SortOrder
    type?: SortOrder
    ctaText?: SortOrderInput | SortOrder
    ctaUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    targetTiers?: SortOrder
    dismissedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnouncementCountOrderByAggregateInput
    _max?: AnnouncementMaxOrderByAggregateInput
    _min?: AnnouncementMinOrderByAggregateInput
  }

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    OR?: AnnouncementScalarWhereWithAggregatesInput[]
    NOT?: AnnouncementScalarWhereWithAggregatesInput | AnnouncementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Announcement"> | string
    title?: StringWithAggregatesFilter<"Announcement"> | string
    description?: StringWithAggregatesFilter<"Announcement"> | string
    featureName?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    estimatedDate?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    type?: EnumAnnouncementTypeWithAggregatesFilter<"Announcement"> | $Enums.AnnouncementType
    ctaText?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    ctaUrl?: StringNullableWithAggregatesFilter<"Announcement"> | string | null
    isActive?: BoolWithAggregatesFilter<"Announcement"> | boolean
    startDate?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Announcement"> | Date | string | null
    targetTiers?: EnumSubscriptionTierNullableListFilter<"Announcement">
    dismissedBy?: StringNullableListFilter<"Announcement">
    createdAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Announcement"> | Date | string
  }

  export type ChatbotWhereInput = {
    AND?: ChatbotWhereInput | ChatbotWhereInput[]
    OR?: ChatbotWhereInput[]
    NOT?: ChatbotWhereInput | ChatbotWhereInput[]
    id?: StringFilter<"Chatbot"> | string
    userId?: StringNullableFilter<"Chatbot"> | string | null
    anonymousId?: StringNullableFilter<"Chatbot"> | string | null
    conversationId?: StringFilter<"Chatbot"> | string
    message?: StringFilter<"Chatbot"> | string
    role?: StringFilter<"Chatbot"> | string
    llmMessageId?: StringNullableFilter<"Chatbot"> | string | null
    createdAt?: DateTimeFilter<"Chatbot"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ChatbotOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    conversationId?: SortOrder
    message?: SortOrder
    role?: SortOrder
    llmMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ChatbotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatbotWhereInput | ChatbotWhereInput[]
    OR?: ChatbotWhereInput[]
    NOT?: ChatbotWhereInput | ChatbotWhereInput[]
    userId?: StringNullableFilter<"Chatbot"> | string | null
    anonymousId?: StringNullableFilter<"Chatbot"> | string | null
    conversationId?: StringFilter<"Chatbot"> | string
    message?: StringFilter<"Chatbot"> | string
    role?: StringFilter<"Chatbot"> | string
    llmMessageId?: StringNullableFilter<"Chatbot"> | string | null
    createdAt?: DateTimeFilter<"Chatbot"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ChatbotOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    anonymousId?: SortOrderInput | SortOrder
    conversationId?: SortOrder
    message?: SortOrder
    role?: SortOrder
    llmMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatbotCountOrderByAggregateInput
    _max?: ChatbotMaxOrderByAggregateInput
    _min?: ChatbotMinOrderByAggregateInput
  }

  export type ChatbotScalarWhereWithAggregatesInput = {
    AND?: ChatbotScalarWhereWithAggregatesInput | ChatbotScalarWhereWithAggregatesInput[]
    OR?: ChatbotScalarWhereWithAggregatesInput[]
    NOT?: ChatbotScalarWhereWithAggregatesInput | ChatbotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chatbot"> | string
    userId?: StringNullableWithAggregatesFilter<"Chatbot"> | string | null
    anonymousId?: StringNullableWithAggregatesFilter<"Chatbot"> | string | null
    conversationId?: StringWithAggregatesFilter<"Chatbot"> | string
    message?: StringWithAggregatesFilter<"Chatbot"> | string
    role?: StringWithAggregatesFilter<"Chatbot"> | string
    llmMessageId?: StringNullableWithAggregatesFilter<"Chatbot"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Chatbot"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    messageCount?: IntFilter<"Conversation"> | number
    selectedTemplate?: StringNullableFilter<"Conversation"> | string | null
    selectedModel?: StringNullableFilter<"Conversation"> | string | null
    metadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ConversationMessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    lastMessageAt?: SortOrder
    messageCount?: SortOrder
    selectedTemplate?: SortOrderInput | SortOrder
    selectedModel?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    messages?: ConversationMessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    messageCount?: IntFilter<"Conversation"> | number
    selectedTemplate?: StringNullableFilter<"Conversation"> | string | null
    selectedModel?: StringNullableFilter<"Conversation"> | string | null
    metadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: ConversationMessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    lastMessageAt?: SortOrder
    messageCount?: SortOrder
    selectedTemplate?: SortOrderInput | SortOrder
    selectedModel?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringWithAggregatesFilter<"Conversation"> | string
    lastMessageAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    messageCount?: IntWithAggregatesFilter<"Conversation"> | number
    selectedTemplate?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    selectedModel?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Conversation">
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationMessageWhereInput = {
    AND?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    OR?: ConversationMessageWhereInput[]
    NOT?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    id?: StringFilter<"ConversationMessage"> | string
    conversationId?: StringFilter<"ConversationMessage"> | string
    role?: EnumMessageRoleFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringFilter<"ConversationMessage"> | string
    messageIndex?: IntFilter<"ConversationMessage"> | number
    model?: StringNullableFilter<"ConversationMessage"> | string | null
    template?: StringNullableFilter<"ConversationMessage"> | string | null
    tokensUsed?: IntNullableFilter<"ConversationMessage"> | number | null
    costUsd?: DecimalNullableFilter<"ConversationMessage"> | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: IntNullableFilter<"ConversationMessage"> | number | null
    hasLatexCode?: BoolFilter<"ConversationMessage"> | boolean
    metadata?: JsonNullableFilter<"ConversationMessage">
    createdAt?: DateTimeFilter<"ConversationMessage"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type ConversationMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    model?: SortOrderInput | SortOrder
    template?: SortOrderInput | SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    costUsd?: SortOrderInput | SortOrder
    processingTimeMs?: SortOrderInput | SortOrder
    hasLatexCode?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type ConversationMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_messageIndex?: ConversationMessageConversationIdMessageIndexCompoundUniqueInput
    AND?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    OR?: ConversationMessageWhereInput[]
    NOT?: ConversationMessageWhereInput | ConversationMessageWhereInput[]
    conversationId?: StringFilter<"ConversationMessage"> | string
    role?: EnumMessageRoleFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringFilter<"ConversationMessage"> | string
    messageIndex?: IntFilter<"ConversationMessage"> | number
    model?: StringNullableFilter<"ConversationMessage"> | string | null
    template?: StringNullableFilter<"ConversationMessage"> | string | null
    tokensUsed?: IntNullableFilter<"ConversationMessage"> | number | null
    costUsd?: DecimalNullableFilter<"ConversationMessage"> | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: IntNullableFilter<"ConversationMessage"> | number | null
    hasLatexCode?: BoolFilter<"ConversationMessage"> | boolean
    metadata?: JsonNullableFilter<"ConversationMessage">
    createdAt?: DateTimeFilter<"ConversationMessage"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id" | "conversationId_messageIndex">

  export type ConversationMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    model?: SortOrderInput | SortOrder
    template?: SortOrderInput | SortOrder
    tokensUsed?: SortOrderInput | SortOrder
    costUsd?: SortOrderInput | SortOrder
    processingTimeMs?: SortOrderInput | SortOrder
    hasLatexCode?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConversationMessageCountOrderByAggregateInput
    _avg?: ConversationMessageAvgOrderByAggregateInput
    _max?: ConversationMessageMaxOrderByAggregateInput
    _min?: ConversationMessageMinOrderByAggregateInput
    _sum?: ConversationMessageSumOrderByAggregateInput
  }

  export type ConversationMessageScalarWhereWithAggregatesInput = {
    AND?: ConversationMessageScalarWhereWithAggregatesInput | ConversationMessageScalarWhereWithAggregatesInput[]
    OR?: ConversationMessageScalarWhereWithAggregatesInput[]
    NOT?: ConversationMessageScalarWhereWithAggregatesInput | ConversationMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationMessage"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationMessage"> | string
    role?: EnumMessageRoleWithAggregatesFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringWithAggregatesFilter<"ConversationMessage"> | string
    messageIndex?: IntWithAggregatesFilter<"ConversationMessage"> | number
    model?: StringNullableWithAggregatesFilter<"ConversationMessage"> | string | null
    template?: StringNullableWithAggregatesFilter<"ConversationMessage"> | string | null
    tokensUsed?: IntNullableWithAggregatesFilter<"ConversationMessage"> | number | null
    costUsd?: DecimalNullableWithAggregatesFilter<"ConversationMessage"> | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: IntNullableWithAggregatesFilter<"ConversationMessage"> | number | null
    hasLatexCode?: BoolWithAggregatesFilter<"ConversationMessage"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"ConversationMessage">
    createdAt?: DateTimeWithAggregatesFilter<"ConversationMessage"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date | string
    createdAt?: Date | string
    usedAt?: Date | string | null
    user: UserCreateNestedOneWithoutVerificationTokensInput
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date | string
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutVerificationTokensNestedInput
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date | string
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LlmCallCreateInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallCreateManyInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LlmCallUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LlmCallUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LlmMessageCreateInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens?: number | null
    outputTokens?: number | null
    totalTokens?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string
    processingTimeMs?: number | null
    finishReason?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    maxTokens?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCall: LlmCallCreateNestedOneWithoutMessagesInput
  }

  export type LlmMessageUncheckedCreateInput = {
    id?: string
    llmCallId: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens?: number | null
    outputTokens?: number | null
    totalTokens?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string
    processingTimeMs?: number | null
    finishReason?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    maxTokens?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LlmMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCall?: LlmCallUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type LlmMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    llmCallId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmMessageCreateManyInput = {
    id?: string
    llmCallId: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens?: number | null
    outputTokens?: number | null
    totalTokens?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string
    processingTimeMs?: number | null
    finishReason?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    maxTokens?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LlmMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    llmCallId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeCreateInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateInput = {
    id?: string
    userId?: string | null
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeUncheckedCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUncheckedUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeCreateManyInput = {
    id?: string
    userId?: string | null
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtractedResumeCreateInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeCreateManyInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ExtractedResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtractedResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtractedJobDescriptionCreateInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionCreateManyInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ExtractedJobDescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtractedJobDescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedResumeCreateInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    extractedResume: ExtractedResumeCreateNestedOneWithoutSummarizedResumesInput
  }

  export type SummarizedResumeUncheckedCreateInput = {
    id?: string
    extractedResumeId: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedResume?: ExtractedResumeUpdateOneRequiredWithoutSummarizedResumesNestedInput
  }

  export type SummarizedResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    extractedResumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedResumeCreateManyInput = {
    id?: string
    extractedResumeId: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    extractedResumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedJobDescriptionCreateInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    extractedJob: ExtractedJobDescriptionCreateNestedOneWithoutSummarizedJobDescriptionsInput
  }

  export type SummarizedJobDescriptionUncheckedCreateInput = {
    id?: string
    extractedJobId: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedJobDescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedJob?: ExtractedJobDescriptionUpdateOneRequiredWithoutSummarizedJobDescriptionsNestedInput
  }

  export type SummarizedJobDescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    extractedJobId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedJobDescriptionCreateManyInput = {
    id?: string
    extractedJobId: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedJobDescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedJobDescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    extractedJobId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedRoastCreateInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastCreateManyInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
  }

  export type GeneratedRoastUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedRoastUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterCreateInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedCoverLettersInput
    resume?: ResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUncheckedCreateInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedCoverLettersNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterCreateManyInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeCreateInput = {
    id?: string
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedResumesInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedResumesInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedResumesInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeUncheckedCreateInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedResumesNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedResumesNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedResumesNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeCreateManyInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
  }

  export type GeneratedResumeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepCreateInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedInterviewPrepsInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepCreateManyInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type GeneratedInterviewPrepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationCreateInput = {
    id?: string
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutInterviewEvaluationsInput
    interviewPrep: GeneratedInterviewPrepCreateNestedOneWithoutEvaluationsInput
  }

  export type InterviewEvaluationUncheckedCreateInput = {
    id?: string
    interviewPrepId: string
    userId?: string | null
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
  }

  export type InterviewEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInterviewEvaluationsNestedInput
    interviewPrep?: GeneratedInterviewPrepUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type InterviewEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewPrepId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationCreateManyInput = {
    id?: string
    interviewPrepId: string
    userId?: string | null
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
  }

  export type InterviewEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewPrepId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAnalysisCreateInput = {
    id: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSharedAnalysesInput
    roast: GeneratedRoastCreateNestedOneWithoutSharedAnalysesInput
  }

  export type SharedAnalysisUncheckedCreateInput = {
    id: string
    userId: string
    roastId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SharedAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedAnalysesNestedInput
    roast?: GeneratedRoastUpdateOneRequiredWithoutSharedAnalysesNestedInput
  }

  export type SharedAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roastId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAnalysisCreateManyInput = {
    id: string
    userId: string
    roastId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SharedAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roastId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    stripeInvoiceId?: string | null
    stripePaymentId?: string | null
    itemCount: number
    generatedAt?: Date | string
    paidAt?: Date | string | null
    user: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    stripeInvoiceId?: string | null
    stripePaymentId?: string | null
    itemCount: number
    generatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceCreateManyInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    stripeInvoiceId?: string | null
    stripePaymentId?: string | null
    itemCount: number
    generatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnnouncementCreateInput = {
    id?: string
    title: string
    description: string
    featureName?: string | null
    estimatedDate?: string | null
    type?: $Enums.AnnouncementType
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetTiers?: AnnouncementCreatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementCreatedismissedByInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    featureName?: string | null
    estimatedDate?: string | null
    type?: $Enums.AnnouncementType
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetTiers?: AnnouncementCreatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementCreatedismissedByInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetTiers?: AnnouncementUpdatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementUpdatedismissedByInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetTiers?: AnnouncementUpdatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementUpdatedismissedByInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementCreateManyInput = {
    id?: string
    title: string
    description: string
    featureName?: string | null
    estimatedDate?: string | null
    type?: $Enums.AnnouncementType
    ctaText?: string | null
    ctaUrl?: string | null
    isActive?: boolean
    startDate?: Date | string | null
    endDate?: Date | string | null
    targetTiers?: AnnouncementCreatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementCreatedismissedByInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnouncementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetTiers?: AnnouncementUpdatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementUpdatedismissedByInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnouncementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    featureName?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedDate?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumAnnouncementTypeFieldUpdateOperationsInput | $Enums.AnnouncementType
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    ctaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetTiers?: AnnouncementUpdatetargetTiersInput | $Enums.SubscriptionTier[]
    dismissedBy?: AnnouncementUpdatedismissedByInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotCreateInput = {
    id?: string
    anonymousId?: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutChatbotInput
  }

  export type ChatbotUncheckedCreateInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId?: string | null
    createdAt?: Date | string
  }

  export type ChatbotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutChatbotNestedInput
  }

  export type ChatbotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotCreateManyInput = {
    id?: string
    userId?: string | null
    anonymousId?: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId?: string | null
    createdAt?: Date | string
  }

  export type ChatbotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    messages?: ConversationMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageCreateInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model?: string | null
    template?: string | null
    tokensUsed?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: number | null
    hasLatexCode?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type ConversationMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model?: string | null
    template?: string | null
    tokensUsed?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: number | null
    hasLatexCode?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ConversationMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageCreateManyInput = {
    id?: string
    conversationId: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model?: string | null
    template?: string | null
    tokensUsed?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: number | null
    hasLatexCode?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type LlmCallListRelationFilter = {
    every?: LlmCallWhereInput
    some?: LlmCallWhereInput
    none?: LlmCallWhereInput
  }

  export type ResumeListRelationFilter = {
    every?: ResumeWhereInput
    some?: ResumeWhereInput
    none?: ResumeWhereInput
  }

  export type GeneratedRoastListRelationFilter = {
    every?: GeneratedRoastWhereInput
    some?: GeneratedRoastWhereInput
    none?: GeneratedRoastWhereInput
  }

  export type GeneratedCoverLetterListRelationFilter = {
    every?: GeneratedCoverLetterWhereInput
    some?: GeneratedCoverLetterWhereInput
    none?: GeneratedCoverLetterWhereInput
  }

  export type GeneratedResumeListRelationFilter = {
    every?: GeneratedResumeWhereInput
    some?: GeneratedResumeWhereInput
    none?: GeneratedResumeWhereInput
  }

  export type GeneratedInterviewPrepListRelationFilter = {
    every?: GeneratedInterviewPrepWhereInput
    some?: GeneratedInterviewPrepWhereInput
    none?: GeneratedInterviewPrepWhereInput
  }

  export type InterviewEvaluationListRelationFilter = {
    every?: InterviewEvaluationWhereInput
    some?: InterviewEvaluationWhereInput
    none?: InterviewEvaluationWhereInput
  }

  export type SharedAnalysisListRelationFilter = {
    every?: SharedAnalysisWhereInput
    some?: SharedAnalysisWhereInput
    none?: SharedAnalysisWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type ChatbotListRelationFilter = {
    every?: ChatbotWhereInput
    some?: ChatbotWhereInput
    none?: ChatbotWhereInput
  }

  export type VerificationTokenListRelationFilter = {
    every?: VerificationTokenWhereInput
    some?: VerificationTokenWhereInput
    none?: VerificationTokenWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LlmCallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedRoastOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedCoverLetterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneratedInterviewPrepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatbotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionId?: SortOrder
    customerId?: SortOrder
    subscriptionEndsAt?: SortOrder
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
    lastRoastReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionId?: SortOrder
    customerId?: SortOrder
    subscriptionEndsAt?: SortOrder
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
    lastRoastReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    hashedPassword?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionId?: SortOrder
    customerId?: SortOrder
    subscriptionEndsAt?: SortOrder
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
    lastRoastReset?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    monthlyRoasts?: SortOrder
    totalRoasts?: SortOrder
    bonusCredits?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVerificationTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationTokenType | EnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTokenTypeFilter<$PrismaModel> | $Enums.VerificationTokenType
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    usedAt?: SortOrder
  }

  export type EnumVerificationTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationTokenType | EnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.VerificationTokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumVerificationTokenTypeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumLlmCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LlmCallStatus | EnumLlmCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLlmCallStatusFilter<$PrismaModel> | $Enums.LlmCallStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ResumeNullableScalarRelationFilter = {
    is?: ResumeWhereInput | null
    isNot?: ResumeWhereInput | null
  }

  export type ExtractedResumeNullableScalarRelationFilter = {
    is?: ExtractedResumeWhereInput | null
    isNot?: ExtractedResumeWhereInput | null
  }

  export type ExtractedJobDescriptionNullableScalarRelationFilter = {
    is?: ExtractedJobDescriptionWhereInput | null
    isNot?: ExtractedJobDescriptionWhereInput | null
  }

  export type GeneratedRoastNullableScalarRelationFilter = {
    is?: GeneratedRoastWhereInput | null
    isNot?: GeneratedRoastWhereInput | null
  }

  export type GeneratedCoverLetterNullableScalarRelationFilter = {
    is?: GeneratedCoverLetterWhereInput | null
    isNot?: GeneratedCoverLetterWhereInput | null
  }

  export type GeneratedResumeNullableScalarRelationFilter = {
    is?: GeneratedResumeWhereInput | null
    isNot?: GeneratedResumeWhereInput | null
  }

  export type GeneratedInterviewPrepNullableScalarRelationFilter = {
    is?: GeneratedInterviewPrepWhereInput | null
    isNot?: GeneratedInterviewPrepWhereInput | null
  }

  export type LlmMessageListRelationFilter = {
    every?: LlmMessageWhereInput
    some?: LlmMessageWhereInput
    none?: LlmMessageWhereInput
  }

  export type LlmMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LlmCallCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    resumeId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    generatedRoastId?: SortOrder
    generatedCoverLetterId?: SortOrder
    generatedResumeId?: SortOrder
    generatedInterviewPrepId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type LlmCallAvgOrderByAggregateInput = {
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrder
  }

  export type LlmCallMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    resumeId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    generatedRoastId?: SortOrder
    generatedCoverLetterId?: SortOrder
    generatedResumeId?: SortOrder
    generatedInterviewPrepId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type LlmCallMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    operationType?: SortOrder
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrder
    status?: SortOrder
    errorMessage?: SortOrder
    resumeId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    generatedRoastId?: SortOrder
    generatedCoverLetterId?: SortOrder
    generatedResumeId?: SortOrder
    generatedInterviewPrepId?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type LlmCallSumOrderByAggregateInput = {
    totalInputTokens?: SortOrder
    totalOutputTokens?: SortOrder
    totalTokens?: SortOrder
    totalCostUsd?: SortOrder
    totalProcessingTimeMs?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumLlmCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LlmCallStatus | EnumLlmCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLlmCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.LlmCallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLlmCallStatusFilter<$PrismaModel>
    _max?: NestedEnumLlmCallStatusFilter<$PrismaModel>
  }

  export type EnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LlmCallScalarRelationFilter = {
    is?: LlmCallWhereInput
    isNot?: LlmCallWhereInput
  }

  export type LlmMessageLlmCallIdMessageIndexCompoundUniqueInput = {
    llmCallId: string
    messageIndex: number
  }

  export type LlmMessageCountOrderByAggregateInput = {
    id?: SortOrder
    llmCallId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    finishReason?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type LlmMessageAvgOrderByAggregateInput = {
    messageIndex?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type LlmMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    llmCallId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    finishReason?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
  }

  export type LlmMessageMinOrderByAggregateInput = {
    id?: SortOrder
    llmCallId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    finishReason?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
    createdAt?: SortOrder
  }

  export type LlmMessageSumOrderByAggregateInput = {
    messageIndex?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    totalTokens?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    temperature?: SortOrder
    maxTokens?: SortOrder
  }

  export type EnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ExtractedResumeListRelationFilter = {
    every?: ExtractedResumeWhereInput
    some?: ExtractedResumeWhereInput
    none?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResumeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileHash?: SortOrder
    mimeType?: SortOrder
    images?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileHash?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type ResumeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    fileHash?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ResumeScalarRelationFilter = {
    is?: ResumeWhereInput
    isNot?: ResumeWhereInput
  }

  export type SummarizedResumeListRelationFilter = {
    every?: SummarizedResumeWhereInput
    some?: SummarizedResumeWhereInput
    none?: SummarizedResumeWhereInput
  }

  export type SummarizedResumeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExtractedResumeCountOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtractedResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtractedResumeMinOrderByAggregateInput = {
    id?: SortOrder
    resumeId?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SummarizedJobDescriptionListRelationFilter = {
    every?: SummarizedJobDescriptionWhereInput
    some?: SummarizedJobDescriptionWhereInput
    none?: SummarizedJobDescriptionWhereInput
  }

  export type SummarizedJobDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExtractedJobDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    contentHash?: SortOrder
    originalText?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtractedJobDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    contentHash?: SortOrder
    originalText?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtractedJobDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    contentHash?: SortOrder
    originalText?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtractedResumeScalarRelationFilter = {
    is?: ExtractedResumeWhereInput
    isNot?: ExtractedResumeWhereInput
  }

  export type SummarizedResumeCountOrderByAggregateInput = {
    id?: SortOrder
    extractedResumeId?: SortOrder
    contentHash?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type SummarizedResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    extractedResumeId?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type SummarizedResumeMinOrderByAggregateInput = {
    id?: SortOrder
    extractedResumeId?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtractedJobDescriptionScalarRelationFilter = {
    is?: ExtractedJobDescriptionWhereInput
    isNot?: ExtractedJobDescriptionWhereInput
  }

  export type SummarizedJobDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type SummarizedJobDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type SummarizedJobDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedRoastCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedRoastAvgOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type GeneratedRoastMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedRoastMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedRoastSumOrderByAggregateInput = {
    overallScore?: SortOrder
  }

  export type GeneratedCoverLetterCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    modelName?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedCoverLetterMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedCoverLetterMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    resumeId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    tone?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedResumeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    templateId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    data?: SortOrder
    atsScore?: SortOrder
    keywordsMatched?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedResumeAvgOrderByAggregateInput = {
    atsScore?: SortOrder
  }

  export type GeneratedResumeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    templateId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    atsScore?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedResumeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    templateId?: SortOrder
    contentHash?: SortOrder
    content?: SortOrder
    atsScore?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedResumeSumOrderByAggregateInput = {
    atsScore?: SortOrder
  }

  export type GeneratedInterviewPrepCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    data?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedInterviewPrepMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedInterviewPrepMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    extractedResumeId?: SortOrder
    extractedJobId?: SortOrder
    contentHash?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    modelName?: SortOrder
    createdAt?: SortOrder
  }

  export type GeneratedInterviewPrepScalarRelationFilter = {
    is?: GeneratedInterviewPrepWhereInput
    isNot?: GeneratedInterviewPrepWhereInput
  }

  export type InterviewEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    interviewPrepId?: SortOrder
    userId?: SortOrder
    evaluationType?: SortOrder
    data?: SortOrder
    questionsCount?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewEvaluationAvgOrderByAggregateInput = {
    questionsCount?: SortOrder
    overallScore?: SortOrder
  }

  export type InterviewEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    interviewPrepId?: SortOrder
    userId?: SortOrder
    evaluationType?: SortOrder
    questionsCount?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    interviewPrepId?: SortOrder
    userId?: SortOrder
    evaluationType?: SortOrder
    questionsCount?: SortOrder
    overallScore?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewEvaluationSumOrderByAggregateInput = {
    questionsCount?: SortOrder
    overallScore?: SortOrder
  }

  export type GeneratedRoastScalarRelationFilter = {
    is?: GeneratedRoastWhereInput
    isNot?: GeneratedRoastWhereInput
  }

  export type SharedAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    settings?: SortOrder
    viewCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedAnalysisAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type SharedAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    viewCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roastId?: SortOrder
    viewCount?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedAnalysisSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    stripeInvoiceId?: SortOrder
    stripePaymentId?: SortOrder
    itemCount?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
    itemCount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    stripeInvoiceId?: SortOrder
    stripePaymentId?: SortOrder
    itemCount?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    billingPeriodStart?: SortOrder
    billingPeriodEnd?: SortOrder
    stripeInvoiceId?: SortOrder
    stripePaymentId?: SortOrder
    itemCount?: SortOrder
    generatedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
    itemCount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumAnnouncementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeFilter<$PrismaModel> | $Enums.AnnouncementType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumSubscriptionTierNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel> | null
    has?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    hasSome?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    featureName?: SortOrder
    estimatedDate?: SortOrder
    type?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    targetTiers?: SortOrder
    dismissedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    featureName?: SortOrder
    estimatedDate?: SortOrder
    type?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    featureName?: SortOrder
    estimatedDate?: SortOrder
    type?: SortOrder
    ctaText?: SortOrder
    ctaUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnnouncementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ChatbotCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    conversationId?: SortOrder
    message?: SortOrder
    role?: SortOrder
    llmMessageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatbotMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    conversationId?: SortOrder
    message?: SortOrder
    role?: SortOrder
    llmMessageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatbotMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    anonymousId?: SortOrder
    conversationId?: SortOrder
    message?: SortOrder
    role?: SortOrder
    llmMessageId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMessageListRelationFilter = {
    every?: ConversationMessageWhereInput
    some?: ConversationMessageWhereInput
    none?: ConversationMessageWhereInput
  }

  export type ConversationMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    lastMessageAt?: SortOrder
    messageCount?: SortOrder
    selectedTemplate?: SortOrder
    selectedModel?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    messageCount?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    lastMessageAt?: SortOrder
    messageCount?: SortOrder
    selectedTemplate?: SortOrder
    selectedModel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    lastMessageAt?: SortOrder
    messageCount?: SortOrder
    selectedTemplate?: SortOrder
    selectedModel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    messageCount?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationMessageConversationIdMessageIndexCompoundUniqueInput = {
    conversationId: string
    messageIndex: number
  }

  export type ConversationMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    model?: SortOrder
    template?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    hasLatexCode?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMessageAvgOrderByAggregateInput = {
    messageIndex?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
  }

  export type ConversationMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    model?: SortOrder
    template?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    hasLatexCode?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    messageIndex?: SortOrder
    model?: SortOrder
    template?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
    hasLatexCode?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMessageSumOrderByAggregateInput = {
    messageIndex?: SortOrder
    tokensUsed?: SortOrder
    costUsd?: SortOrder
    processingTimeMs?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LlmCallCreateNestedManyWithoutUserInput = {
    create?: XOR<LlmCallCreateWithoutUserInput, LlmCallUncheckedCreateWithoutUserInput> | LlmCallCreateWithoutUserInput[] | LlmCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutUserInput | LlmCallCreateOrConnectWithoutUserInput[]
    createMany?: LlmCallCreateManyUserInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type ResumeCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
  }

  export type GeneratedRoastCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedRoastCreateWithoutUserInput, GeneratedRoastUncheckedCreateWithoutUserInput> | GeneratedRoastCreateWithoutUserInput[] | GeneratedRoastUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutUserInput | GeneratedRoastCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedRoastCreateManyUserInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutUserInput, GeneratedCoverLetterUncheckedCreateWithoutUserInput> | GeneratedCoverLetterCreateWithoutUserInput[] | GeneratedCoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutUserInput | GeneratedCoverLetterCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedCoverLetterCreateManyUserInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedResumeCreateWithoutUserInput, GeneratedResumeUncheckedCreateWithoutUserInput> | GeneratedResumeCreateWithoutUserInput[] | GeneratedResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutUserInput | GeneratedResumeCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedResumeCreateManyUserInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutUserInput, GeneratedInterviewPrepUncheckedCreateWithoutUserInput> | GeneratedInterviewPrepCreateWithoutUserInput[] | GeneratedInterviewPrepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutUserInput | GeneratedInterviewPrepCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedInterviewPrepCreateManyUserInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type InterviewEvaluationCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewEvaluationCreateWithoutUserInput, InterviewEvaluationUncheckedCreateWithoutUserInput> | InterviewEvaluationCreateWithoutUserInput[] | InterviewEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutUserInput | InterviewEvaluationCreateOrConnectWithoutUserInput[]
    createMany?: InterviewEvaluationCreateManyUserInputEnvelope
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
  }

  export type SharedAnalysisCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedAnalysisCreateWithoutUserInput, SharedAnalysisUncheckedCreateWithoutUserInput> | SharedAnalysisCreateWithoutUserInput[] | SharedAnalysisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutUserInput | SharedAnalysisCreateOrConnectWithoutUserInput[]
    createMany?: SharedAnalysisCreateManyUserInputEnvelope
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ChatbotCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatbotCreateWithoutUserInput, ChatbotUncheckedCreateWithoutUserInput> | ChatbotCreateWithoutUserInput[] | ChatbotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotCreateOrConnectWithoutUserInput | ChatbotCreateOrConnectWithoutUserInput[]
    createMany?: ChatbotCreateManyUserInputEnvelope
    connect?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
  }

  export type VerificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LlmCallCreateWithoutUserInput, LlmCallUncheckedCreateWithoutUserInput> | LlmCallCreateWithoutUserInput[] | LlmCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutUserInput | LlmCallCreateOrConnectWithoutUserInput[]
    createMany?: LlmCallCreateManyUserInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type ResumeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
  }

  export type GeneratedRoastUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedRoastCreateWithoutUserInput, GeneratedRoastUncheckedCreateWithoutUserInput> | GeneratedRoastCreateWithoutUserInput[] | GeneratedRoastUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutUserInput | GeneratedRoastCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedRoastCreateManyUserInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutUserInput, GeneratedCoverLetterUncheckedCreateWithoutUserInput> | GeneratedCoverLetterCreateWithoutUserInput[] | GeneratedCoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutUserInput | GeneratedCoverLetterCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedCoverLetterCreateManyUserInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedResumeCreateWithoutUserInput, GeneratedResumeUncheckedCreateWithoutUserInput> | GeneratedResumeCreateWithoutUserInput[] | GeneratedResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutUserInput | GeneratedResumeCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedResumeCreateManyUserInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutUserInput, GeneratedInterviewPrepUncheckedCreateWithoutUserInput> | GeneratedInterviewPrepCreateWithoutUserInput[] | GeneratedInterviewPrepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutUserInput | GeneratedInterviewPrepCreateOrConnectWithoutUserInput[]
    createMany?: GeneratedInterviewPrepCreateManyUserInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewEvaluationCreateWithoutUserInput, InterviewEvaluationUncheckedCreateWithoutUserInput> | InterviewEvaluationCreateWithoutUserInput[] | InterviewEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutUserInput | InterviewEvaluationCreateOrConnectWithoutUserInput[]
    createMany?: InterviewEvaluationCreateManyUserInputEnvelope
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
  }

  export type SharedAnalysisUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedAnalysisCreateWithoutUserInput, SharedAnalysisUncheckedCreateWithoutUserInput> | SharedAnalysisCreateWithoutUserInput[] | SharedAnalysisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutUserInput | SharedAnalysisCreateOrConnectWithoutUserInput[]
    createMany?: SharedAnalysisCreateManyUserInputEnvelope
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ChatbotUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatbotCreateWithoutUserInput, ChatbotUncheckedCreateWithoutUserInput> | ChatbotCreateWithoutUserInput[] | ChatbotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotCreateOrConnectWithoutUserInput | ChatbotCreateOrConnectWithoutUserInput[]
    createMany?: ChatbotCreateManyUserInputEnvelope
    connect?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
  }

  export type VerificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumSubscriptionTierFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionTier
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LlmCallUpdateManyWithoutUserNestedInput = {
    create?: XOR<LlmCallCreateWithoutUserInput, LlmCallUncheckedCreateWithoutUserInput> | LlmCallCreateWithoutUserInput[] | LlmCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutUserInput | LlmCallCreateOrConnectWithoutUserInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutUserInput | LlmCallUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LlmCallCreateManyUserInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutUserInput | LlmCallUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutUserInput | LlmCallUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type ResumeUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    upsert?: ResumeUpsertWithWhereUniqueWithoutUserInput | ResumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    set?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    disconnect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    delete?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    update?: ResumeUpdateWithWhereUniqueWithoutUserInput | ResumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeUpdateManyWithWhereWithoutUserInput | ResumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
  }

  export type GeneratedRoastUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutUserInput, GeneratedRoastUncheckedCreateWithoutUserInput> | GeneratedRoastCreateWithoutUserInput[] | GeneratedRoastUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutUserInput | GeneratedRoastCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutUserInput | GeneratedRoastUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedRoastCreateManyUserInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutUserInput | GeneratedRoastUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutUserInput | GeneratedRoastUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutUserInput, GeneratedCoverLetterUncheckedCreateWithoutUserInput> | GeneratedCoverLetterCreateWithoutUserInput[] | GeneratedCoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutUserInput | GeneratedCoverLetterCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutUserInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedCoverLetterCreateManyUserInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutUserInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutUserInput | GeneratedCoverLetterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutUserInput, GeneratedResumeUncheckedCreateWithoutUserInput> | GeneratedResumeCreateWithoutUserInput[] | GeneratedResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutUserInput | GeneratedResumeCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutUserInput | GeneratedResumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedResumeCreateManyUserInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutUserInput | GeneratedResumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutUserInput | GeneratedResumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutUserInput, GeneratedInterviewPrepUncheckedCreateWithoutUserInput> | GeneratedInterviewPrepCreateWithoutUserInput[] | GeneratedInterviewPrepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutUserInput | GeneratedInterviewPrepCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutUserInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedInterviewPrepCreateManyUserInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutUserInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutUserInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type InterviewEvaluationUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewEvaluationCreateWithoutUserInput, InterviewEvaluationUncheckedCreateWithoutUserInput> | InterviewEvaluationCreateWithoutUserInput[] | InterviewEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutUserInput | InterviewEvaluationCreateOrConnectWithoutUserInput[]
    upsert?: InterviewEvaluationUpsertWithWhereUniqueWithoutUserInput | InterviewEvaluationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewEvaluationCreateManyUserInputEnvelope
    set?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    disconnect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    delete?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    update?: InterviewEvaluationUpdateWithWhereUniqueWithoutUserInput | InterviewEvaluationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewEvaluationUpdateManyWithWhereWithoutUserInput | InterviewEvaluationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewEvaluationScalarWhereInput | InterviewEvaluationScalarWhereInput[]
  }

  export type SharedAnalysisUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedAnalysisCreateWithoutUserInput, SharedAnalysisUncheckedCreateWithoutUserInput> | SharedAnalysisCreateWithoutUserInput[] | SharedAnalysisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutUserInput | SharedAnalysisCreateOrConnectWithoutUserInput[]
    upsert?: SharedAnalysisUpsertWithWhereUniqueWithoutUserInput | SharedAnalysisUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedAnalysisCreateManyUserInputEnvelope
    set?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    disconnect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    delete?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    update?: SharedAnalysisUpdateWithWhereUniqueWithoutUserInput | SharedAnalysisUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedAnalysisUpdateManyWithWhereWithoutUserInput | SharedAnalysisUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedAnalysisScalarWhereInput | SharedAnalysisScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ChatbotUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatbotCreateWithoutUserInput, ChatbotUncheckedCreateWithoutUserInput> | ChatbotCreateWithoutUserInput[] | ChatbotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotCreateOrConnectWithoutUserInput | ChatbotCreateOrConnectWithoutUserInput[]
    upsert?: ChatbotUpsertWithWhereUniqueWithoutUserInput | ChatbotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatbotCreateManyUserInputEnvelope
    set?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    disconnect?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    delete?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    connect?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    update?: ChatbotUpdateWithWhereUniqueWithoutUserInput | ChatbotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatbotUpdateManyWithWhereWithoutUserInput | ChatbotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatbotScalarWhereInput | ChatbotScalarWhereInput[]
  }

  export type VerificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: VerificationTokenUpsertWithWhereUniqueWithoutUserInput | VerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    set?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    disconnect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    delete?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    update?: VerificationTokenUpdateWithWhereUniqueWithoutUserInput | VerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationTokenUpdateManyWithWhereWithoutUserInput | VerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LlmCallCreateWithoutUserInput, LlmCallUncheckedCreateWithoutUserInput> | LlmCallCreateWithoutUserInput[] | LlmCallUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutUserInput | LlmCallCreateOrConnectWithoutUserInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutUserInput | LlmCallUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LlmCallCreateManyUserInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutUserInput | LlmCallUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutUserInput | LlmCallUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type ResumeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput> | ResumeCreateWithoutUserInput[] | ResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ResumeCreateOrConnectWithoutUserInput | ResumeCreateOrConnectWithoutUserInput[]
    upsert?: ResumeUpsertWithWhereUniqueWithoutUserInput | ResumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ResumeCreateManyUserInputEnvelope
    set?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    disconnect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    delete?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    connect?: ResumeWhereUniqueInput | ResumeWhereUniqueInput[]
    update?: ResumeUpdateWithWhereUniqueWithoutUserInput | ResumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ResumeUpdateManyWithWhereWithoutUserInput | ResumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutUserInput, GeneratedRoastUncheckedCreateWithoutUserInput> | GeneratedRoastCreateWithoutUserInput[] | GeneratedRoastUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutUserInput | GeneratedRoastCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutUserInput | GeneratedRoastUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedRoastCreateManyUserInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutUserInput | GeneratedRoastUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutUserInput | GeneratedRoastUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutUserInput, GeneratedCoverLetterUncheckedCreateWithoutUserInput> | GeneratedCoverLetterCreateWithoutUserInput[] | GeneratedCoverLetterUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutUserInput | GeneratedCoverLetterCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutUserInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedCoverLetterCreateManyUserInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutUserInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutUserInput | GeneratedCoverLetterUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutUserInput, GeneratedResumeUncheckedCreateWithoutUserInput> | GeneratedResumeCreateWithoutUserInput[] | GeneratedResumeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutUserInput | GeneratedResumeCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutUserInput | GeneratedResumeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedResumeCreateManyUserInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutUserInput | GeneratedResumeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutUserInput | GeneratedResumeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutUserInput, GeneratedInterviewPrepUncheckedCreateWithoutUserInput> | GeneratedInterviewPrepCreateWithoutUserInput[] | GeneratedInterviewPrepUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutUserInput | GeneratedInterviewPrepCreateOrConnectWithoutUserInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutUserInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GeneratedInterviewPrepCreateManyUserInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutUserInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutUserInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewEvaluationCreateWithoutUserInput, InterviewEvaluationUncheckedCreateWithoutUserInput> | InterviewEvaluationCreateWithoutUserInput[] | InterviewEvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutUserInput | InterviewEvaluationCreateOrConnectWithoutUserInput[]
    upsert?: InterviewEvaluationUpsertWithWhereUniqueWithoutUserInput | InterviewEvaluationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewEvaluationCreateManyUserInputEnvelope
    set?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    disconnect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    delete?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    update?: InterviewEvaluationUpdateWithWhereUniqueWithoutUserInput | InterviewEvaluationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewEvaluationUpdateManyWithWhereWithoutUserInput | InterviewEvaluationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewEvaluationScalarWhereInput | InterviewEvaluationScalarWhereInput[]
  }

  export type SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedAnalysisCreateWithoutUserInput, SharedAnalysisUncheckedCreateWithoutUserInput> | SharedAnalysisCreateWithoutUserInput[] | SharedAnalysisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutUserInput | SharedAnalysisCreateOrConnectWithoutUserInput[]
    upsert?: SharedAnalysisUpsertWithWhereUniqueWithoutUserInput | SharedAnalysisUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedAnalysisCreateManyUserInputEnvelope
    set?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    disconnect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    delete?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    update?: SharedAnalysisUpdateWithWhereUniqueWithoutUserInput | SharedAnalysisUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedAnalysisUpdateManyWithWhereWithoutUserInput | SharedAnalysisUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedAnalysisScalarWhereInput | SharedAnalysisScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ChatbotUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatbotCreateWithoutUserInput, ChatbotUncheckedCreateWithoutUserInput> | ChatbotCreateWithoutUserInput[] | ChatbotUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatbotCreateOrConnectWithoutUserInput | ChatbotCreateOrConnectWithoutUserInput[]
    upsert?: ChatbotUpsertWithWhereUniqueWithoutUserInput | ChatbotUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatbotCreateManyUserInputEnvelope
    set?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    disconnect?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    delete?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    connect?: ChatbotWhereUniqueInput | ChatbotWhereUniqueInput[]
    update?: ChatbotUpdateWithWhereUniqueWithoutUserInput | ChatbotUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatbotUpdateManyWithWhereWithoutUserInput | ChatbotUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatbotScalarWhereInput | ChatbotScalarWhereInput[]
  }

  export type VerificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: VerificationTokenUpsertWithWhereUniqueWithoutUserInput | VerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    set?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    disconnect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    delete?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    update?: VerificationTokenUpdateWithWhereUniqueWithoutUserInput | VerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationTokenUpdateManyWithWhereWithoutUserInput | VerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutVerificationTokensInput = {
    create?: XOR<UserCreateWithoutVerificationTokensInput, UserUncheckedCreateWithoutVerificationTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationTokensInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVerificationTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.VerificationTokenType
  }

  export type UserUpdateOneRequiredWithoutVerificationTokensNestedInput = {
    create?: XOR<UserCreateWithoutVerificationTokensInput, UserUncheckedCreateWithoutVerificationTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutVerificationTokensInput
    upsert?: UserUpsertWithoutVerificationTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVerificationTokensInput, UserUpdateWithoutVerificationTokensInput>, UserUncheckedUpdateWithoutVerificationTokensInput>
  }

  export type UserCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<UserCreateWithoutLlmCallsInput, UserUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLlmCallsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<ResumeCreateWithoutLlmCallsInput, ResumeUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutLlmCallsInput
    connect?: ResumeWhereUniqueInput
  }

  export type ExtractedResumeCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<ExtractedResumeCreateWithoutLlmCallsInput, ExtractedResumeUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutLlmCallsInput
    connect?: ExtractedResumeWhereUniqueInput
  }

  export type ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutLlmCallsInput, ExtractedJobDescriptionUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutLlmCallsInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
  }

  export type GeneratedRoastCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<GeneratedRoastCreateWithoutLlmCallsInput, GeneratedRoastUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutLlmCallsInput
    connect?: GeneratedRoastWhereUniqueInput
  }

  export type GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutLlmCallsInput, GeneratedCoverLetterUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutLlmCallsInput
    connect?: GeneratedCoverLetterWhereUniqueInput
  }

  export type GeneratedResumeCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<GeneratedResumeCreateWithoutLlmCallsInput, GeneratedResumeUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutLlmCallsInput
    connect?: GeneratedResumeWhereUniqueInput
  }

  export type GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutLlmCallsInput, GeneratedInterviewPrepUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutLlmCallsInput
    connect?: GeneratedInterviewPrepWhereUniqueInput
  }

  export type LlmMessageCreateNestedManyWithoutLlmCallInput = {
    create?: XOR<LlmMessageCreateWithoutLlmCallInput, LlmMessageUncheckedCreateWithoutLlmCallInput> | LlmMessageCreateWithoutLlmCallInput[] | LlmMessageUncheckedCreateWithoutLlmCallInput[]
    connectOrCreate?: LlmMessageCreateOrConnectWithoutLlmCallInput | LlmMessageCreateOrConnectWithoutLlmCallInput[]
    createMany?: LlmMessageCreateManyLlmCallInputEnvelope
    connect?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
  }

  export type LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput = {
    create?: XOR<LlmMessageCreateWithoutLlmCallInput, LlmMessageUncheckedCreateWithoutLlmCallInput> | LlmMessageCreateWithoutLlmCallInput[] | LlmMessageUncheckedCreateWithoutLlmCallInput[]
    connectOrCreate?: LlmMessageCreateOrConnectWithoutLlmCallInput | LlmMessageCreateOrConnectWithoutLlmCallInput[]
    createMany?: LlmMessageCreateManyLlmCallInputEnvelope
    connect?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumLlmCallStatusFieldUpdateOperationsInput = {
    set?: $Enums.LlmCallStatus
  }

  export type UserUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<UserCreateWithoutLlmCallsInput, UserUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLlmCallsInput
    upsert?: UserUpsertWithoutLlmCallsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLlmCallsInput, UserUpdateWithoutLlmCallsInput>, UserUncheckedUpdateWithoutLlmCallsInput>
  }

  export type ResumeUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<ResumeCreateWithoutLlmCallsInput, ResumeUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutLlmCallsInput
    upsert?: ResumeUpsertWithoutLlmCallsInput
    disconnect?: ResumeWhereInput | boolean
    delete?: ResumeWhereInput | boolean
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutLlmCallsInput, ResumeUpdateWithoutLlmCallsInput>, ResumeUncheckedUpdateWithoutLlmCallsInput>
  }

  export type ExtractedResumeUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutLlmCallsInput, ExtractedResumeUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutLlmCallsInput
    upsert?: ExtractedResumeUpsertWithoutLlmCallsInput
    disconnect?: ExtractedResumeWhereInput | boolean
    delete?: ExtractedResumeWhereInput | boolean
    connect?: ExtractedResumeWhereUniqueInput
    update?: XOR<XOR<ExtractedResumeUpdateToOneWithWhereWithoutLlmCallsInput, ExtractedResumeUpdateWithoutLlmCallsInput>, ExtractedResumeUncheckedUpdateWithoutLlmCallsInput>
  }

  export type ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutLlmCallsInput, ExtractedJobDescriptionUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutLlmCallsInput
    upsert?: ExtractedJobDescriptionUpsertWithoutLlmCallsInput
    disconnect?: ExtractedJobDescriptionWhereInput | boolean
    delete?: ExtractedJobDescriptionWhereInput | boolean
    connect?: ExtractedJobDescriptionWhereUniqueInput
    update?: XOR<XOR<ExtractedJobDescriptionUpdateToOneWithWhereWithoutLlmCallsInput, ExtractedJobDescriptionUpdateWithoutLlmCallsInput>, ExtractedJobDescriptionUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedRoastUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutLlmCallsInput, GeneratedRoastUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutLlmCallsInput
    upsert?: GeneratedRoastUpsertWithoutLlmCallsInput
    disconnect?: GeneratedRoastWhereInput | boolean
    delete?: GeneratedRoastWhereInput | boolean
    connect?: GeneratedRoastWhereUniqueInput
    update?: XOR<XOR<GeneratedRoastUpdateToOneWithWhereWithoutLlmCallsInput, GeneratedRoastUpdateWithoutLlmCallsInput>, GeneratedRoastUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutLlmCallsInput, GeneratedCoverLetterUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutLlmCallsInput
    upsert?: GeneratedCoverLetterUpsertWithoutLlmCallsInput
    disconnect?: GeneratedCoverLetterWhereInput | boolean
    delete?: GeneratedCoverLetterWhereInput | boolean
    connect?: GeneratedCoverLetterWhereUniqueInput
    update?: XOR<XOR<GeneratedCoverLetterUpdateToOneWithWhereWithoutLlmCallsInput, GeneratedCoverLetterUpdateWithoutLlmCallsInput>, GeneratedCoverLetterUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedResumeUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutLlmCallsInput, GeneratedResumeUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutLlmCallsInput
    upsert?: GeneratedResumeUpsertWithoutLlmCallsInput
    disconnect?: GeneratedResumeWhereInput | boolean
    delete?: GeneratedResumeWhereInput | boolean
    connect?: GeneratedResumeWhereUniqueInput
    update?: XOR<XOR<GeneratedResumeUpdateToOneWithWhereWithoutLlmCallsInput, GeneratedResumeUpdateWithoutLlmCallsInput>, GeneratedResumeUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutLlmCallsInput, GeneratedInterviewPrepUncheckedCreateWithoutLlmCallsInput>
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutLlmCallsInput
    upsert?: GeneratedInterviewPrepUpsertWithoutLlmCallsInput
    disconnect?: GeneratedInterviewPrepWhereInput | boolean
    delete?: GeneratedInterviewPrepWhereInput | boolean
    connect?: GeneratedInterviewPrepWhereUniqueInput
    update?: XOR<XOR<GeneratedInterviewPrepUpdateToOneWithWhereWithoutLlmCallsInput, GeneratedInterviewPrepUpdateWithoutLlmCallsInput>, GeneratedInterviewPrepUncheckedUpdateWithoutLlmCallsInput>
  }

  export type LlmMessageUpdateManyWithoutLlmCallNestedInput = {
    create?: XOR<LlmMessageCreateWithoutLlmCallInput, LlmMessageUncheckedCreateWithoutLlmCallInput> | LlmMessageCreateWithoutLlmCallInput[] | LlmMessageUncheckedCreateWithoutLlmCallInput[]
    connectOrCreate?: LlmMessageCreateOrConnectWithoutLlmCallInput | LlmMessageCreateOrConnectWithoutLlmCallInput[]
    upsert?: LlmMessageUpsertWithWhereUniqueWithoutLlmCallInput | LlmMessageUpsertWithWhereUniqueWithoutLlmCallInput[]
    createMany?: LlmMessageCreateManyLlmCallInputEnvelope
    set?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    disconnect?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    delete?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    connect?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    update?: LlmMessageUpdateWithWhereUniqueWithoutLlmCallInput | LlmMessageUpdateWithWhereUniqueWithoutLlmCallInput[]
    updateMany?: LlmMessageUpdateManyWithWhereWithoutLlmCallInput | LlmMessageUpdateManyWithWhereWithoutLlmCallInput[]
    deleteMany?: LlmMessageScalarWhereInput | LlmMessageScalarWhereInput[]
  }

  export type LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput = {
    create?: XOR<LlmMessageCreateWithoutLlmCallInput, LlmMessageUncheckedCreateWithoutLlmCallInput> | LlmMessageCreateWithoutLlmCallInput[] | LlmMessageUncheckedCreateWithoutLlmCallInput[]
    connectOrCreate?: LlmMessageCreateOrConnectWithoutLlmCallInput | LlmMessageCreateOrConnectWithoutLlmCallInput[]
    upsert?: LlmMessageUpsertWithWhereUniqueWithoutLlmCallInput | LlmMessageUpsertWithWhereUniqueWithoutLlmCallInput[]
    createMany?: LlmMessageCreateManyLlmCallInputEnvelope
    set?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    disconnect?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    delete?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    connect?: LlmMessageWhereUniqueInput | LlmMessageWhereUniqueInput[]
    update?: LlmMessageUpdateWithWhereUniqueWithoutLlmCallInput | LlmMessageUpdateWithWhereUniqueWithoutLlmCallInput[]
    updateMany?: LlmMessageUpdateManyWithWhereWithoutLlmCallInput | LlmMessageUpdateManyWithWhereWithoutLlmCallInput[]
    deleteMany?: LlmMessageScalarWhereInput | LlmMessageScalarWhereInput[]
  }

  export type LlmCallCreateNestedOneWithoutMessagesInput = {
    create?: XOR<LlmCallCreateWithoutMessagesInput, LlmCallUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LlmCallCreateOrConnectWithoutMessagesInput
    connect?: LlmCallWhereUniqueInput
  }

  export type EnumMessageRoleFieldUpdateOperationsInput = {
    set?: $Enums.MessageRole
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type LlmCallUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<LlmCallCreateWithoutMessagesInput, LlmCallUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LlmCallCreateOrConnectWithoutMessagesInput
    upsert?: LlmCallUpsertWithoutMessagesInput
    connect?: LlmCallWhereUniqueInput
    update?: XOR<XOR<LlmCallUpdateToOneWithWhereWithoutMessagesInput, LlmCallUpdateWithoutMessagesInput>, LlmCallUncheckedUpdateWithoutMessagesInput>
  }

  export type ResumeCreateimagesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutResumesInput = {
    create?: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesInput
    connect?: UserWhereUniqueInput
  }

  export type LlmCallCreateNestedManyWithoutResumeInput = {
    create?: XOR<LlmCallCreateWithoutResumeInput, LlmCallUncheckedCreateWithoutResumeInput> | LlmCallCreateWithoutResumeInput[] | LlmCallUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutResumeInput | LlmCallCreateOrConnectWithoutResumeInput[]
    createMany?: LlmCallCreateManyResumeInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type ExtractedResumeCreateNestedManyWithoutResumeInput = {
    create?: XOR<ExtractedResumeCreateWithoutResumeInput, ExtractedResumeUncheckedCreateWithoutResumeInput> | ExtractedResumeCreateWithoutResumeInput[] | ExtractedResumeUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutResumeInput | ExtractedResumeCreateOrConnectWithoutResumeInput[]
    createMany?: ExtractedResumeCreateManyResumeInputEnvelope
    connect?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
  }

  export type GeneratedRoastCreateNestedManyWithoutResumeInput = {
    create?: XOR<GeneratedRoastCreateWithoutResumeInput, GeneratedRoastUncheckedCreateWithoutResumeInput> | GeneratedRoastCreateWithoutResumeInput[] | GeneratedRoastUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutResumeInput | GeneratedRoastCreateOrConnectWithoutResumeInput[]
    createMany?: GeneratedRoastCreateManyResumeInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterCreateNestedManyWithoutResumeInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutResumeInput, GeneratedCoverLetterUncheckedCreateWithoutResumeInput> | GeneratedCoverLetterCreateWithoutResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutResumeInput | GeneratedCoverLetterCreateOrConnectWithoutResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyResumeInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<LlmCallCreateWithoutResumeInput, LlmCallUncheckedCreateWithoutResumeInput> | LlmCallCreateWithoutResumeInput[] | LlmCallUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutResumeInput | LlmCallCreateOrConnectWithoutResumeInput[]
    createMany?: LlmCallCreateManyResumeInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type ExtractedResumeUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<ExtractedResumeCreateWithoutResumeInput, ExtractedResumeUncheckedCreateWithoutResumeInput> | ExtractedResumeCreateWithoutResumeInput[] | ExtractedResumeUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutResumeInput | ExtractedResumeCreateOrConnectWithoutResumeInput[]
    createMany?: ExtractedResumeCreateManyResumeInputEnvelope
    connect?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
  }

  export type GeneratedRoastUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<GeneratedRoastCreateWithoutResumeInput, GeneratedRoastUncheckedCreateWithoutResumeInput> | GeneratedRoastCreateWithoutResumeInput[] | GeneratedRoastUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutResumeInput | GeneratedRoastCreateOrConnectWithoutResumeInput[]
    createMany?: GeneratedRoastCreateManyResumeInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterUncheckedCreateNestedManyWithoutResumeInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutResumeInput, GeneratedCoverLetterUncheckedCreateWithoutResumeInput> | GeneratedCoverLetterCreateWithoutResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutResumeInput | GeneratedCoverLetterCreateOrConnectWithoutResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyResumeInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type ResumeUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutResumesNestedInput = {
    create?: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutResumesInput
    upsert?: UserUpsertWithoutResumesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResumesInput, UserUpdateWithoutResumesInput>, UserUncheckedUpdateWithoutResumesInput>
  }

  export type LlmCallUpdateManyWithoutResumeNestedInput = {
    create?: XOR<LlmCallCreateWithoutResumeInput, LlmCallUncheckedCreateWithoutResumeInput> | LlmCallCreateWithoutResumeInput[] | LlmCallUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutResumeInput | LlmCallCreateOrConnectWithoutResumeInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutResumeInput | LlmCallUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: LlmCallCreateManyResumeInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutResumeInput | LlmCallUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutResumeInput | LlmCallUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type ExtractedResumeUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutResumeInput, ExtractedResumeUncheckedCreateWithoutResumeInput> | ExtractedResumeCreateWithoutResumeInput[] | ExtractedResumeUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutResumeInput | ExtractedResumeCreateOrConnectWithoutResumeInput[]
    upsert?: ExtractedResumeUpsertWithWhereUniqueWithoutResumeInput | ExtractedResumeUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ExtractedResumeCreateManyResumeInputEnvelope
    set?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    disconnect?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    delete?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    connect?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    update?: ExtractedResumeUpdateWithWhereUniqueWithoutResumeInput | ExtractedResumeUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ExtractedResumeUpdateManyWithWhereWithoutResumeInput | ExtractedResumeUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ExtractedResumeScalarWhereInput | ExtractedResumeScalarWhereInput[]
  }

  export type GeneratedRoastUpdateManyWithoutResumeNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutResumeInput, GeneratedRoastUncheckedCreateWithoutResumeInput> | GeneratedRoastCreateWithoutResumeInput[] | GeneratedRoastUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutResumeInput | GeneratedRoastCreateOrConnectWithoutResumeInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutResumeInput | GeneratedRoastUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: GeneratedRoastCreateManyResumeInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutResumeInput | GeneratedRoastUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutResumeInput | GeneratedRoastUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUpdateManyWithoutResumeNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutResumeInput, GeneratedCoverLetterUncheckedCreateWithoutResumeInput> | GeneratedCoverLetterCreateWithoutResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutResumeInput | GeneratedCoverLetterCreateOrConnectWithoutResumeInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutResumeInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyResumeInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutResumeInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutResumeInput | GeneratedCoverLetterUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<LlmCallCreateWithoutResumeInput, LlmCallUncheckedCreateWithoutResumeInput> | LlmCallCreateWithoutResumeInput[] | LlmCallUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutResumeInput | LlmCallCreateOrConnectWithoutResumeInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutResumeInput | LlmCallUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: LlmCallCreateManyResumeInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutResumeInput | LlmCallUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutResumeInput | LlmCallUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type ExtractedResumeUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutResumeInput, ExtractedResumeUncheckedCreateWithoutResumeInput> | ExtractedResumeCreateWithoutResumeInput[] | ExtractedResumeUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutResumeInput | ExtractedResumeCreateOrConnectWithoutResumeInput[]
    upsert?: ExtractedResumeUpsertWithWhereUniqueWithoutResumeInput | ExtractedResumeUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: ExtractedResumeCreateManyResumeInputEnvelope
    set?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    disconnect?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    delete?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    connect?: ExtractedResumeWhereUniqueInput | ExtractedResumeWhereUniqueInput[]
    update?: ExtractedResumeUpdateWithWhereUniqueWithoutResumeInput | ExtractedResumeUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: ExtractedResumeUpdateManyWithWhereWithoutResumeInput | ExtractedResumeUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: ExtractedResumeScalarWhereInput | ExtractedResumeScalarWhereInput[]
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutResumeInput, GeneratedRoastUncheckedCreateWithoutResumeInput> | GeneratedRoastCreateWithoutResumeInput[] | GeneratedRoastUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutResumeInput | GeneratedRoastCreateOrConnectWithoutResumeInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutResumeInput | GeneratedRoastUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: GeneratedRoastCreateManyResumeInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutResumeInput | GeneratedRoastUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutResumeInput | GeneratedRoastUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutResumeNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutResumeInput, GeneratedCoverLetterUncheckedCreateWithoutResumeInput> | GeneratedCoverLetterCreateWithoutResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutResumeInput | GeneratedCoverLetterCreateOrConnectWithoutResumeInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutResumeInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyResumeInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutResumeInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutResumeInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutResumeInput | GeneratedCoverLetterUpdateManyWithWhereWithoutResumeInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type ResumeCreateNestedOneWithoutExtractedResumesInput = {
    create?: XOR<ResumeCreateWithoutExtractedResumesInput, ResumeUncheckedCreateWithoutExtractedResumesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutExtractedResumesInput
    connect?: ResumeWhereUniqueInput
  }

  export type LlmCallCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<LlmCallCreateWithoutExtractedResumeInput, LlmCallUncheckedCreateWithoutExtractedResumeInput> | LlmCallCreateWithoutExtractedResumeInput[] | LlmCallUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedResumeInput | LlmCallCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: LlmCallCreateManyExtractedResumeInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type SummarizedResumeCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<SummarizedResumeCreateWithoutExtractedResumeInput, SummarizedResumeUncheckedCreateWithoutExtractedResumeInput> | SummarizedResumeCreateWithoutExtractedResumeInput[] | SummarizedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: SummarizedResumeCreateOrConnectWithoutExtractedResumeInput | SummarizedResumeCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: SummarizedResumeCreateManyExtractedResumeInputEnvelope
    connect?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
  }

  export type GeneratedRoastCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedResumeInput, GeneratedRoastUncheckedCreateWithoutExtractedResumeInput> | GeneratedRoastCreateWithoutExtractedResumeInput[] | GeneratedRoastUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedResumeInput | GeneratedRoastCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedRoastCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput> | GeneratedCoverLetterCreateWithoutExtractedResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedResumeInput, GeneratedResumeUncheckedCreateWithoutExtractedResumeInput> | GeneratedResumeCreateWithoutExtractedResumeInput[] | GeneratedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedResumeInput | GeneratedResumeCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedResumeCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput> | GeneratedInterviewPrepCreateWithoutExtractedResumeInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<LlmCallCreateWithoutExtractedResumeInput, LlmCallUncheckedCreateWithoutExtractedResumeInput> | LlmCallCreateWithoutExtractedResumeInput[] | LlmCallUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedResumeInput | LlmCallCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: LlmCallCreateManyExtractedResumeInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<SummarizedResumeCreateWithoutExtractedResumeInput, SummarizedResumeUncheckedCreateWithoutExtractedResumeInput> | SummarizedResumeCreateWithoutExtractedResumeInput[] | SummarizedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: SummarizedResumeCreateOrConnectWithoutExtractedResumeInput | SummarizedResumeCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: SummarizedResumeCreateManyExtractedResumeInputEnvelope
    connect?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
  }

  export type GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedResumeInput, GeneratedRoastUncheckedCreateWithoutExtractedResumeInput> | GeneratedRoastCreateWithoutExtractedResumeInput[] | GeneratedRoastUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedResumeInput | GeneratedRoastCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedRoastCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput> | GeneratedCoverLetterCreateWithoutExtractedResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedResumeInput, GeneratedResumeUncheckedCreateWithoutExtractedResumeInput> | GeneratedResumeCreateWithoutExtractedResumeInput[] | GeneratedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedResumeInput | GeneratedResumeCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedResumeCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput> | GeneratedInterviewPrepCreateWithoutExtractedResumeInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedResumeInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput = {
    create?: XOR<ResumeCreateWithoutExtractedResumesInput, ResumeUncheckedCreateWithoutExtractedResumesInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutExtractedResumesInput
    upsert?: ResumeUpsertWithoutExtractedResumesInput
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutExtractedResumesInput, ResumeUpdateWithoutExtractedResumesInput>, ResumeUncheckedUpdateWithoutExtractedResumesInput>
  }

  export type LlmCallUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<LlmCallCreateWithoutExtractedResumeInput, LlmCallUncheckedCreateWithoutExtractedResumeInput> | LlmCallCreateWithoutExtractedResumeInput[] | LlmCallUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedResumeInput | LlmCallCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutExtractedResumeInput | LlmCallUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: LlmCallCreateManyExtractedResumeInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutExtractedResumeInput | LlmCallUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutExtractedResumeInput | LlmCallUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<SummarizedResumeCreateWithoutExtractedResumeInput, SummarizedResumeUncheckedCreateWithoutExtractedResumeInput> | SummarizedResumeCreateWithoutExtractedResumeInput[] | SummarizedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: SummarizedResumeCreateOrConnectWithoutExtractedResumeInput | SummarizedResumeCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: SummarizedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput | SummarizedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: SummarizedResumeCreateManyExtractedResumeInputEnvelope
    set?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    disconnect?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    delete?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    connect?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    update?: SummarizedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput | SummarizedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: SummarizedResumeUpdateManyWithWhereWithoutExtractedResumeInput | SummarizedResumeUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: SummarizedResumeScalarWhereInput | SummarizedResumeScalarWhereInput[]
  }

  export type GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedResumeInput, GeneratedRoastUncheckedCreateWithoutExtractedResumeInput> | GeneratedRoastCreateWithoutExtractedResumeInput[] | GeneratedRoastUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedResumeInput | GeneratedRoastCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedRoastUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedRoastCreateManyExtractedResumeInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedRoastUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedRoastUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput> | GeneratedCoverLetterCreateWithoutExtractedResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedResumeInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedResumeInput, GeneratedResumeUncheckedCreateWithoutExtractedResumeInput> | GeneratedResumeCreateWithoutExtractedResumeInput[] | GeneratedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedResumeInput | GeneratedResumeCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedResumeCreateManyExtractedResumeInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedResumeUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput> | GeneratedInterviewPrepCreateWithoutExtractedResumeInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedResumeInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<LlmCallCreateWithoutExtractedResumeInput, LlmCallUncheckedCreateWithoutExtractedResumeInput> | LlmCallCreateWithoutExtractedResumeInput[] | LlmCallUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedResumeInput | LlmCallCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutExtractedResumeInput | LlmCallUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: LlmCallCreateManyExtractedResumeInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutExtractedResumeInput | LlmCallUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutExtractedResumeInput | LlmCallUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<SummarizedResumeCreateWithoutExtractedResumeInput, SummarizedResumeUncheckedCreateWithoutExtractedResumeInput> | SummarizedResumeCreateWithoutExtractedResumeInput[] | SummarizedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: SummarizedResumeCreateOrConnectWithoutExtractedResumeInput | SummarizedResumeCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: SummarizedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput | SummarizedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: SummarizedResumeCreateManyExtractedResumeInputEnvelope
    set?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    disconnect?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    delete?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    connect?: SummarizedResumeWhereUniqueInput | SummarizedResumeWhereUniqueInput[]
    update?: SummarizedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput | SummarizedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: SummarizedResumeUpdateManyWithWhereWithoutExtractedResumeInput | SummarizedResumeUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: SummarizedResumeScalarWhereInput | SummarizedResumeScalarWhereInput[]
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedResumeInput, GeneratedRoastUncheckedCreateWithoutExtractedResumeInput> | GeneratedRoastCreateWithoutExtractedResumeInput[] | GeneratedRoastUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedResumeInput | GeneratedRoastCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedRoastUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedRoastCreateManyExtractedResumeInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedRoastUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedRoastUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput> | GeneratedCoverLetterCreateWithoutExtractedResumeInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedResumeInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedResumeInput, GeneratedResumeUncheckedCreateWithoutExtractedResumeInput> | GeneratedResumeCreateWithoutExtractedResumeInput[] | GeneratedResumeUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedResumeInput | GeneratedResumeCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedResumeCreateManyExtractedResumeInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedResumeUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput> | GeneratedInterviewPrepCreateWithoutExtractedResumeInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedResumeInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedResumeInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedResumeInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedResumeInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedResumeInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedResumeInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedResumeInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type LlmCallCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<LlmCallCreateWithoutExtractedJobInput, LlmCallUncheckedCreateWithoutExtractedJobInput> | LlmCallCreateWithoutExtractedJobInput[] | LlmCallUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedJobInput | LlmCallCreateOrConnectWithoutExtractedJobInput[]
    createMany?: LlmCallCreateManyExtractedJobInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<SummarizedJobDescriptionCreateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput> | SummarizedJobDescriptionCreateWithoutExtractedJobInput[] | SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput | SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput[]
    createMany?: SummarizedJobDescriptionCreateManyExtractedJobInputEnvelope
    connect?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
  }

  export type GeneratedRoastCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedJobInput, GeneratedRoastUncheckedCreateWithoutExtractedJobInput> | GeneratedRoastCreateWithoutExtractedJobInput[] | GeneratedRoastUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedJobInput | GeneratedRoastCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedRoastCreateManyExtractedJobInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput> | GeneratedCoverLetterCreateWithoutExtractedJobInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedJobInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedJobInput, GeneratedResumeUncheckedCreateWithoutExtractedJobInput> | GeneratedResumeCreateWithoutExtractedJobInput[] | GeneratedResumeUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedJobInput | GeneratedResumeCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedResumeCreateManyExtractedJobInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput> | GeneratedInterviewPrepCreateWithoutExtractedJobInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedJobInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<LlmCallCreateWithoutExtractedJobInput, LlmCallUncheckedCreateWithoutExtractedJobInput> | LlmCallCreateWithoutExtractedJobInput[] | LlmCallUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedJobInput | LlmCallCreateOrConnectWithoutExtractedJobInput[]
    createMany?: LlmCallCreateManyExtractedJobInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<SummarizedJobDescriptionCreateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput> | SummarizedJobDescriptionCreateWithoutExtractedJobInput[] | SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput | SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput[]
    createMany?: SummarizedJobDescriptionCreateManyExtractedJobInputEnvelope
    connect?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
  }

  export type GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedJobInput, GeneratedRoastUncheckedCreateWithoutExtractedJobInput> | GeneratedRoastCreateWithoutExtractedJobInput[] | GeneratedRoastUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedJobInput | GeneratedRoastCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedRoastCreateManyExtractedJobInputEnvelope
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
  }

  export type GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput> | GeneratedCoverLetterCreateWithoutExtractedJobInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedJobInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedJobInput, GeneratedResumeUncheckedCreateWithoutExtractedJobInput> | GeneratedResumeCreateWithoutExtractedJobInput[] | GeneratedResumeUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedJobInput | GeneratedResumeCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedResumeCreateManyExtractedJobInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput> | GeneratedInterviewPrepCreateWithoutExtractedJobInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedJobInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type LlmCallUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<LlmCallCreateWithoutExtractedJobInput, LlmCallUncheckedCreateWithoutExtractedJobInput> | LlmCallCreateWithoutExtractedJobInput[] | LlmCallUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedJobInput | LlmCallCreateOrConnectWithoutExtractedJobInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutExtractedJobInput | LlmCallUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: LlmCallCreateManyExtractedJobInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutExtractedJobInput | LlmCallUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutExtractedJobInput | LlmCallUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<SummarizedJobDescriptionCreateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput> | SummarizedJobDescriptionCreateWithoutExtractedJobInput[] | SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput | SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput[]
    upsert?: SummarizedJobDescriptionUpsertWithWhereUniqueWithoutExtractedJobInput | SummarizedJobDescriptionUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: SummarizedJobDescriptionCreateManyExtractedJobInputEnvelope
    set?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    disconnect?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    delete?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    connect?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    update?: SummarizedJobDescriptionUpdateWithWhereUniqueWithoutExtractedJobInput | SummarizedJobDescriptionUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: SummarizedJobDescriptionUpdateManyWithWhereWithoutExtractedJobInput | SummarizedJobDescriptionUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: SummarizedJobDescriptionScalarWhereInput | SummarizedJobDescriptionScalarWhereInput[]
  }

  export type GeneratedRoastUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedJobInput, GeneratedRoastUncheckedCreateWithoutExtractedJobInput> | GeneratedRoastCreateWithoutExtractedJobInput[] | GeneratedRoastUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedJobInput | GeneratedRoastCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedRoastUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedRoastCreateManyExtractedJobInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedRoastUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutExtractedJobInput | GeneratedRoastUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput> | GeneratedCoverLetterCreateWithoutExtractedJobInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedJobInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedJobInput | GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedJobInput, GeneratedResumeUncheckedCreateWithoutExtractedJobInput> | GeneratedResumeCreateWithoutExtractedJobInput[] | GeneratedResumeUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedJobInput | GeneratedResumeCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedResumeUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedResumeCreateManyExtractedJobInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedResumeUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutExtractedJobInput | GeneratedResumeUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput> | GeneratedInterviewPrepCreateWithoutExtractedJobInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedJobInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedJobInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<LlmCallCreateWithoutExtractedJobInput, LlmCallUncheckedCreateWithoutExtractedJobInput> | LlmCallCreateWithoutExtractedJobInput[] | LlmCallUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutExtractedJobInput | LlmCallCreateOrConnectWithoutExtractedJobInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutExtractedJobInput | LlmCallUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: LlmCallCreateManyExtractedJobInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutExtractedJobInput | LlmCallUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutExtractedJobInput | LlmCallUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<SummarizedJobDescriptionCreateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput> | SummarizedJobDescriptionCreateWithoutExtractedJobInput[] | SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput | SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput[]
    upsert?: SummarizedJobDescriptionUpsertWithWhereUniqueWithoutExtractedJobInput | SummarizedJobDescriptionUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: SummarizedJobDescriptionCreateManyExtractedJobInputEnvelope
    set?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    disconnect?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    delete?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    connect?: SummarizedJobDescriptionWhereUniqueInput | SummarizedJobDescriptionWhereUniqueInput[]
    update?: SummarizedJobDescriptionUpdateWithWhereUniqueWithoutExtractedJobInput | SummarizedJobDescriptionUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: SummarizedJobDescriptionUpdateManyWithWhereWithoutExtractedJobInput | SummarizedJobDescriptionUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: SummarizedJobDescriptionScalarWhereInput | SummarizedJobDescriptionScalarWhereInput[]
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutExtractedJobInput, GeneratedRoastUncheckedCreateWithoutExtractedJobInput> | GeneratedRoastCreateWithoutExtractedJobInput[] | GeneratedRoastUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutExtractedJobInput | GeneratedRoastCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedRoastUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedRoastUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedRoastCreateManyExtractedJobInputEnvelope
    set?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    disconnect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    delete?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    connect?: GeneratedRoastWhereUniqueInput | GeneratedRoastWhereUniqueInput[]
    update?: GeneratedRoastUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedRoastUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedRoastUpdateManyWithWhereWithoutExtractedJobInput | GeneratedRoastUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput> | GeneratedCoverLetterCreateWithoutExtractedJobInput[] | GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput | GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedCoverLetterCreateManyExtractedJobInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedJobInput | GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutExtractedJobInput, GeneratedResumeUncheckedCreateWithoutExtractedJobInput> | GeneratedResumeCreateWithoutExtractedJobInput[] | GeneratedResumeUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutExtractedJobInput | GeneratedResumeCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedResumeUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedResumeCreateManyExtractedJobInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedResumeUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutExtractedJobInput | GeneratedResumeUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput> | GeneratedInterviewPrepCreateWithoutExtractedJobInput[] | GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput | GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedJobInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedJobInput[]
    createMany?: GeneratedInterviewPrepCreateManyExtractedJobInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedJobInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedJobInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedJobInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedJobInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type ExtractedResumeCreateNestedOneWithoutSummarizedResumesInput = {
    create?: XOR<ExtractedResumeCreateWithoutSummarizedResumesInput, ExtractedResumeUncheckedCreateWithoutSummarizedResumesInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutSummarizedResumesInput
    connect?: ExtractedResumeWhereUniqueInput
  }

  export type ExtractedResumeUpdateOneRequiredWithoutSummarizedResumesNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutSummarizedResumesInput, ExtractedResumeUncheckedCreateWithoutSummarizedResumesInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutSummarizedResumesInput
    upsert?: ExtractedResumeUpsertWithoutSummarizedResumesInput
    connect?: ExtractedResumeWhereUniqueInput
    update?: XOR<XOR<ExtractedResumeUpdateToOneWithWhereWithoutSummarizedResumesInput, ExtractedResumeUpdateWithoutSummarizedResumesInput>, ExtractedResumeUncheckedUpdateWithoutSummarizedResumesInput>
  }

  export type ExtractedJobDescriptionCreateNestedOneWithoutSummarizedJobDescriptionsInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUncheckedCreateWithoutSummarizedJobDescriptionsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutSummarizedJobDescriptionsInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
  }

  export type ExtractedJobDescriptionUpdateOneRequiredWithoutSummarizedJobDescriptionsNestedInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUncheckedCreateWithoutSummarizedJobDescriptionsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutSummarizedJobDescriptionsInput
    upsert?: ExtractedJobDescriptionUpsertWithoutSummarizedJobDescriptionsInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
    update?: XOR<XOR<ExtractedJobDescriptionUpdateToOneWithWhereWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUpdateWithoutSummarizedJobDescriptionsInput>, ExtractedJobDescriptionUncheckedUpdateWithoutSummarizedJobDescriptionsInput>
  }

  export type UserCreateNestedOneWithoutGeneratedRoastsInput = {
    create?: XOR<UserCreateWithoutGeneratedRoastsInput, UserUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedRoastsInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutGeneratedRoastsInput = {
    create?: XOR<ResumeCreateWithoutGeneratedRoastsInput, ResumeUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutGeneratedRoastsInput
    connect?: ResumeWhereUniqueInput
  }

  export type ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedRoastsInput, ExtractedResumeUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedRoastsInput
    connect?: ExtractedResumeWhereUniqueInput
  }

  export type ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedRoastsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedRoastsInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
  }

  export type LlmCallCreateNestedManyWithoutGeneratedRoastInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedRoastInput, LlmCallUncheckedCreateWithoutGeneratedRoastInput> | LlmCallCreateWithoutGeneratedRoastInput[] | LlmCallUncheckedCreateWithoutGeneratedRoastInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedRoastInput | LlmCallCreateOrConnectWithoutGeneratedRoastInput[]
    createMany?: LlmCallCreateManyGeneratedRoastInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type SharedAnalysisCreateNestedManyWithoutRoastInput = {
    create?: XOR<SharedAnalysisCreateWithoutRoastInput, SharedAnalysisUncheckedCreateWithoutRoastInput> | SharedAnalysisCreateWithoutRoastInput[] | SharedAnalysisUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutRoastInput | SharedAnalysisCreateOrConnectWithoutRoastInput[]
    createMany?: SharedAnalysisCreateManyRoastInputEnvelope
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
  }

  export type GeneratedCoverLetterCreateNestedManyWithoutRoastInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutRoastInput, GeneratedCoverLetterUncheckedCreateWithoutRoastInput> | GeneratedCoverLetterCreateWithoutRoastInput[] | GeneratedCoverLetterUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutRoastInput | GeneratedCoverLetterCreateOrConnectWithoutRoastInput[]
    createMany?: GeneratedCoverLetterCreateManyRoastInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeCreateNestedManyWithoutRoastInput = {
    create?: XOR<GeneratedResumeCreateWithoutRoastInput, GeneratedResumeUncheckedCreateWithoutRoastInput> | GeneratedResumeCreateWithoutRoastInput[] | GeneratedResumeUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutRoastInput | GeneratedResumeCreateOrConnectWithoutRoastInput[]
    createMany?: GeneratedResumeCreateManyRoastInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepCreateNestedManyWithoutRoastInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutRoastInput, GeneratedInterviewPrepUncheckedCreateWithoutRoastInput> | GeneratedInterviewPrepCreateWithoutRoastInput[] | GeneratedInterviewPrepUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutRoastInput | GeneratedInterviewPrepCreateOrConnectWithoutRoastInput[]
    createMany?: GeneratedInterviewPrepCreateManyRoastInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedRoastInput, LlmCallUncheckedCreateWithoutGeneratedRoastInput> | LlmCallCreateWithoutGeneratedRoastInput[] | LlmCallUncheckedCreateWithoutGeneratedRoastInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedRoastInput | LlmCallCreateOrConnectWithoutGeneratedRoastInput[]
    createMany?: LlmCallCreateManyGeneratedRoastInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput = {
    create?: XOR<SharedAnalysisCreateWithoutRoastInput, SharedAnalysisUncheckedCreateWithoutRoastInput> | SharedAnalysisCreateWithoutRoastInput[] | SharedAnalysisUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutRoastInput | SharedAnalysisCreateOrConnectWithoutRoastInput[]
    createMany?: SharedAnalysisCreateManyRoastInputEnvelope
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
  }

  export type GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutRoastInput, GeneratedCoverLetterUncheckedCreateWithoutRoastInput> | GeneratedCoverLetterCreateWithoutRoastInput[] | GeneratedCoverLetterUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutRoastInput | GeneratedCoverLetterCreateOrConnectWithoutRoastInput[]
    createMany?: GeneratedCoverLetterCreateManyRoastInputEnvelope
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
  }

  export type GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput = {
    create?: XOR<GeneratedResumeCreateWithoutRoastInput, GeneratedResumeUncheckedCreateWithoutRoastInput> | GeneratedResumeCreateWithoutRoastInput[] | GeneratedResumeUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutRoastInput | GeneratedResumeCreateOrConnectWithoutRoastInput[]
    createMany?: GeneratedResumeCreateManyRoastInputEnvelope
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
  }

  export type GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutRoastInput, GeneratedInterviewPrepUncheckedCreateWithoutRoastInput> | GeneratedInterviewPrepCreateWithoutRoastInput[] | GeneratedInterviewPrepUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutRoastInput | GeneratedInterviewPrepCreateOrConnectWithoutRoastInput[]
    createMany?: GeneratedInterviewPrepCreateManyRoastInputEnvelope
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutGeneratedRoastsNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedRoastsInput, UserUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedRoastsInput
    upsert?: UserUpsertWithoutGeneratedRoastsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedRoastsInput, UserUpdateWithoutGeneratedRoastsInput>, UserUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type ResumeUpdateOneWithoutGeneratedRoastsNestedInput = {
    create?: XOR<ResumeCreateWithoutGeneratedRoastsInput, ResumeUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutGeneratedRoastsInput
    upsert?: ResumeUpsertWithoutGeneratedRoastsInput
    disconnect?: ResumeWhereInput | boolean
    delete?: ResumeWhereInput | boolean
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutGeneratedRoastsInput, ResumeUpdateWithoutGeneratedRoastsInput>, ResumeUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedRoastsInput, ExtractedResumeUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedRoastsInput
    upsert?: ExtractedResumeUpsertWithoutGeneratedRoastsInput
    disconnect?: ExtractedResumeWhereInput | boolean
    delete?: ExtractedResumeWhereInput | boolean
    connect?: ExtractedResumeWhereUniqueInput
    update?: XOR<XOR<ExtractedResumeUpdateToOneWithWhereWithoutGeneratedRoastsInput, ExtractedResumeUpdateWithoutGeneratedRoastsInput>, ExtractedResumeUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedRoastsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedRoastsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedRoastsInput
    upsert?: ExtractedJobDescriptionUpsertWithoutGeneratedRoastsInput
    disconnect?: ExtractedJobDescriptionWhereInput | boolean
    delete?: ExtractedJobDescriptionWhereInput | boolean
    connect?: ExtractedJobDescriptionWhereUniqueInput
    update?: XOR<XOR<ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedRoastsInput, ExtractedJobDescriptionUpdateWithoutGeneratedRoastsInput>, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type LlmCallUpdateManyWithoutGeneratedRoastNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedRoastInput, LlmCallUncheckedCreateWithoutGeneratedRoastInput> | LlmCallCreateWithoutGeneratedRoastInput[] | LlmCallUncheckedCreateWithoutGeneratedRoastInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedRoastInput | LlmCallCreateOrConnectWithoutGeneratedRoastInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedRoastInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedRoastInput[]
    createMany?: LlmCallCreateManyGeneratedRoastInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedRoastInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedRoastInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedRoastInput | LlmCallUpdateManyWithWhereWithoutGeneratedRoastInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type SharedAnalysisUpdateManyWithoutRoastNestedInput = {
    create?: XOR<SharedAnalysisCreateWithoutRoastInput, SharedAnalysisUncheckedCreateWithoutRoastInput> | SharedAnalysisCreateWithoutRoastInput[] | SharedAnalysisUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutRoastInput | SharedAnalysisCreateOrConnectWithoutRoastInput[]
    upsert?: SharedAnalysisUpsertWithWhereUniqueWithoutRoastInput | SharedAnalysisUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: SharedAnalysisCreateManyRoastInputEnvelope
    set?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    disconnect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    delete?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    update?: SharedAnalysisUpdateWithWhereUniqueWithoutRoastInput | SharedAnalysisUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: SharedAnalysisUpdateManyWithWhereWithoutRoastInput | SharedAnalysisUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: SharedAnalysisScalarWhereInput | SharedAnalysisScalarWhereInput[]
  }

  export type GeneratedCoverLetterUpdateManyWithoutRoastNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutRoastInput, GeneratedCoverLetterUncheckedCreateWithoutRoastInput> | GeneratedCoverLetterCreateWithoutRoastInput[] | GeneratedCoverLetterUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutRoastInput | GeneratedCoverLetterCreateOrConnectWithoutRoastInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutRoastInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: GeneratedCoverLetterCreateManyRoastInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutRoastInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutRoastInput | GeneratedCoverLetterUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUpdateManyWithoutRoastNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutRoastInput, GeneratedResumeUncheckedCreateWithoutRoastInput> | GeneratedResumeCreateWithoutRoastInput[] | GeneratedResumeUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutRoastInput | GeneratedResumeCreateOrConnectWithoutRoastInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutRoastInput | GeneratedResumeUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: GeneratedResumeCreateManyRoastInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutRoastInput | GeneratedResumeUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutRoastInput | GeneratedResumeUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutRoastInput, GeneratedInterviewPrepUncheckedCreateWithoutRoastInput> | GeneratedInterviewPrepCreateWithoutRoastInput[] | GeneratedInterviewPrepUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutRoastInput | GeneratedInterviewPrepCreateOrConnectWithoutRoastInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutRoastInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: GeneratedInterviewPrepCreateManyRoastInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutRoastInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutRoastInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedRoastInput, LlmCallUncheckedCreateWithoutGeneratedRoastInput> | LlmCallCreateWithoutGeneratedRoastInput[] | LlmCallUncheckedCreateWithoutGeneratedRoastInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedRoastInput | LlmCallCreateOrConnectWithoutGeneratedRoastInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedRoastInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedRoastInput[]
    createMany?: LlmCallCreateManyGeneratedRoastInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedRoastInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedRoastInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedRoastInput | LlmCallUpdateManyWithWhereWithoutGeneratedRoastInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput = {
    create?: XOR<SharedAnalysisCreateWithoutRoastInput, SharedAnalysisUncheckedCreateWithoutRoastInput> | SharedAnalysisCreateWithoutRoastInput[] | SharedAnalysisUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: SharedAnalysisCreateOrConnectWithoutRoastInput | SharedAnalysisCreateOrConnectWithoutRoastInput[]
    upsert?: SharedAnalysisUpsertWithWhereUniqueWithoutRoastInput | SharedAnalysisUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: SharedAnalysisCreateManyRoastInputEnvelope
    set?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    disconnect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    delete?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    connect?: SharedAnalysisWhereUniqueInput | SharedAnalysisWhereUniqueInput[]
    update?: SharedAnalysisUpdateWithWhereUniqueWithoutRoastInput | SharedAnalysisUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: SharedAnalysisUpdateManyWithWhereWithoutRoastInput | SharedAnalysisUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: SharedAnalysisScalarWhereInput | SharedAnalysisScalarWhereInput[]
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput = {
    create?: XOR<GeneratedCoverLetterCreateWithoutRoastInput, GeneratedCoverLetterUncheckedCreateWithoutRoastInput> | GeneratedCoverLetterCreateWithoutRoastInput[] | GeneratedCoverLetterUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedCoverLetterCreateOrConnectWithoutRoastInput | GeneratedCoverLetterCreateOrConnectWithoutRoastInput[]
    upsert?: GeneratedCoverLetterUpsertWithWhereUniqueWithoutRoastInput | GeneratedCoverLetterUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: GeneratedCoverLetterCreateManyRoastInputEnvelope
    set?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    disconnect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    delete?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    connect?: GeneratedCoverLetterWhereUniqueInput | GeneratedCoverLetterWhereUniqueInput[]
    update?: GeneratedCoverLetterUpdateWithWhereUniqueWithoutRoastInput | GeneratedCoverLetterUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: GeneratedCoverLetterUpdateManyWithWhereWithoutRoastInput | GeneratedCoverLetterUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput = {
    create?: XOR<GeneratedResumeCreateWithoutRoastInput, GeneratedResumeUncheckedCreateWithoutRoastInput> | GeneratedResumeCreateWithoutRoastInput[] | GeneratedResumeUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedResumeCreateOrConnectWithoutRoastInput | GeneratedResumeCreateOrConnectWithoutRoastInput[]
    upsert?: GeneratedResumeUpsertWithWhereUniqueWithoutRoastInput | GeneratedResumeUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: GeneratedResumeCreateManyRoastInputEnvelope
    set?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    disconnect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    delete?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    connect?: GeneratedResumeWhereUniqueInput | GeneratedResumeWhereUniqueInput[]
    update?: GeneratedResumeUpdateWithWhereUniqueWithoutRoastInput | GeneratedResumeUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: GeneratedResumeUpdateManyWithWhereWithoutRoastInput | GeneratedResumeUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutRoastInput, GeneratedInterviewPrepUncheckedCreateWithoutRoastInput> | GeneratedInterviewPrepCreateWithoutRoastInput[] | GeneratedInterviewPrepUncheckedCreateWithoutRoastInput[]
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutRoastInput | GeneratedInterviewPrepCreateOrConnectWithoutRoastInput[]
    upsert?: GeneratedInterviewPrepUpsertWithWhereUniqueWithoutRoastInput | GeneratedInterviewPrepUpsertWithWhereUniqueWithoutRoastInput[]
    createMany?: GeneratedInterviewPrepCreateManyRoastInputEnvelope
    set?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    disconnect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    delete?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    connect?: GeneratedInterviewPrepWhereUniqueInput | GeneratedInterviewPrepWhereUniqueInput[]
    update?: GeneratedInterviewPrepUpdateWithWhereUniqueWithoutRoastInput | GeneratedInterviewPrepUpdateWithWhereUniqueWithoutRoastInput[]
    updateMany?: GeneratedInterviewPrepUpdateManyWithWhereWithoutRoastInput | GeneratedInterviewPrepUpdateManyWithWhereWithoutRoastInput[]
    deleteMany?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGeneratedCoverLettersInput = {
    create?: XOR<UserCreateWithoutGeneratedCoverLettersInput, UserUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedCoverLettersInput
    connect?: UserWhereUniqueInput
  }

  export type ResumeCreateNestedOneWithoutGeneratedCoverLettersInput = {
    create?: XOR<ResumeCreateWithoutGeneratedCoverLettersInput, ResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutGeneratedCoverLettersInput
    connect?: ResumeWhereUniqueInput
  }

  export type GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput = {
    create?: XOR<GeneratedRoastCreateWithoutGeneratedCoverLettersInput, GeneratedRoastUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutGeneratedCoverLettersInput
    connect?: GeneratedRoastWhereUniqueInput
  }

  export type ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedCoverLettersInput, ExtractedResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedCoverLettersInput
    connect?: ExtractedResumeWhereUniqueInput
  }

  export type ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedCoverLettersInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
  }

  export type LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedCoverLetterInput, LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput> | LlmCallCreateWithoutGeneratedCoverLetterInput[] | LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput | LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput[]
    createMany?: LlmCallCreateManyGeneratedCoverLetterInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedCoverLetterInput, LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput> | LlmCallCreateWithoutGeneratedCoverLetterInput[] | LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput | LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput[]
    createMany?: LlmCallCreateManyGeneratedCoverLetterInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutGeneratedCoverLettersNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedCoverLettersInput, UserUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedCoverLettersInput
    upsert?: UserUpsertWithoutGeneratedCoverLettersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedCoverLettersInput, UserUpdateWithoutGeneratedCoverLettersInput>, UserUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput = {
    create?: XOR<ResumeCreateWithoutGeneratedCoverLettersInput, ResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: ResumeCreateOrConnectWithoutGeneratedCoverLettersInput
    upsert?: ResumeUpsertWithoutGeneratedCoverLettersInput
    disconnect?: ResumeWhereInput | boolean
    delete?: ResumeWhereInput | boolean
    connect?: ResumeWhereUniqueInput
    update?: XOR<XOR<ResumeUpdateToOneWithWhereWithoutGeneratedCoverLettersInput, ResumeUpdateWithoutGeneratedCoverLettersInput>, ResumeUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutGeneratedCoverLettersInput, GeneratedRoastUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutGeneratedCoverLettersInput
    upsert?: GeneratedRoastUpsertWithoutGeneratedCoverLettersInput
    disconnect?: GeneratedRoastWhereInput | boolean
    delete?: GeneratedRoastWhereInput | boolean
    connect?: GeneratedRoastWhereUniqueInput
    update?: XOR<XOR<GeneratedRoastUpdateToOneWithWhereWithoutGeneratedCoverLettersInput, GeneratedRoastUpdateWithoutGeneratedCoverLettersInput>, GeneratedRoastUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedCoverLettersInput, ExtractedResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedCoverLettersInput
    upsert?: ExtractedResumeUpsertWithoutGeneratedCoverLettersInput
    disconnect?: ExtractedResumeWhereInput | boolean
    delete?: ExtractedResumeWhereInput | boolean
    connect?: ExtractedResumeWhereUniqueInput
    update?: XOR<XOR<ExtractedResumeUpdateToOneWithWhereWithoutGeneratedCoverLettersInput, ExtractedResumeUpdateWithoutGeneratedCoverLettersInput>, ExtractedResumeUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedCoverLettersInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedCoverLettersInput
    upsert?: ExtractedJobDescriptionUpsertWithoutGeneratedCoverLettersInput
    disconnect?: ExtractedJobDescriptionWhereInput | boolean
    delete?: ExtractedJobDescriptionWhereInput | boolean
    connect?: ExtractedJobDescriptionWhereUniqueInput
    update?: XOR<XOR<ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUpdateWithoutGeneratedCoverLettersInput>, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedCoverLetterInput, LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput> | LlmCallCreateWithoutGeneratedCoverLetterInput[] | LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput | LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedCoverLetterInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedCoverLetterInput[]
    createMany?: LlmCallCreateManyGeneratedCoverLetterInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedCoverLetterInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedCoverLetterInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedCoverLetterInput | LlmCallUpdateManyWithWhereWithoutGeneratedCoverLetterInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedCoverLetterInput, LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput> | LlmCallCreateWithoutGeneratedCoverLetterInput[] | LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput | LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedCoverLetterInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedCoverLetterInput[]
    createMany?: LlmCallCreateManyGeneratedCoverLetterInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedCoverLetterInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedCoverLetterInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedCoverLetterInput | LlmCallUpdateManyWithWhereWithoutGeneratedCoverLetterInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type GeneratedResumeCreatekeywordsMatchedInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutGeneratedResumesInput = {
    create?: XOR<UserCreateWithoutGeneratedResumesInput, UserUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedResumesInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedRoastCreateNestedOneWithoutGeneratedResumesInput = {
    create?: XOR<GeneratedRoastCreateWithoutGeneratedResumesInput, GeneratedRoastUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutGeneratedResumesInput
    connect?: GeneratedRoastWhereUniqueInput
  }

  export type ExtractedResumeCreateNestedOneWithoutGeneratedResumesInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedResumesInput, ExtractedResumeUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedResumesInput
    connect?: ExtractedResumeWhereUniqueInput
  }

  export type ExtractedJobDescriptionCreateNestedOneWithoutGeneratedResumesInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedResumesInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedResumesInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
  }

  export type LlmCallCreateNestedManyWithoutGeneratedResumeInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedResumeInput, LlmCallUncheckedCreateWithoutGeneratedResumeInput> | LlmCallCreateWithoutGeneratedResumeInput[] | LlmCallUncheckedCreateWithoutGeneratedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedResumeInput | LlmCallCreateOrConnectWithoutGeneratedResumeInput[]
    createMany?: LlmCallCreateManyGeneratedResumeInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutGeneratedResumeInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedResumeInput, LlmCallUncheckedCreateWithoutGeneratedResumeInput> | LlmCallCreateWithoutGeneratedResumeInput[] | LlmCallUncheckedCreateWithoutGeneratedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedResumeInput | LlmCallCreateOrConnectWithoutGeneratedResumeInput[]
    createMany?: LlmCallCreateManyGeneratedResumeInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type GeneratedResumeUpdatekeywordsMatchedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneWithoutGeneratedResumesNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedResumesInput, UserUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedResumesInput
    upsert?: UserUpsertWithoutGeneratedResumesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedResumesInput, UserUpdateWithoutGeneratedResumesInput>, UserUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type GeneratedRoastUpdateOneWithoutGeneratedResumesNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutGeneratedResumesInput, GeneratedRoastUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutGeneratedResumesInput
    upsert?: GeneratedRoastUpsertWithoutGeneratedResumesInput
    disconnect?: GeneratedRoastWhereInput | boolean
    delete?: GeneratedRoastWhereInput | boolean
    connect?: GeneratedRoastWhereUniqueInput
    update?: XOR<XOR<GeneratedRoastUpdateToOneWithWhereWithoutGeneratedResumesInput, GeneratedRoastUpdateWithoutGeneratedResumesInput>, GeneratedRoastUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type ExtractedResumeUpdateOneWithoutGeneratedResumesNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedResumesInput, ExtractedResumeUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedResumesInput
    upsert?: ExtractedResumeUpsertWithoutGeneratedResumesInput
    disconnect?: ExtractedResumeWhereInput | boolean
    delete?: ExtractedResumeWhereInput | boolean
    connect?: ExtractedResumeWhereUniqueInput
    update?: XOR<XOR<ExtractedResumeUpdateToOneWithWhereWithoutGeneratedResumesInput, ExtractedResumeUpdateWithoutGeneratedResumesInput>, ExtractedResumeUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type ExtractedJobDescriptionUpdateOneWithoutGeneratedResumesNestedInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedResumesInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedResumesInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedResumesInput
    upsert?: ExtractedJobDescriptionUpsertWithoutGeneratedResumesInput
    disconnect?: ExtractedJobDescriptionWhereInput | boolean
    delete?: ExtractedJobDescriptionWhereInput | boolean
    connect?: ExtractedJobDescriptionWhereUniqueInput
    update?: XOR<XOR<ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedResumesInput, ExtractedJobDescriptionUpdateWithoutGeneratedResumesInput>, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type LlmCallUpdateManyWithoutGeneratedResumeNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedResumeInput, LlmCallUncheckedCreateWithoutGeneratedResumeInput> | LlmCallCreateWithoutGeneratedResumeInput[] | LlmCallUncheckedCreateWithoutGeneratedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedResumeInput | LlmCallCreateOrConnectWithoutGeneratedResumeInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedResumeInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedResumeInput[]
    createMany?: LlmCallCreateManyGeneratedResumeInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedResumeInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedResumeInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedResumeInput | LlmCallUpdateManyWithWhereWithoutGeneratedResumeInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedResumeNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedResumeInput, LlmCallUncheckedCreateWithoutGeneratedResumeInput> | LlmCallCreateWithoutGeneratedResumeInput[] | LlmCallUncheckedCreateWithoutGeneratedResumeInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedResumeInput | LlmCallCreateOrConnectWithoutGeneratedResumeInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedResumeInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedResumeInput[]
    createMany?: LlmCallCreateManyGeneratedResumeInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedResumeInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedResumeInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedResumeInput | LlmCallUpdateManyWithWhereWithoutGeneratedResumeInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutGeneratedInterviewPrepsInput = {
    create?: XOR<UserCreateWithoutGeneratedInterviewPrepsInput, UserUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedInterviewPrepsInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput = {
    create?: XOR<GeneratedRoastCreateWithoutGeneratedInterviewPrepsInput, GeneratedRoastUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutGeneratedInterviewPrepsInput
    connect?: GeneratedRoastWhereUniqueInput
  }

  export type ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedInterviewPrepsInput, ExtractedResumeUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedInterviewPrepsInput
    connect?: ExtractedResumeWhereUniqueInput
  }

  export type ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedInterviewPrepsInput
    connect?: ExtractedJobDescriptionWhereUniqueInput
  }

  export type LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput> | LlmCallCreateWithoutGeneratedInterviewPrepInput[] | LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput | LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput[]
    createMany?: LlmCallCreateManyGeneratedInterviewPrepInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewPrepInput, InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput> | InterviewEvaluationCreateWithoutInterviewPrepInput[] | InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput | InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput[]
    createMany?: InterviewEvaluationCreateManyInterviewPrepInputEnvelope
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
  }

  export type LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput> | LlmCallCreateWithoutGeneratedInterviewPrepInput[] | LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput | LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput[]
    createMany?: LlmCallCreateManyGeneratedInterviewPrepInputEnvelope
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
  }

  export type InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewPrepInput, InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput> | InterviewEvaluationCreateWithoutInterviewPrepInput[] | InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput | InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput[]
    createMany?: InterviewEvaluationCreateManyInterviewPrepInputEnvelope
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput = {
    create?: XOR<UserCreateWithoutGeneratedInterviewPrepsInput, UserUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGeneratedInterviewPrepsInput
    upsert?: UserUpsertWithoutGeneratedInterviewPrepsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput, UserUpdateWithoutGeneratedInterviewPrepsInput>, UserUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutGeneratedInterviewPrepsInput, GeneratedRoastUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutGeneratedInterviewPrepsInput
    upsert?: GeneratedRoastUpsertWithoutGeneratedInterviewPrepsInput
    disconnect?: GeneratedRoastWhereInput | boolean
    delete?: GeneratedRoastWhereInput | boolean
    connect?: GeneratedRoastWhereUniqueInput
    update?: XOR<XOR<GeneratedRoastUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput, GeneratedRoastUpdateWithoutGeneratedInterviewPrepsInput>, GeneratedRoastUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput = {
    create?: XOR<ExtractedResumeCreateWithoutGeneratedInterviewPrepsInput, ExtractedResumeUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: ExtractedResumeCreateOrConnectWithoutGeneratedInterviewPrepsInput
    upsert?: ExtractedResumeUpsertWithoutGeneratedInterviewPrepsInput
    disconnect?: ExtractedResumeWhereInput | boolean
    delete?: ExtractedResumeWhereInput | boolean
    connect?: ExtractedResumeWhereUniqueInput
    update?: XOR<XOR<ExtractedResumeUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput, ExtractedResumeUpdateWithoutGeneratedInterviewPrepsInput>, ExtractedResumeUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput = {
    create?: XOR<ExtractedJobDescriptionCreateWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    connectOrCreate?: ExtractedJobDescriptionCreateOrConnectWithoutGeneratedInterviewPrepsInput
    upsert?: ExtractedJobDescriptionUpsertWithoutGeneratedInterviewPrepsInput
    disconnect?: ExtractedJobDescriptionWhereInput | boolean
    delete?: ExtractedJobDescriptionWhereInput | boolean
    connect?: ExtractedJobDescriptionWhereUniqueInput
    update?: XOR<XOR<ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUpdateWithoutGeneratedInterviewPrepsInput>, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput> | LlmCallCreateWithoutGeneratedInterviewPrepInput[] | LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput | LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedInterviewPrepInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedInterviewPrepInput[]
    createMany?: LlmCallCreateManyGeneratedInterviewPrepInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedInterviewPrepInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedInterviewPrepInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedInterviewPrepInput | LlmCallUpdateManyWithWhereWithoutGeneratedInterviewPrepInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewPrepInput, InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput> | InterviewEvaluationCreateWithoutInterviewPrepInput[] | InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput | InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput[]
    upsert?: InterviewEvaluationUpsertWithWhereUniqueWithoutInterviewPrepInput | InterviewEvaluationUpsertWithWhereUniqueWithoutInterviewPrepInput[]
    createMany?: InterviewEvaluationCreateManyInterviewPrepInputEnvelope
    set?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    disconnect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    delete?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    update?: InterviewEvaluationUpdateWithWhereUniqueWithoutInterviewPrepInput | InterviewEvaluationUpdateWithWhereUniqueWithoutInterviewPrepInput[]
    updateMany?: InterviewEvaluationUpdateManyWithWhereWithoutInterviewPrepInput | InterviewEvaluationUpdateManyWithWhereWithoutInterviewPrepInput[]
    deleteMany?: InterviewEvaluationScalarWhereInput | InterviewEvaluationScalarWhereInput[]
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput = {
    create?: XOR<LlmCallCreateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput> | LlmCallCreateWithoutGeneratedInterviewPrepInput[] | LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput[]
    connectOrCreate?: LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput | LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput[]
    upsert?: LlmCallUpsertWithWhereUniqueWithoutGeneratedInterviewPrepInput | LlmCallUpsertWithWhereUniqueWithoutGeneratedInterviewPrepInput[]
    createMany?: LlmCallCreateManyGeneratedInterviewPrepInputEnvelope
    set?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    disconnect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    delete?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    connect?: LlmCallWhereUniqueInput | LlmCallWhereUniqueInput[]
    update?: LlmCallUpdateWithWhereUniqueWithoutGeneratedInterviewPrepInput | LlmCallUpdateWithWhereUniqueWithoutGeneratedInterviewPrepInput[]
    updateMany?: LlmCallUpdateManyWithWhereWithoutGeneratedInterviewPrepInput | LlmCallUpdateManyWithWhereWithoutGeneratedInterviewPrepInput[]
    deleteMany?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
  }

  export type InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput = {
    create?: XOR<InterviewEvaluationCreateWithoutInterviewPrepInput, InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput> | InterviewEvaluationCreateWithoutInterviewPrepInput[] | InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput[]
    connectOrCreate?: InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput | InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput[]
    upsert?: InterviewEvaluationUpsertWithWhereUniqueWithoutInterviewPrepInput | InterviewEvaluationUpsertWithWhereUniqueWithoutInterviewPrepInput[]
    createMany?: InterviewEvaluationCreateManyInterviewPrepInputEnvelope
    set?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    disconnect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    delete?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    connect?: InterviewEvaluationWhereUniqueInput | InterviewEvaluationWhereUniqueInput[]
    update?: InterviewEvaluationUpdateWithWhereUniqueWithoutInterviewPrepInput | InterviewEvaluationUpdateWithWhereUniqueWithoutInterviewPrepInput[]
    updateMany?: InterviewEvaluationUpdateManyWithWhereWithoutInterviewPrepInput | InterviewEvaluationUpdateManyWithWhereWithoutInterviewPrepInput[]
    deleteMany?: InterviewEvaluationScalarWhereInput | InterviewEvaluationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInterviewEvaluationsInput = {
    create?: XOR<UserCreateWithoutInterviewEvaluationsInput, UserUncheckedCreateWithoutInterviewEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewEvaluationsInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedInterviewPrepCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutEvaluationsInput, GeneratedInterviewPrepUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutEvaluationsInput
    connect?: GeneratedInterviewPrepWhereUniqueInput
  }

  export type UserUpdateOneWithoutInterviewEvaluationsNestedInput = {
    create?: XOR<UserCreateWithoutInterviewEvaluationsInput, UserUncheckedCreateWithoutInterviewEvaluationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewEvaluationsInput
    upsert?: UserUpsertWithoutInterviewEvaluationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterviewEvaluationsInput, UserUpdateWithoutInterviewEvaluationsInput>, UserUncheckedUpdateWithoutInterviewEvaluationsInput>
  }

  export type GeneratedInterviewPrepUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<GeneratedInterviewPrepCreateWithoutEvaluationsInput, GeneratedInterviewPrepUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: GeneratedInterviewPrepCreateOrConnectWithoutEvaluationsInput
    upsert?: GeneratedInterviewPrepUpsertWithoutEvaluationsInput
    connect?: GeneratedInterviewPrepWhereUniqueInput
    update?: XOR<XOR<GeneratedInterviewPrepUpdateToOneWithWhereWithoutEvaluationsInput, GeneratedInterviewPrepUpdateWithoutEvaluationsInput>, GeneratedInterviewPrepUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserCreateNestedOneWithoutSharedAnalysesInput = {
    create?: XOR<UserCreateWithoutSharedAnalysesInput, UserUncheckedCreateWithoutSharedAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedAnalysesInput
    connect?: UserWhereUniqueInput
  }

  export type GeneratedRoastCreateNestedOneWithoutSharedAnalysesInput = {
    create?: XOR<GeneratedRoastCreateWithoutSharedAnalysesInput, GeneratedRoastUncheckedCreateWithoutSharedAnalysesInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutSharedAnalysesInput
    connect?: GeneratedRoastWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSharedAnalysesNestedInput = {
    create?: XOR<UserCreateWithoutSharedAnalysesInput, UserUncheckedCreateWithoutSharedAnalysesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedAnalysesInput
    upsert?: UserUpsertWithoutSharedAnalysesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedAnalysesInput, UserUpdateWithoutSharedAnalysesInput>, UserUncheckedUpdateWithoutSharedAnalysesInput>
  }

  export type GeneratedRoastUpdateOneRequiredWithoutSharedAnalysesNestedInput = {
    create?: XOR<GeneratedRoastCreateWithoutSharedAnalysesInput, GeneratedRoastUncheckedCreateWithoutSharedAnalysesInput>
    connectOrCreate?: GeneratedRoastCreateOrConnectWithoutSharedAnalysesInput
    upsert?: GeneratedRoastUpsertWithoutSharedAnalysesInput
    connect?: GeneratedRoastWhereUniqueInput
    update?: XOR<XOR<GeneratedRoastUpdateToOneWithWhereWithoutSharedAnalysesInput, GeneratedRoastUpdateWithoutSharedAnalysesInput>, GeneratedRoastUncheckedUpdateWithoutSharedAnalysesInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type AnnouncementCreatetargetTiersInput = {
    set: $Enums.SubscriptionTier[]
  }

  export type AnnouncementCreatedismissedByInput = {
    set: string[]
  }

  export type EnumAnnouncementTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnnouncementType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AnnouncementUpdatetargetTiersInput = {
    set?: $Enums.SubscriptionTier[]
    push?: $Enums.SubscriptionTier | $Enums.SubscriptionTier[]
  }

  export type AnnouncementUpdatedismissedByInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserCreateNestedOneWithoutChatbotInput = {
    create?: XOR<UserCreateWithoutChatbotInput, UserUncheckedCreateWithoutChatbotInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutChatbotNestedInput = {
    create?: XOR<UserCreateWithoutChatbotInput, UserUncheckedCreateWithoutChatbotInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatbotInput
    upsert?: UserUpsertWithoutChatbotInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatbotInput, UserUpdateWithoutChatbotInput>, UserUncheckedUpdateWithoutChatbotInput>
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type ConversationMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type ConversationMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutConversationInput | ConversationMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutConversationInput | ConversationMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutConversationInput | ConversationMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput> | ConversationMessageCreateWithoutConversationInput[] | ConversationMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutConversationInput | ConversationMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationMessageUpsertWithWhereUniqueWithoutConversationInput | ConversationMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    set?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    disconnect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    delete?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    connect?: ConversationMessageWhereUniqueInput | ConversationMessageWhereUniqueInput[]
    update?: ConversationMessageUpdateWithWhereUniqueWithoutConversationInput | ConversationMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationMessageUpdateManyWithWhereWithoutConversationInput | ConversationMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSubscriptionTierFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierFilter<$PrismaModel> | $Enums.SubscriptionTier
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionTier | EnumSubscriptionTierFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionTier[] | ListEnumSubscriptionTierFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionTierWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTierFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTierFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationTokenType | EnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTokenTypeFilter<$PrismaModel> | $Enums.VerificationTokenType
  }

  export type NestedEnumVerificationTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationTokenType | EnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationTokenType[] | ListEnumVerificationTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.VerificationTokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumVerificationTokenTypeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumLlmCallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LlmCallStatus | EnumLlmCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLlmCallStatusFilter<$PrismaModel> | $Enums.LlmCallStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumLlmCallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LlmCallStatus | EnumLlmCallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LlmCallStatus[] | ListEnumLlmCallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLlmCallStatusWithAggregatesFilter<$PrismaModel> | $Enums.LlmCallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLlmCallStatusFilter<$PrismaModel>
    _max?: NestedEnumLlmCallStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleFilter<$PrismaModel> | $Enums.MessageRole
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageRole | EnumMessageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageRole[] | ListEnumMessageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageRoleWithAggregatesFilter<$PrismaModel> | $Enums.MessageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageRoleFilter<$PrismaModel>
    _max?: NestedEnumMessageRoleFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumAnnouncementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeFilter<$PrismaModel> | $Enums.AnnouncementType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumAnnouncementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnnouncementType | EnumAnnouncementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnnouncementType[] | ListEnumAnnouncementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAnnouncementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AnnouncementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
    _max?: NestedEnumAnnouncementTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LlmCallCreateWithoutUserInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutUserInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutUserInput, LlmCallUncheckedCreateWithoutUserInput>
  }

  export type LlmCallCreateManyUserInputEnvelope = {
    data: LlmCallCreateManyUserInput | LlmCallCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ResumeCreateWithoutUserInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutUserInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeUncheckedCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutUserInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput>
  }

  export type ResumeCreateManyUserInputEnvelope = {
    data: ResumeCreateManyUserInput | ResumeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedRoastCreateWithoutUserInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutUserInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutUserInput, GeneratedRoastUncheckedCreateWithoutUserInput>
  }

  export type GeneratedRoastCreateManyUserInputEnvelope = {
    data: GeneratedRoastCreateManyUserInput | GeneratedRoastCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedCoverLetterCreateWithoutUserInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume?: ResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUncheckedCreateWithoutUserInput = {
    id?: string
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterCreateOrConnectWithoutUserInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    create: XOR<GeneratedCoverLetterCreateWithoutUserInput, GeneratedCoverLetterUncheckedCreateWithoutUserInput>
  }

  export type GeneratedCoverLetterCreateManyUserInputEnvelope = {
    data: GeneratedCoverLetterCreateManyUserInput | GeneratedCoverLetterCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedResumeCreateWithoutUserInput = {
    id?: string
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedResumesInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedResumesInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeUncheckedCreateWithoutUserInput = {
    id?: string
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeCreateOrConnectWithoutUserInput = {
    where: GeneratedResumeWhereUniqueInput
    create: XOR<GeneratedResumeCreateWithoutUserInput, GeneratedResumeUncheckedCreateWithoutUserInput>
  }

  export type GeneratedResumeCreateManyUserInputEnvelope = {
    data: GeneratedResumeCreateManyUserInput | GeneratedResumeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedInterviewPrepCreateWithoutUserInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateWithoutUserInput = {
    id?: string
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepCreateOrConnectWithoutUserInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    create: XOR<GeneratedInterviewPrepCreateWithoutUserInput, GeneratedInterviewPrepUncheckedCreateWithoutUserInput>
  }

  export type GeneratedInterviewPrepCreateManyUserInputEnvelope = {
    data: GeneratedInterviewPrepCreateManyUserInput | GeneratedInterviewPrepCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterviewEvaluationCreateWithoutUserInput = {
    id?: string
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
    interviewPrep: GeneratedInterviewPrepCreateNestedOneWithoutEvaluationsInput
  }

  export type InterviewEvaluationUncheckedCreateWithoutUserInput = {
    id?: string
    interviewPrepId: string
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
  }

  export type InterviewEvaluationCreateOrConnectWithoutUserInput = {
    where: InterviewEvaluationWhereUniqueInput
    create: XOR<InterviewEvaluationCreateWithoutUserInput, InterviewEvaluationUncheckedCreateWithoutUserInput>
  }

  export type InterviewEvaluationCreateManyUserInputEnvelope = {
    data: InterviewEvaluationCreateManyUserInput | InterviewEvaluationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedAnalysisCreateWithoutUserInput = {
    id: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
    roast: GeneratedRoastCreateNestedOneWithoutSharedAnalysesInput
  }

  export type SharedAnalysisUncheckedCreateWithoutUserInput = {
    id: string
    roastId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SharedAnalysisCreateOrConnectWithoutUserInput = {
    where: SharedAnalysisWhereUniqueInput
    create: XOR<SharedAnalysisCreateWithoutUserInput, SharedAnalysisUncheckedCreateWithoutUserInput>
  }

  export type SharedAnalysisCreateManyUserInputEnvelope = {
    data: SharedAnalysisCreateManyUserInput | SharedAnalysisCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    stripeInvoiceId?: string | null
    stripePaymentId?: string | null
    itemCount: number
    generatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    stripeInvoiceId?: string | null
    stripePaymentId?: string | null
    itemCount: number
    generatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ChatbotCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId?: string | null
    createdAt?: Date | string
  }

  export type ChatbotUncheckedCreateWithoutUserInput = {
    id?: string
    anonymousId?: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId?: string | null
    createdAt?: Date | string
  }

  export type ChatbotCreateOrConnectWithoutUserInput = {
    where: ChatbotWhereUniqueInput
    create: XOR<ChatbotCreateWithoutUserInput, ChatbotUncheckedCreateWithoutUserInput>
  }

  export type ChatbotCreateManyUserInputEnvelope = {
    data: ChatbotCreateManyUserInput | ChatbotCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type VerificationTokenCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date | string
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type VerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date | string
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type VerificationTokenCreateOrConnectWithoutUserInput = {
    where: VerificationTokenWhereUniqueInput
    create: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type VerificationTokenCreateManyUserInputEnvelope = {
    data: VerificationTokenCreateManyUserInput | VerificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ConversationMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type LlmCallUpsertWithWhereUniqueWithoutUserInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutUserInput, LlmCallUncheckedUpdateWithoutUserInput>
    create: XOR<LlmCallCreateWithoutUserInput, LlmCallUncheckedCreateWithoutUserInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutUserInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutUserInput, LlmCallUncheckedUpdateWithoutUserInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutUserInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutUserInput>
  }

  export type LlmCallScalarWhereInput = {
    AND?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
    OR?: LlmCallScalarWhereInput[]
    NOT?: LlmCallScalarWhereInput | LlmCallScalarWhereInput[]
    id?: StringFilter<"LlmCall"> | string
    userId?: StringNullableFilter<"LlmCall"> | string | null
    provider?: StringFilter<"LlmCall"> | string
    model?: StringFilter<"LlmCall"> | string
    operationType?: StringFilter<"LlmCall"> | string
    totalInputTokens?: IntFilter<"LlmCall"> | number
    totalOutputTokens?: IntFilter<"LlmCall"> | number
    totalTokens?: IntFilter<"LlmCall"> | number
    totalCostUsd?: DecimalFilter<"LlmCall"> | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: IntNullableFilter<"LlmCall"> | number | null
    status?: EnumLlmCallStatusFilter<"LlmCall"> | $Enums.LlmCallStatus
    errorMessage?: StringNullableFilter<"LlmCall"> | string | null
    resumeId?: StringNullableFilter<"LlmCall"> | string | null
    extractedResumeId?: StringNullableFilter<"LlmCall"> | string | null
    extractedJobId?: StringNullableFilter<"LlmCall"> | string | null
    generatedRoastId?: StringNullableFilter<"LlmCall"> | string | null
    generatedCoverLetterId?: StringNullableFilter<"LlmCall"> | string | null
    generatedResumeId?: StringNullableFilter<"LlmCall"> | string | null
    generatedInterviewPrepId?: StringNullableFilter<"LlmCall"> | string | null
    createdAt?: DateTimeFilter<"LlmCall"> | Date | string
    completedAt?: DateTimeNullableFilter<"LlmCall"> | Date | string | null
  }

  export type ResumeUpsertWithWhereUniqueWithoutUserInput = {
    where: ResumeWhereUniqueInput
    update: XOR<ResumeUpdateWithoutUserInput, ResumeUncheckedUpdateWithoutUserInput>
    create: XOR<ResumeCreateWithoutUserInput, ResumeUncheckedCreateWithoutUserInput>
  }

  export type ResumeUpdateWithWhereUniqueWithoutUserInput = {
    where: ResumeWhereUniqueInput
    data: XOR<ResumeUpdateWithoutUserInput, ResumeUncheckedUpdateWithoutUserInput>
  }

  export type ResumeUpdateManyWithWhereWithoutUserInput = {
    where: ResumeScalarWhereInput
    data: XOR<ResumeUpdateManyMutationInput, ResumeUncheckedUpdateManyWithoutUserInput>
  }

  export type ResumeScalarWhereInput = {
    AND?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
    OR?: ResumeScalarWhereInput[]
    NOT?: ResumeScalarWhereInput | ResumeScalarWhereInput[]
    id?: StringFilter<"Resume"> | string
    userId?: StringNullableFilter<"Resume"> | string | null
    filename?: StringFilter<"Resume"> | string
    fileHash?: StringFilter<"Resume"> | string
    mimeType?: StringFilter<"Resume"> | string
    images?: StringNullableListFilter<"Resume">
    metadata?: JsonNullableFilter<"Resume">
    createdAt?: DateTimeFilter<"Resume"> | Date | string
  }

  export type GeneratedRoastUpsertWithWhereUniqueWithoutUserInput = {
    where: GeneratedRoastWhereUniqueInput
    update: XOR<GeneratedRoastUpdateWithoutUserInput, GeneratedRoastUncheckedUpdateWithoutUserInput>
    create: XOR<GeneratedRoastCreateWithoutUserInput, GeneratedRoastUncheckedCreateWithoutUserInput>
  }

  export type GeneratedRoastUpdateWithWhereUniqueWithoutUserInput = {
    where: GeneratedRoastWhereUniqueInput
    data: XOR<GeneratedRoastUpdateWithoutUserInput, GeneratedRoastUncheckedUpdateWithoutUserInput>
  }

  export type GeneratedRoastUpdateManyWithWhereWithoutUserInput = {
    where: GeneratedRoastScalarWhereInput
    data: XOR<GeneratedRoastUpdateManyMutationInput, GeneratedRoastUncheckedUpdateManyWithoutUserInput>
  }

  export type GeneratedRoastScalarWhereInput = {
    AND?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
    OR?: GeneratedRoastScalarWhereInput[]
    NOT?: GeneratedRoastScalarWhereInput | GeneratedRoastScalarWhereInput[]
    id?: StringFilter<"GeneratedRoast"> | string
    userId?: StringNullableFilter<"GeneratedRoast"> | string | null
    resumeId?: StringNullableFilter<"GeneratedRoast"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedRoast"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedRoast"> | string | null
    contentHash?: StringFilter<"GeneratedRoast"> | string
    data?: JsonFilter<"GeneratedRoast">
    overallScore?: IntNullableFilter<"GeneratedRoast"> | number | null
    createdAt?: DateTimeFilter<"GeneratedRoast"> | Date | string
  }

  export type GeneratedCoverLetterUpsertWithWhereUniqueWithoutUserInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    update: XOR<GeneratedCoverLetterUpdateWithoutUserInput, GeneratedCoverLetterUncheckedUpdateWithoutUserInput>
    create: XOR<GeneratedCoverLetterCreateWithoutUserInput, GeneratedCoverLetterUncheckedCreateWithoutUserInput>
  }

  export type GeneratedCoverLetterUpdateWithWhereUniqueWithoutUserInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    data: XOR<GeneratedCoverLetterUpdateWithoutUserInput, GeneratedCoverLetterUncheckedUpdateWithoutUserInput>
  }

  export type GeneratedCoverLetterUpdateManyWithWhereWithoutUserInput = {
    where: GeneratedCoverLetterScalarWhereInput
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyWithoutUserInput>
  }

  export type GeneratedCoverLetterScalarWhereInput = {
    AND?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
    OR?: GeneratedCoverLetterScalarWhereInput[]
    NOT?: GeneratedCoverLetterScalarWhereInput | GeneratedCoverLetterScalarWhereInput[]
    id?: StringFilter<"GeneratedCoverLetter"> | string
    userId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    resumeId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    roastId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    contentHash?: StringFilter<"GeneratedCoverLetter"> | string
    content?: StringFilter<"GeneratedCoverLetter"> | string
    tone?: StringFilter<"GeneratedCoverLetter"> | string
    modelName?: StringNullableFilter<"GeneratedCoverLetter"> | string | null
    metadata?: JsonNullableFilter<"GeneratedCoverLetter">
    createdAt?: DateTimeFilter<"GeneratedCoverLetter"> | Date | string
  }

  export type GeneratedResumeUpsertWithWhereUniqueWithoutUserInput = {
    where: GeneratedResumeWhereUniqueInput
    update: XOR<GeneratedResumeUpdateWithoutUserInput, GeneratedResumeUncheckedUpdateWithoutUserInput>
    create: XOR<GeneratedResumeCreateWithoutUserInput, GeneratedResumeUncheckedCreateWithoutUserInput>
  }

  export type GeneratedResumeUpdateWithWhereUniqueWithoutUserInput = {
    where: GeneratedResumeWhereUniqueInput
    data: XOR<GeneratedResumeUpdateWithoutUserInput, GeneratedResumeUncheckedUpdateWithoutUserInput>
  }

  export type GeneratedResumeUpdateManyWithWhereWithoutUserInput = {
    where: GeneratedResumeScalarWhereInput
    data: XOR<GeneratedResumeUpdateManyMutationInput, GeneratedResumeUncheckedUpdateManyWithoutUserInput>
  }

  export type GeneratedResumeScalarWhereInput = {
    AND?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
    OR?: GeneratedResumeScalarWhereInput[]
    NOT?: GeneratedResumeScalarWhereInput | GeneratedResumeScalarWhereInput[]
    id?: StringFilter<"GeneratedResume"> | string
    userId?: StringNullableFilter<"GeneratedResume"> | string | null
    roastId?: StringNullableFilter<"GeneratedResume"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedResume"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedResume"> | string | null
    templateId?: StringFilter<"GeneratedResume"> | string
    contentHash?: StringFilter<"GeneratedResume"> | string
    content?: StringFilter<"GeneratedResume"> | string
    data?: JsonFilter<"GeneratedResume">
    atsScore?: IntNullableFilter<"GeneratedResume"> | number | null
    keywordsMatched?: StringNullableListFilter<"GeneratedResume">
    createdAt?: DateTimeFilter<"GeneratedResume"> | Date | string
  }

  export type GeneratedInterviewPrepUpsertWithWhereUniqueWithoutUserInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    update: XOR<GeneratedInterviewPrepUpdateWithoutUserInput, GeneratedInterviewPrepUncheckedUpdateWithoutUserInput>
    create: XOR<GeneratedInterviewPrepCreateWithoutUserInput, GeneratedInterviewPrepUncheckedCreateWithoutUserInput>
  }

  export type GeneratedInterviewPrepUpdateWithWhereUniqueWithoutUserInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    data: XOR<GeneratedInterviewPrepUpdateWithoutUserInput, GeneratedInterviewPrepUncheckedUpdateWithoutUserInput>
  }

  export type GeneratedInterviewPrepUpdateManyWithWhereWithoutUserInput = {
    where: GeneratedInterviewPrepScalarWhereInput
    data: XOR<GeneratedInterviewPrepUpdateManyMutationInput, GeneratedInterviewPrepUncheckedUpdateManyWithoutUserInput>
  }

  export type GeneratedInterviewPrepScalarWhereInput = {
    AND?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
    OR?: GeneratedInterviewPrepScalarWhereInput[]
    NOT?: GeneratedInterviewPrepScalarWhereInput | GeneratedInterviewPrepScalarWhereInput[]
    id?: StringFilter<"GeneratedInterviewPrep"> | string
    userId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    roastId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    extractedResumeId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    extractedJobId?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    contentHash?: StringFilter<"GeneratedInterviewPrep"> | string
    data?: JsonFilter<"GeneratedInterviewPrep">
    difficulty?: StringFilter<"GeneratedInterviewPrep"> | string
    category?: StringFilter<"GeneratedInterviewPrep"> | string
    modelName?: StringNullableFilter<"GeneratedInterviewPrep"> | string | null
    createdAt?: DateTimeFilter<"GeneratedInterviewPrep"> | Date | string
  }

  export type InterviewEvaluationUpsertWithWhereUniqueWithoutUserInput = {
    where: InterviewEvaluationWhereUniqueInput
    update: XOR<InterviewEvaluationUpdateWithoutUserInput, InterviewEvaluationUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewEvaluationCreateWithoutUserInput, InterviewEvaluationUncheckedCreateWithoutUserInput>
  }

  export type InterviewEvaluationUpdateWithWhereUniqueWithoutUserInput = {
    where: InterviewEvaluationWhereUniqueInput
    data: XOR<InterviewEvaluationUpdateWithoutUserInput, InterviewEvaluationUncheckedUpdateWithoutUserInput>
  }

  export type InterviewEvaluationUpdateManyWithWhereWithoutUserInput = {
    where: InterviewEvaluationScalarWhereInput
    data: XOR<InterviewEvaluationUpdateManyMutationInput, InterviewEvaluationUncheckedUpdateManyWithoutUserInput>
  }

  export type InterviewEvaluationScalarWhereInput = {
    AND?: InterviewEvaluationScalarWhereInput | InterviewEvaluationScalarWhereInput[]
    OR?: InterviewEvaluationScalarWhereInput[]
    NOT?: InterviewEvaluationScalarWhereInput | InterviewEvaluationScalarWhereInput[]
    id?: StringFilter<"InterviewEvaluation"> | string
    interviewPrepId?: StringFilter<"InterviewEvaluation"> | string
    userId?: StringNullableFilter<"InterviewEvaluation"> | string | null
    evaluationType?: StringFilter<"InterviewEvaluation"> | string
    data?: JsonFilter<"InterviewEvaluation">
    questionsCount?: IntFilter<"InterviewEvaluation"> | number
    overallScore?: IntFilter<"InterviewEvaluation"> | number
    createdAt?: DateTimeFilter<"InterviewEvaluation"> | Date | string
  }

  export type SharedAnalysisUpsertWithWhereUniqueWithoutUserInput = {
    where: SharedAnalysisWhereUniqueInput
    update: XOR<SharedAnalysisUpdateWithoutUserInput, SharedAnalysisUncheckedUpdateWithoutUserInput>
    create: XOR<SharedAnalysisCreateWithoutUserInput, SharedAnalysisUncheckedCreateWithoutUserInput>
  }

  export type SharedAnalysisUpdateWithWhereUniqueWithoutUserInput = {
    where: SharedAnalysisWhereUniqueInput
    data: XOR<SharedAnalysisUpdateWithoutUserInput, SharedAnalysisUncheckedUpdateWithoutUserInput>
  }

  export type SharedAnalysisUpdateManyWithWhereWithoutUserInput = {
    where: SharedAnalysisScalarWhereInput
    data: XOR<SharedAnalysisUpdateManyMutationInput, SharedAnalysisUncheckedUpdateManyWithoutUserInput>
  }

  export type SharedAnalysisScalarWhereInput = {
    AND?: SharedAnalysisScalarWhereInput | SharedAnalysisScalarWhereInput[]
    OR?: SharedAnalysisScalarWhereInput[]
    NOT?: SharedAnalysisScalarWhereInput | SharedAnalysisScalarWhereInput[]
    id?: StringFilter<"SharedAnalysis"> | string
    userId?: StringFilter<"SharedAnalysis"> | string
    roastId?: StringFilter<"SharedAnalysis"> | string
    settings?: JsonNullableFilter<"SharedAnalysis">
    viewCount?: IntFilter<"SharedAnalysis"> | number
    expiresAt?: DateTimeFilter<"SharedAnalysis"> | Date | string
    createdAt?: DateTimeFilter<"SharedAnalysis"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFilter<"Invoice"> | Date | string
    billingPeriodEnd?: DateTimeFilter<"Invoice"> | Date | string
    stripeInvoiceId?: StringNullableFilter<"Invoice"> | string | null
    stripePaymentId?: StringNullableFilter<"Invoice"> | string | null
    itemCount?: IntFilter<"Invoice"> | number
    generatedAt?: DateTimeFilter<"Invoice"> | Date | string
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
  }

  export type ChatbotUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatbotWhereUniqueInput
    update: XOR<ChatbotUpdateWithoutUserInput, ChatbotUncheckedUpdateWithoutUserInput>
    create: XOR<ChatbotCreateWithoutUserInput, ChatbotUncheckedCreateWithoutUserInput>
  }

  export type ChatbotUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatbotWhereUniqueInput
    data: XOR<ChatbotUpdateWithoutUserInput, ChatbotUncheckedUpdateWithoutUserInput>
  }

  export type ChatbotUpdateManyWithWhereWithoutUserInput = {
    where: ChatbotScalarWhereInput
    data: XOR<ChatbotUpdateManyMutationInput, ChatbotUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatbotScalarWhereInput = {
    AND?: ChatbotScalarWhereInput | ChatbotScalarWhereInput[]
    OR?: ChatbotScalarWhereInput[]
    NOT?: ChatbotScalarWhereInput | ChatbotScalarWhereInput[]
    id?: StringFilter<"Chatbot"> | string
    userId?: StringNullableFilter<"Chatbot"> | string | null
    anonymousId?: StringNullableFilter<"Chatbot"> | string | null
    conversationId?: StringFilter<"Chatbot"> | string
    message?: StringFilter<"Chatbot"> | string
    role?: StringFilter<"Chatbot"> | string
    llmMessageId?: StringNullableFilter<"Chatbot"> | string | null
    createdAt?: DateTimeFilter<"Chatbot"> | Date | string
  }

  export type VerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationTokenWhereUniqueInput
    update: XOR<VerificationTokenUpdateWithoutUserInput, VerificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type VerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationTokenWhereUniqueInput
    data: XOR<VerificationTokenUpdateWithoutUserInput, VerificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type VerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: VerificationTokenScalarWhereInput
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationTokenScalarWhereInput = {
    AND?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
    OR?: VerificationTokenScalarWhereInput[]
    NOT?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    userId?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    type?: EnumVerificationTokenTypeFilter<"VerificationToken"> | $Enums.VerificationTokenType
    expiresAt?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    usedAt?: DateTimeNullableFilter<"VerificationToken"> | Date | string | null
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    title?: StringFilter<"Conversation"> | string
    lastMessageAt?: DateTimeFilter<"Conversation"> | Date | string
    messageCount?: IntFilter<"Conversation"> | number
    selectedTemplate?: StringNullableFilter<"Conversation"> | string | null
    selectedModel?: StringNullableFilter<"Conversation"> | string | null
    metadata?: JsonNullableFilter<"Conversation">
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutVerificationTokensInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVerificationTokensInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVerificationTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVerificationTokensInput, UserUncheckedCreateWithoutVerificationTokensInput>
  }

  export type UserUpsertWithoutVerificationTokensInput = {
    update: XOR<UserUpdateWithoutVerificationTokensInput, UserUncheckedUpdateWithoutVerificationTokensInput>
    create: XOR<UserCreateWithoutVerificationTokensInput, UserUncheckedCreateWithoutVerificationTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVerificationTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVerificationTokensInput, UserUncheckedUpdateWithoutVerificationTokensInput>
  }

  export type UserUpdateWithoutVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLlmCallsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLlmCallsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLlmCallsInput, UserUncheckedCreateWithoutLlmCallsInput>
  }

  export type ResumeCreateWithoutLlmCallsInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutResumesInput
    extractedResumes?: ExtractedResumeCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    userId?: string | null
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    extractedResumes?: ExtractedResumeUncheckedCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutLlmCallsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutLlmCallsInput, ResumeUncheckedCreateWithoutLlmCallsInput>
  }

  export type ExtractedResumeCreateWithoutLlmCallsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutLlmCallsInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutLlmCallsInput, ExtractedResumeUncheckedCreateWithoutLlmCallsInput>
  }

  export type ExtractedJobDescriptionCreateWithoutLlmCallsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    summarizedJobDescriptions?: SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionCreateOrConnectWithoutLlmCallsInput = {
    where: ExtractedJobDescriptionWhereUniqueInput
    create: XOR<ExtractedJobDescriptionCreateWithoutLlmCallsInput, ExtractedJobDescriptionUncheckedCreateWithoutLlmCallsInput>
  }

  export type GeneratedRoastCreateWithoutLlmCallsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutLlmCallsInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutLlmCallsInput, GeneratedRoastUncheckedCreateWithoutLlmCallsInput>
  }

  export type GeneratedCoverLetterCreateWithoutLlmCallsInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedCoverLettersInput
    resume?: ResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput
  }

  export type GeneratedCoverLetterUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterCreateOrConnectWithoutLlmCallsInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    create: XOR<GeneratedCoverLetterCreateWithoutLlmCallsInput, GeneratedCoverLetterUncheckedCreateWithoutLlmCallsInput>
  }

  export type GeneratedResumeCreateWithoutLlmCallsInput = {
    id?: string
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedResumesInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedResumesInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedResumesInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedResumesInput
  }

  export type GeneratedResumeUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
  }

  export type GeneratedResumeCreateOrConnectWithoutLlmCallsInput = {
    where: GeneratedResumeWhereUniqueInput
    create: XOR<GeneratedResumeCreateWithoutLlmCallsInput, GeneratedResumeUncheckedCreateWithoutLlmCallsInput>
  }

  export type GeneratedInterviewPrepCreateWithoutLlmCallsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedInterviewPrepsInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput
    evaluations?: InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateWithoutLlmCallsInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    evaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepCreateOrConnectWithoutLlmCallsInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    create: XOR<GeneratedInterviewPrepCreateWithoutLlmCallsInput, GeneratedInterviewPrepUncheckedCreateWithoutLlmCallsInput>
  }

  export type LlmMessageCreateWithoutLlmCallInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens?: number | null
    outputTokens?: number | null
    totalTokens?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string
    processingTimeMs?: number | null
    finishReason?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    maxTokens?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LlmMessageUncheckedCreateWithoutLlmCallInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens?: number | null
    outputTokens?: number | null
    totalTokens?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string
    processingTimeMs?: number | null
    finishReason?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    maxTokens?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LlmMessageCreateOrConnectWithoutLlmCallInput = {
    where: LlmMessageWhereUniqueInput
    create: XOR<LlmMessageCreateWithoutLlmCallInput, LlmMessageUncheckedCreateWithoutLlmCallInput>
  }

  export type LlmMessageCreateManyLlmCallInputEnvelope = {
    data: LlmMessageCreateManyLlmCallInput | LlmMessageCreateManyLlmCallInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLlmCallsInput = {
    update: XOR<UserUpdateWithoutLlmCallsInput, UserUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<UserCreateWithoutLlmCallsInput, UserUncheckedCreateWithoutLlmCallsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLlmCallsInput, UserUncheckedUpdateWithoutLlmCallsInput>
  }

  export type UserUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutLlmCallsInput = {
    update: XOR<ResumeUpdateWithoutLlmCallsInput, ResumeUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<ResumeCreateWithoutLlmCallsInput, ResumeUncheckedCreateWithoutLlmCallsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutLlmCallsInput, ResumeUncheckedUpdateWithoutLlmCallsInput>
  }

  export type ResumeUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResumesNestedInput
    extractedResumes?: ExtractedResumeUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extractedResumes?: ExtractedResumeUncheckedUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ExtractedResumeUpsertWithoutLlmCallsInput = {
    update: XOR<ExtractedResumeUpdateWithoutLlmCallsInput, ExtractedResumeUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<ExtractedResumeCreateWithoutLlmCallsInput, ExtractedResumeUncheckedCreateWithoutLlmCallsInput>
    where?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: ExtractedResumeWhereInput
    data: XOR<ExtractedResumeUpdateWithoutLlmCallsInput, ExtractedResumeUncheckedUpdateWithoutLlmCallsInput>
  }

  export type ExtractedResumeUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedJobDescriptionUpsertWithoutLlmCallsInput = {
    update: XOR<ExtractedJobDescriptionUpdateWithoutLlmCallsInput, ExtractedJobDescriptionUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<ExtractedJobDescriptionCreateWithoutLlmCallsInput, ExtractedJobDescriptionUncheckedCreateWithoutLlmCallsInput>
    where?: ExtractedJobDescriptionWhereInput
  }

  export type ExtractedJobDescriptionUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: ExtractedJobDescriptionWhereInput
    data: XOR<ExtractedJobDescriptionUpdateWithoutLlmCallsInput, ExtractedJobDescriptionUncheckedUpdateWithoutLlmCallsInput>
  }

  export type ExtractedJobDescriptionUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summarizedJobDescriptions?: SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type GeneratedRoastUpsertWithoutLlmCallsInput = {
    update: XOR<GeneratedRoastUpdateWithoutLlmCallsInput, GeneratedRoastUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<GeneratedRoastCreateWithoutLlmCallsInput, GeneratedRoastUncheckedCreateWithoutLlmCallsInput>
    where?: GeneratedRoastWhereInput
  }

  export type GeneratedRoastUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: GeneratedRoastWhereInput
    data: XOR<GeneratedRoastUpdateWithoutLlmCallsInput, GeneratedRoastUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedRoastUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedCoverLetterUpsertWithoutLlmCallsInput = {
    update: XOR<GeneratedCoverLetterUpdateWithoutLlmCallsInput, GeneratedCoverLetterUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<GeneratedCoverLetterCreateWithoutLlmCallsInput, GeneratedCoverLetterUncheckedCreateWithoutLlmCallsInput>
    where?: GeneratedCoverLetterWhereInput
  }

  export type GeneratedCoverLetterUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: GeneratedCoverLetterWhereInput
    data: XOR<GeneratedCoverLetterUpdateWithoutLlmCallsInput, GeneratedCoverLetterUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedCoverLetterUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedCoverLettersNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeUpsertWithoutLlmCallsInput = {
    update: XOR<GeneratedResumeUpdateWithoutLlmCallsInput, GeneratedResumeUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<GeneratedResumeCreateWithoutLlmCallsInput, GeneratedResumeUncheckedCreateWithoutLlmCallsInput>
    where?: GeneratedResumeWhereInput
  }

  export type GeneratedResumeUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: GeneratedResumeWhereInput
    data: XOR<GeneratedResumeUpdateWithoutLlmCallsInput, GeneratedResumeUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedResumeUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedResumesNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedResumesNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedResumesNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedResumesNestedInput
  }

  export type GeneratedResumeUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepUpsertWithoutLlmCallsInput = {
    update: XOR<GeneratedInterviewPrepUpdateWithoutLlmCallsInput, GeneratedInterviewPrepUncheckedUpdateWithoutLlmCallsInput>
    create: XOR<GeneratedInterviewPrepCreateWithoutLlmCallsInput, GeneratedInterviewPrepUncheckedCreateWithoutLlmCallsInput>
    where?: GeneratedInterviewPrepWhereInput
  }

  export type GeneratedInterviewPrepUpdateToOneWithWhereWithoutLlmCallsInput = {
    where?: GeneratedInterviewPrepWhereInput
    data: XOR<GeneratedInterviewPrepUpdateWithoutLlmCallsInput, GeneratedInterviewPrepUncheckedUpdateWithoutLlmCallsInput>
  }

  export type GeneratedInterviewPrepUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    evaluations?: InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateWithoutLlmCallsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput
  }

  export type LlmMessageUpsertWithWhereUniqueWithoutLlmCallInput = {
    where: LlmMessageWhereUniqueInput
    update: XOR<LlmMessageUpdateWithoutLlmCallInput, LlmMessageUncheckedUpdateWithoutLlmCallInput>
    create: XOR<LlmMessageCreateWithoutLlmCallInput, LlmMessageUncheckedCreateWithoutLlmCallInput>
  }

  export type LlmMessageUpdateWithWhereUniqueWithoutLlmCallInput = {
    where: LlmMessageWhereUniqueInput
    data: XOR<LlmMessageUpdateWithoutLlmCallInput, LlmMessageUncheckedUpdateWithoutLlmCallInput>
  }

  export type LlmMessageUpdateManyWithWhereWithoutLlmCallInput = {
    where: LlmMessageScalarWhereInput
    data: XOR<LlmMessageUpdateManyMutationInput, LlmMessageUncheckedUpdateManyWithoutLlmCallInput>
  }

  export type LlmMessageScalarWhereInput = {
    AND?: LlmMessageScalarWhereInput | LlmMessageScalarWhereInput[]
    OR?: LlmMessageScalarWhereInput[]
    NOT?: LlmMessageScalarWhereInput | LlmMessageScalarWhereInput[]
    id?: StringFilter<"LlmMessage"> | string
    llmCallId?: StringFilter<"LlmMessage"> | string
    role?: EnumMessageRoleFilter<"LlmMessage"> | $Enums.MessageRole
    content?: StringFilter<"LlmMessage"> | string
    messageIndex?: IntFilter<"LlmMessage"> | number
    inputTokens?: IntNullableFilter<"LlmMessage"> | number | null
    outputTokens?: IntNullableFilter<"LlmMessage"> | number | null
    totalTokens?: IntNullableFilter<"LlmMessage"> | number | null
    costUsd?: DecimalFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string
    processingTimeMs?: IntNullableFilter<"LlmMessage"> | number | null
    finishReason?: StringNullableFilter<"LlmMessage"> | string | null
    temperature?: DecimalNullableFilter<"LlmMessage"> | Decimal | DecimalJsLike | number | string | null
    maxTokens?: IntNullableFilter<"LlmMessage"> | number | null
    metadata?: JsonNullableFilter<"LlmMessage">
    createdAt?: DateTimeFilter<"LlmMessage"> | Date | string
  }

  export type LlmCallCreateWithoutMessagesInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
  }

  export type LlmCallUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LlmCallCreateOrConnectWithoutMessagesInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutMessagesInput, LlmCallUncheckedCreateWithoutMessagesInput>
  }

  export type LlmCallUpsertWithoutMessagesInput = {
    update: XOR<LlmCallUpdateWithoutMessagesInput, LlmCallUncheckedUpdateWithoutMessagesInput>
    create: XOR<LlmCallCreateWithoutMessagesInput, LlmCallUncheckedCreateWithoutMessagesInput>
    where?: LlmCallWhereInput
  }

  export type LlmCallUpdateToOneWithWhereWithoutMessagesInput = {
    where?: LlmCallWhereInput
    data: XOR<LlmCallUpdateWithoutMessagesInput, LlmCallUncheckedUpdateWithoutMessagesInput>
  }

  export type LlmCallUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutResumesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutResumesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutResumesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
  }

  export type LlmCallCreateWithoutResumeInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutResumeInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutResumeInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutResumeInput, LlmCallUncheckedCreateWithoutResumeInput>
  }

  export type LlmCallCreateManyResumeInputEnvelope = {
    data: LlmCallCreateManyResumeInput | LlmCallCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type ExtractedResumeCreateWithoutResumeInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutResumeInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutResumeInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutResumeInput, ExtractedResumeUncheckedCreateWithoutResumeInput>
  }

  export type ExtractedResumeCreateManyResumeInputEnvelope = {
    data: ExtractedResumeCreateManyResumeInput | ExtractedResumeCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedRoastCreateWithoutResumeInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutResumeInput = {
    id?: string
    userId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutResumeInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutResumeInput, GeneratedRoastUncheckedCreateWithoutResumeInput>
  }

  export type GeneratedRoastCreateManyResumeInputEnvelope = {
    data: GeneratedRoastCreateManyResumeInput | GeneratedRoastCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedCoverLetterCreateWithoutResumeInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedCoverLettersInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUncheckedCreateWithoutResumeInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterCreateOrConnectWithoutResumeInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    create: XOR<GeneratedCoverLetterCreateWithoutResumeInput, GeneratedCoverLetterUncheckedCreateWithoutResumeInput>
  }

  export type GeneratedCoverLetterCreateManyResumeInputEnvelope = {
    data: GeneratedCoverLetterCreateManyResumeInput | GeneratedCoverLetterCreateManyResumeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutResumesInput = {
    update: XOR<UserUpdateWithoutResumesInput, UserUncheckedUpdateWithoutResumesInput>
    create: XOR<UserCreateWithoutResumesInput, UserUncheckedCreateWithoutResumesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResumesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResumesInput, UserUncheckedUpdateWithoutResumesInput>
  }

  export type UserUpdateWithoutResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LlmCallUpsertWithWhereUniqueWithoutResumeInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutResumeInput, LlmCallUncheckedUpdateWithoutResumeInput>
    create: XOR<LlmCallCreateWithoutResumeInput, LlmCallUncheckedCreateWithoutResumeInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutResumeInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutResumeInput, LlmCallUncheckedUpdateWithoutResumeInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutResumeInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutResumeInput>
  }

  export type ExtractedResumeUpsertWithWhereUniqueWithoutResumeInput = {
    where: ExtractedResumeWhereUniqueInput
    update: XOR<ExtractedResumeUpdateWithoutResumeInput, ExtractedResumeUncheckedUpdateWithoutResumeInput>
    create: XOR<ExtractedResumeCreateWithoutResumeInput, ExtractedResumeUncheckedCreateWithoutResumeInput>
  }

  export type ExtractedResumeUpdateWithWhereUniqueWithoutResumeInput = {
    where: ExtractedResumeWhereUniqueInput
    data: XOR<ExtractedResumeUpdateWithoutResumeInput, ExtractedResumeUncheckedUpdateWithoutResumeInput>
  }

  export type ExtractedResumeUpdateManyWithWhereWithoutResumeInput = {
    where: ExtractedResumeScalarWhereInput
    data: XOR<ExtractedResumeUpdateManyMutationInput, ExtractedResumeUncheckedUpdateManyWithoutResumeInput>
  }

  export type ExtractedResumeScalarWhereInput = {
    AND?: ExtractedResumeScalarWhereInput | ExtractedResumeScalarWhereInput[]
    OR?: ExtractedResumeScalarWhereInput[]
    NOT?: ExtractedResumeScalarWhereInput | ExtractedResumeScalarWhereInput[]
    id?: StringFilter<"ExtractedResume"> | string
    resumeId?: StringFilter<"ExtractedResume"> | string
    contentHash?: StringFilter<"ExtractedResume"> | string
    data?: JsonFilter<"ExtractedResume">
    createdAt?: DateTimeFilter<"ExtractedResume"> | Date | string
  }

  export type GeneratedRoastUpsertWithWhereUniqueWithoutResumeInput = {
    where: GeneratedRoastWhereUniqueInput
    update: XOR<GeneratedRoastUpdateWithoutResumeInput, GeneratedRoastUncheckedUpdateWithoutResumeInput>
    create: XOR<GeneratedRoastCreateWithoutResumeInput, GeneratedRoastUncheckedCreateWithoutResumeInput>
  }

  export type GeneratedRoastUpdateWithWhereUniqueWithoutResumeInput = {
    where: GeneratedRoastWhereUniqueInput
    data: XOR<GeneratedRoastUpdateWithoutResumeInput, GeneratedRoastUncheckedUpdateWithoutResumeInput>
  }

  export type GeneratedRoastUpdateManyWithWhereWithoutResumeInput = {
    where: GeneratedRoastScalarWhereInput
    data: XOR<GeneratedRoastUpdateManyMutationInput, GeneratedRoastUncheckedUpdateManyWithoutResumeInput>
  }

  export type GeneratedCoverLetterUpsertWithWhereUniqueWithoutResumeInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    update: XOR<GeneratedCoverLetterUpdateWithoutResumeInput, GeneratedCoverLetterUncheckedUpdateWithoutResumeInput>
    create: XOR<GeneratedCoverLetterCreateWithoutResumeInput, GeneratedCoverLetterUncheckedCreateWithoutResumeInput>
  }

  export type GeneratedCoverLetterUpdateWithWhereUniqueWithoutResumeInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    data: XOR<GeneratedCoverLetterUpdateWithoutResumeInput, GeneratedCoverLetterUncheckedUpdateWithoutResumeInput>
  }

  export type GeneratedCoverLetterUpdateManyWithWhereWithoutResumeInput = {
    where: GeneratedCoverLetterScalarWhereInput
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyWithoutResumeInput>
  }

  export type ResumeCreateWithoutExtractedResumesInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutExtractedResumesInput = {
    id?: string
    userId?: string | null
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutExtractedResumesInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutExtractedResumesInput, ResumeUncheckedCreateWithoutExtractedResumesInput>
  }

  export type LlmCallCreateWithoutExtractedResumeInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutExtractedResumeInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutExtractedResumeInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutExtractedResumeInput, LlmCallUncheckedCreateWithoutExtractedResumeInput>
  }

  export type LlmCallCreateManyExtractedResumeInputEnvelope = {
    data: LlmCallCreateManyExtractedResumeInput | LlmCallCreateManyExtractedResumeInput[]
    skipDuplicates?: boolean
  }

  export type SummarizedResumeCreateWithoutExtractedResumeInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedResumeUncheckedCreateWithoutExtractedResumeInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedResumeCreateOrConnectWithoutExtractedResumeInput = {
    where: SummarizedResumeWhereUniqueInput
    create: XOR<SummarizedResumeCreateWithoutExtractedResumeInput, SummarizedResumeUncheckedCreateWithoutExtractedResumeInput>
  }

  export type SummarizedResumeCreateManyExtractedResumeInputEnvelope = {
    data: SummarizedResumeCreateManyExtractedResumeInput | SummarizedResumeCreateManyExtractedResumeInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedRoastCreateWithoutExtractedResumeInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutExtractedResumeInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutExtractedResumeInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutExtractedResumeInput, GeneratedRoastUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedRoastCreateManyExtractedResumeInputEnvelope = {
    data: GeneratedRoastCreateManyExtractedResumeInput | GeneratedRoastCreateManyExtractedResumeInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedCoverLetterCreateWithoutExtractedResumeInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedCoverLettersInput
    resume?: ResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterCreateOrConnectWithoutExtractedResumeInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    create: XOR<GeneratedCoverLetterCreateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedCoverLetterCreateManyExtractedResumeInputEnvelope = {
    data: GeneratedCoverLetterCreateManyExtractedResumeInput | GeneratedCoverLetterCreateManyExtractedResumeInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedResumeCreateWithoutExtractedResumeInput = {
    id?: string
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedResumesInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedResumesInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeUncheckedCreateWithoutExtractedResumeInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeCreateOrConnectWithoutExtractedResumeInput = {
    where: GeneratedResumeWhereUniqueInput
    create: XOR<GeneratedResumeCreateWithoutExtractedResumeInput, GeneratedResumeUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedResumeCreateManyExtractedResumeInputEnvelope = {
    data: GeneratedResumeCreateManyExtractedResumeInput | GeneratedResumeCreateManyExtractedResumeInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedInterviewPrepCreateWithoutExtractedResumeInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedInterviewPrepsInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepCreateOrConnectWithoutExtractedResumeInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    create: XOR<GeneratedInterviewPrepCreateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedInterviewPrepCreateManyExtractedResumeInputEnvelope = {
    data: GeneratedInterviewPrepCreateManyExtractedResumeInput | GeneratedInterviewPrepCreateManyExtractedResumeInput[]
    skipDuplicates?: boolean
  }

  export type ResumeUpsertWithoutExtractedResumesInput = {
    update: XOR<ResumeUpdateWithoutExtractedResumesInput, ResumeUncheckedUpdateWithoutExtractedResumesInput>
    create: XOR<ResumeCreateWithoutExtractedResumesInput, ResumeUncheckedCreateWithoutExtractedResumesInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutExtractedResumesInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutExtractedResumesInput, ResumeUncheckedUpdateWithoutExtractedResumesInput>
  }

  export type ResumeUpdateWithoutExtractedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutExtractedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type LlmCallUpsertWithWhereUniqueWithoutExtractedResumeInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutExtractedResumeInput, LlmCallUncheckedUpdateWithoutExtractedResumeInput>
    create: XOR<LlmCallCreateWithoutExtractedResumeInput, LlmCallUncheckedCreateWithoutExtractedResumeInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutExtractedResumeInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutExtractedResumeInput, LlmCallUncheckedUpdateWithoutExtractedResumeInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutExtractedResumeInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutExtractedResumeInput>
  }

  export type SummarizedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput = {
    where: SummarizedResumeWhereUniqueInput
    update: XOR<SummarizedResumeUpdateWithoutExtractedResumeInput, SummarizedResumeUncheckedUpdateWithoutExtractedResumeInput>
    create: XOR<SummarizedResumeCreateWithoutExtractedResumeInput, SummarizedResumeUncheckedCreateWithoutExtractedResumeInput>
  }

  export type SummarizedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput = {
    where: SummarizedResumeWhereUniqueInput
    data: XOR<SummarizedResumeUpdateWithoutExtractedResumeInput, SummarizedResumeUncheckedUpdateWithoutExtractedResumeInput>
  }

  export type SummarizedResumeUpdateManyWithWhereWithoutExtractedResumeInput = {
    where: SummarizedResumeScalarWhereInput
    data: XOR<SummarizedResumeUpdateManyMutationInput, SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeInput>
  }

  export type SummarizedResumeScalarWhereInput = {
    AND?: SummarizedResumeScalarWhereInput | SummarizedResumeScalarWhereInput[]
    OR?: SummarizedResumeScalarWhereInput[]
    NOT?: SummarizedResumeScalarWhereInput | SummarizedResumeScalarWhereInput[]
    id?: StringFilter<"SummarizedResume"> | string
    extractedResumeId?: StringFilter<"SummarizedResume"> | string
    contentHash?: StringFilter<"SummarizedResume"> | string
    summary?: JsonFilter<"SummarizedResume">
    createdAt?: DateTimeFilter<"SummarizedResume"> | Date | string
  }

  export type GeneratedRoastUpsertWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedRoastWhereUniqueInput
    update: XOR<GeneratedRoastUpdateWithoutExtractedResumeInput, GeneratedRoastUncheckedUpdateWithoutExtractedResumeInput>
    create: XOR<GeneratedRoastCreateWithoutExtractedResumeInput, GeneratedRoastUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedRoastUpdateWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedRoastWhereUniqueInput
    data: XOR<GeneratedRoastUpdateWithoutExtractedResumeInput, GeneratedRoastUncheckedUpdateWithoutExtractedResumeInput>
  }

  export type GeneratedRoastUpdateManyWithWhereWithoutExtractedResumeInput = {
    where: GeneratedRoastScalarWhereInput
    data: XOR<GeneratedRoastUpdateManyMutationInput, GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeInput>
  }

  export type GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    update: XOR<GeneratedCoverLetterUpdateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedUpdateWithoutExtractedResumeInput>
    create: XOR<GeneratedCoverLetterCreateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    data: XOR<GeneratedCoverLetterUpdateWithoutExtractedResumeInput, GeneratedCoverLetterUncheckedUpdateWithoutExtractedResumeInput>
  }

  export type GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedResumeInput = {
    where: GeneratedCoverLetterScalarWhereInput
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeInput>
  }

  export type GeneratedResumeUpsertWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedResumeWhereUniqueInput
    update: XOR<GeneratedResumeUpdateWithoutExtractedResumeInput, GeneratedResumeUncheckedUpdateWithoutExtractedResumeInput>
    create: XOR<GeneratedResumeCreateWithoutExtractedResumeInput, GeneratedResumeUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedResumeUpdateWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedResumeWhereUniqueInput
    data: XOR<GeneratedResumeUpdateWithoutExtractedResumeInput, GeneratedResumeUncheckedUpdateWithoutExtractedResumeInput>
  }

  export type GeneratedResumeUpdateManyWithWhereWithoutExtractedResumeInput = {
    where: GeneratedResumeScalarWhereInput
    data: XOR<GeneratedResumeUpdateManyMutationInput, GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeInput>
  }

  export type GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    update: XOR<GeneratedInterviewPrepUpdateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedUpdateWithoutExtractedResumeInput>
    create: XOR<GeneratedInterviewPrepCreateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedResumeInput>
  }

  export type GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedResumeInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    data: XOR<GeneratedInterviewPrepUpdateWithoutExtractedResumeInput, GeneratedInterviewPrepUncheckedUpdateWithoutExtractedResumeInput>
  }

  export type GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedResumeInput = {
    where: GeneratedInterviewPrepScalarWhereInput
    data: XOR<GeneratedInterviewPrepUpdateManyMutationInput, GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeInput>
  }

  export type LlmCallCreateWithoutExtractedJobInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutExtractedJobInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutExtractedJobInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutExtractedJobInput, LlmCallUncheckedCreateWithoutExtractedJobInput>
  }

  export type LlmCallCreateManyExtractedJobInputEnvelope = {
    data: LlmCallCreateManyExtractedJobInput | LlmCallCreateManyExtractedJobInput[]
    skipDuplicates?: boolean
  }

  export type SummarizedJobDescriptionCreateWithoutExtractedJobInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SummarizedJobDescriptionCreateOrConnectWithoutExtractedJobInput = {
    where: SummarizedJobDescriptionWhereUniqueInput
    create: XOR<SummarizedJobDescriptionCreateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput>
  }

  export type SummarizedJobDescriptionCreateManyExtractedJobInputEnvelope = {
    data: SummarizedJobDescriptionCreateManyExtractedJobInput | SummarizedJobDescriptionCreateManyExtractedJobInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedRoastCreateWithoutExtractedJobInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutExtractedJobInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutExtractedJobInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutExtractedJobInput, GeneratedRoastUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedRoastCreateManyExtractedJobInputEnvelope = {
    data: GeneratedRoastCreateManyExtractedJobInput | GeneratedRoastCreateManyExtractedJobInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedCoverLetterCreateWithoutExtractedJobInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedCoverLettersInput
    resume?: ResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterCreateOrConnectWithoutExtractedJobInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    create: XOR<GeneratedCoverLetterCreateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedCoverLetterCreateManyExtractedJobInputEnvelope = {
    data: GeneratedCoverLetterCreateManyExtractedJobInput | GeneratedCoverLetterCreateManyExtractedJobInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedResumeCreateWithoutExtractedJobInput = {
    id?: string
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedResumesInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedResumesInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeUncheckedCreateWithoutExtractedJobInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeCreateOrConnectWithoutExtractedJobInput = {
    where: GeneratedResumeWhereUniqueInput
    create: XOR<GeneratedResumeCreateWithoutExtractedJobInput, GeneratedResumeUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedResumeCreateManyExtractedJobInputEnvelope = {
    data: GeneratedResumeCreateManyExtractedJobInput | GeneratedResumeCreateManyExtractedJobInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedInterviewPrepCreateWithoutExtractedJobInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedInterviewPrepsInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepCreateOrConnectWithoutExtractedJobInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    create: XOR<GeneratedInterviewPrepCreateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedInterviewPrepCreateManyExtractedJobInputEnvelope = {
    data: GeneratedInterviewPrepCreateManyExtractedJobInput | GeneratedInterviewPrepCreateManyExtractedJobInput[]
    skipDuplicates?: boolean
  }

  export type LlmCallUpsertWithWhereUniqueWithoutExtractedJobInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutExtractedJobInput, LlmCallUncheckedUpdateWithoutExtractedJobInput>
    create: XOR<LlmCallCreateWithoutExtractedJobInput, LlmCallUncheckedCreateWithoutExtractedJobInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutExtractedJobInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutExtractedJobInput, LlmCallUncheckedUpdateWithoutExtractedJobInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutExtractedJobInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutExtractedJobInput>
  }

  export type SummarizedJobDescriptionUpsertWithWhereUniqueWithoutExtractedJobInput = {
    where: SummarizedJobDescriptionWhereUniqueInput
    update: XOR<SummarizedJobDescriptionUpdateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedUpdateWithoutExtractedJobInput>
    create: XOR<SummarizedJobDescriptionCreateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedCreateWithoutExtractedJobInput>
  }

  export type SummarizedJobDescriptionUpdateWithWhereUniqueWithoutExtractedJobInput = {
    where: SummarizedJobDescriptionWhereUniqueInput
    data: XOR<SummarizedJobDescriptionUpdateWithoutExtractedJobInput, SummarizedJobDescriptionUncheckedUpdateWithoutExtractedJobInput>
  }

  export type SummarizedJobDescriptionUpdateManyWithWhereWithoutExtractedJobInput = {
    where: SummarizedJobDescriptionScalarWhereInput
    data: XOR<SummarizedJobDescriptionUpdateManyMutationInput, SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobInput>
  }

  export type SummarizedJobDescriptionScalarWhereInput = {
    AND?: SummarizedJobDescriptionScalarWhereInput | SummarizedJobDescriptionScalarWhereInput[]
    OR?: SummarizedJobDescriptionScalarWhereInput[]
    NOT?: SummarizedJobDescriptionScalarWhereInput | SummarizedJobDescriptionScalarWhereInput[]
    id?: StringFilter<"SummarizedJobDescription"> | string
    extractedJobId?: StringFilter<"SummarizedJobDescription"> | string
    contentHash?: StringFilter<"SummarizedJobDescription"> | string
    summary?: JsonFilter<"SummarizedJobDescription">
    createdAt?: DateTimeFilter<"SummarizedJobDescription"> | Date | string
  }

  export type GeneratedRoastUpsertWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedRoastWhereUniqueInput
    update: XOR<GeneratedRoastUpdateWithoutExtractedJobInput, GeneratedRoastUncheckedUpdateWithoutExtractedJobInput>
    create: XOR<GeneratedRoastCreateWithoutExtractedJobInput, GeneratedRoastUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedRoastUpdateWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedRoastWhereUniqueInput
    data: XOR<GeneratedRoastUpdateWithoutExtractedJobInput, GeneratedRoastUncheckedUpdateWithoutExtractedJobInput>
  }

  export type GeneratedRoastUpdateManyWithWhereWithoutExtractedJobInput = {
    where: GeneratedRoastScalarWhereInput
    data: XOR<GeneratedRoastUpdateManyMutationInput, GeneratedRoastUncheckedUpdateManyWithoutExtractedJobInput>
  }

  export type GeneratedCoverLetterUpsertWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    update: XOR<GeneratedCoverLetterUpdateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedUpdateWithoutExtractedJobInput>
    create: XOR<GeneratedCoverLetterCreateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedCoverLetterUpdateWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    data: XOR<GeneratedCoverLetterUpdateWithoutExtractedJobInput, GeneratedCoverLetterUncheckedUpdateWithoutExtractedJobInput>
  }

  export type GeneratedCoverLetterUpdateManyWithWhereWithoutExtractedJobInput = {
    where: GeneratedCoverLetterScalarWhereInput
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobInput>
  }

  export type GeneratedResumeUpsertWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedResumeWhereUniqueInput
    update: XOR<GeneratedResumeUpdateWithoutExtractedJobInput, GeneratedResumeUncheckedUpdateWithoutExtractedJobInput>
    create: XOR<GeneratedResumeCreateWithoutExtractedJobInput, GeneratedResumeUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedResumeUpdateWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedResumeWhereUniqueInput
    data: XOR<GeneratedResumeUpdateWithoutExtractedJobInput, GeneratedResumeUncheckedUpdateWithoutExtractedJobInput>
  }

  export type GeneratedResumeUpdateManyWithWhereWithoutExtractedJobInput = {
    where: GeneratedResumeScalarWhereInput
    data: XOR<GeneratedResumeUpdateManyMutationInput, GeneratedResumeUncheckedUpdateManyWithoutExtractedJobInput>
  }

  export type GeneratedInterviewPrepUpsertWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    update: XOR<GeneratedInterviewPrepUpdateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedUpdateWithoutExtractedJobInput>
    create: XOR<GeneratedInterviewPrepCreateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedCreateWithoutExtractedJobInput>
  }

  export type GeneratedInterviewPrepUpdateWithWhereUniqueWithoutExtractedJobInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    data: XOR<GeneratedInterviewPrepUpdateWithoutExtractedJobInput, GeneratedInterviewPrepUncheckedUpdateWithoutExtractedJobInput>
  }

  export type GeneratedInterviewPrepUpdateManyWithWhereWithoutExtractedJobInput = {
    where: GeneratedInterviewPrepScalarWhereInput
    data: XOR<GeneratedInterviewPrepUpdateManyMutationInput, GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobInput>
  }

  export type ExtractedResumeCreateWithoutSummarizedResumesInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutSummarizedResumesInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutSummarizedResumesInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutSummarizedResumesInput, ExtractedResumeUncheckedCreateWithoutSummarizedResumesInput>
  }

  export type ExtractedResumeUpsertWithoutSummarizedResumesInput = {
    update: XOR<ExtractedResumeUpdateWithoutSummarizedResumesInput, ExtractedResumeUncheckedUpdateWithoutSummarizedResumesInput>
    create: XOR<ExtractedResumeCreateWithoutSummarizedResumesInput, ExtractedResumeUncheckedCreateWithoutSummarizedResumesInput>
    where?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeUpdateToOneWithWhereWithoutSummarizedResumesInput = {
    where?: ExtractedResumeWhereInput
    data: XOR<ExtractedResumeUpdateWithoutSummarizedResumesInput, ExtractedResumeUncheckedUpdateWithoutSummarizedResumesInput>
  }

  export type ExtractedResumeUpdateWithoutSummarizedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutSummarizedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedJobDescriptionCreateWithoutSummarizedJobDescriptionsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateWithoutSummarizedJobDescriptionsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionCreateOrConnectWithoutSummarizedJobDescriptionsInput = {
    where: ExtractedJobDescriptionWhereUniqueInput
    create: XOR<ExtractedJobDescriptionCreateWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUncheckedCreateWithoutSummarizedJobDescriptionsInput>
  }

  export type ExtractedJobDescriptionUpsertWithoutSummarizedJobDescriptionsInput = {
    update: XOR<ExtractedJobDescriptionUpdateWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUncheckedUpdateWithoutSummarizedJobDescriptionsInput>
    create: XOR<ExtractedJobDescriptionCreateWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUncheckedCreateWithoutSummarizedJobDescriptionsInput>
    where?: ExtractedJobDescriptionWhereInput
  }

  export type ExtractedJobDescriptionUpdateToOneWithWhereWithoutSummarizedJobDescriptionsInput = {
    where?: ExtractedJobDescriptionWhereInput
    data: XOR<ExtractedJobDescriptionUpdateWithoutSummarizedJobDescriptionsInput, ExtractedJobDescriptionUncheckedUpdateWithoutSummarizedJobDescriptionsInput>
  }

  export type ExtractedJobDescriptionUpdateWithoutSummarizedJobDescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateWithoutSummarizedJobDescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type UserCreateWithoutGeneratedRoastsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedRoastsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedRoastsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedRoastsInput, UserUncheckedCreateWithoutGeneratedRoastsInput>
  }

  export type ResumeCreateWithoutGeneratedRoastsInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutGeneratedRoastsInput = {
    id?: string
    userId?: string | null
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeUncheckedCreateNestedManyWithoutResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutGeneratedRoastsInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutGeneratedRoastsInput, ResumeUncheckedCreateWithoutGeneratedRoastsInput>
  }

  export type ExtractedResumeCreateWithoutGeneratedRoastsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutGeneratedRoastsInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutGeneratedRoastsInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutGeneratedRoastsInput, ExtractedResumeUncheckedCreateWithoutGeneratedRoastsInput>
  }

  export type ExtractedJobDescriptionCreateWithoutGeneratedRoastsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateWithoutGeneratedRoastsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionCreateOrConnectWithoutGeneratedRoastsInput = {
    where: ExtractedJobDescriptionWhereUniqueInput
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedRoastsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedRoastsInput>
  }

  export type LlmCallCreateWithoutGeneratedRoastInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutGeneratedRoastInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutGeneratedRoastInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutGeneratedRoastInput, LlmCallUncheckedCreateWithoutGeneratedRoastInput>
  }

  export type LlmCallCreateManyGeneratedRoastInputEnvelope = {
    data: LlmCallCreateManyGeneratedRoastInput | LlmCallCreateManyGeneratedRoastInput[]
    skipDuplicates?: boolean
  }

  export type SharedAnalysisCreateWithoutRoastInput = {
    id: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSharedAnalysesInput
  }

  export type SharedAnalysisUncheckedCreateWithoutRoastInput = {
    id: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SharedAnalysisCreateOrConnectWithoutRoastInput = {
    where: SharedAnalysisWhereUniqueInput
    create: XOR<SharedAnalysisCreateWithoutRoastInput, SharedAnalysisUncheckedCreateWithoutRoastInput>
  }

  export type SharedAnalysisCreateManyRoastInputEnvelope = {
    data: SharedAnalysisCreateManyRoastInput | SharedAnalysisCreateManyRoastInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedCoverLetterCreateWithoutRoastInput = {
    id?: string
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedCoverLettersInput
    resume?: ResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedCoverLettersInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedCoverLettersInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterUncheckedCreateWithoutRoastInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedCoverLetterInput
  }

  export type GeneratedCoverLetterCreateOrConnectWithoutRoastInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    create: XOR<GeneratedCoverLetterCreateWithoutRoastInput, GeneratedCoverLetterUncheckedCreateWithoutRoastInput>
  }

  export type GeneratedCoverLetterCreateManyRoastInputEnvelope = {
    data: GeneratedCoverLetterCreateManyRoastInput | GeneratedCoverLetterCreateManyRoastInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedResumeCreateWithoutRoastInput = {
    id?: string
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedResumesInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedResumesInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeUncheckedCreateWithoutRoastInput = {
    id?: string
    userId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedResumeInput
  }

  export type GeneratedResumeCreateOrConnectWithoutRoastInput = {
    where: GeneratedResumeWhereUniqueInput
    create: XOR<GeneratedResumeCreateWithoutRoastInput, GeneratedResumeUncheckedCreateWithoutRoastInput>
  }

  export type GeneratedResumeCreateManyRoastInputEnvelope = {
    data: GeneratedResumeCreateManyRoastInput | GeneratedResumeCreateManyRoastInput[]
    skipDuplicates?: boolean
  }

  export type GeneratedInterviewPrepCreateWithoutRoastInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateWithoutRoastInput = {
    id?: string
    userId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput
    evaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutInterviewPrepInput
  }

  export type GeneratedInterviewPrepCreateOrConnectWithoutRoastInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    create: XOR<GeneratedInterviewPrepCreateWithoutRoastInput, GeneratedInterviewPrepUncheckedCreateWithoutRoastInput>
  }

  export type GeneratedInterviewPrepCreateManyRoastInputEnvelope = {
    data: GeneratedInterviewPrepCreateManyRoastInput | GeneratedInterviewPrepCreateManyRoastInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGeneratedRoastsInput = {
    update: XOR<UserUpdateWithoutGeneratedRoastsInput, UserUncheckedUpdateWithoutGeneratedRoastsInput>
    create: XOR<UserCreateWithoutGeneratedRoastsInput, UserUncheckedCreateWithoutGeneratedRoastsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedRoastsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedRoastsInput, UserUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type UserUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutGeneratedRoastsInput = {
    update: XOR<ResumeUpdateWithoutGeneratedRoastsInput, ResumeUncheckedUpdateWithoutGeneratedRoastsInput>
    create: XOR<ResumeCreateWithoutGeneratedRoastsInput, ResumeUncheckedCreateWithoutGeneratedRoastsInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutGeneratedRoastsInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutGeneratedRoastsInput, ResumeUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type ResumeUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUncheckedUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ExtractedResumeUpsertWithoutGeneratedRoastsInput = {
    update: XOR<ExtractedResumeUpdateWithoutGeneratedRoastsInput, ExtractedResumeUncheckedUpdateWithoutGeneratedRoastsInput>
    create: XOR<ExtractedResumeCreateWithoutGeneratedRoastsInput, ExtractedResumeUncheckedCreateWithoutGeneratedRoastsInput>
    where?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeUpdateToOneWithWhereWithoutGeneratedRoastsInput = {
    where?: ExtractedResumeWhereInput
    data: XOR<ExtractedResumeUpdateWithoutGeneratedRoastsInput, ExtractedResumeUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type ExtractedResumeUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedJobDescriptionUpsertWithoutGeneratedRoastsInput = {
    update: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedRoastsInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedRoastsInput>
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedRoastsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedRoastsInput>
    where?: ExtractedJobDescriptionWhereInput
  }

  export type ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedRoastsInput = {
    where?: ExtractedJobDescriptionWhereInput
    data: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedRoastsInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedRoastsInput>
  }

  export type ExtractedJobDescriptionUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedRoastsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type LlmCallUpsertWithWhereUniqueWithoutGeneratedRoastInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutGeneratedRoastInput, LlmCallUncheckedUpdateWithoutGeneratedRoastInput>
    create: XOR<LlmCallCreateWithoutGeneratedRoastInput, LlmCallUncheckedCreateWithoutGeneratedRoastInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutGeneratedRoastInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutGeneratedRoastInput, LlmCallUncheckedUpdateWithoutGeneratedRoastInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutGeneratedRoastInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutGeneratedRoastInput>
  }

  export type SharedAnalysisUpsertWithWhereUniqueWithoutRoastInput = {
    where: SharedAnalysisWhereUniqueInput
    update: XOR<SharedAnalysisUpdateWithoutRoastInput, SharedAnalysisUncheckedUpdateWithoutRoastInput>
    create: XOR<SharedAnalysisCreateWithoutRoastInput, SharedAnalysisUncheckedCreateWithoutRoastInput>
  }

  export type SharedAnalysisUpdateWithWhereUniqueWithoutRoastInput = {
    where: SharedAnalysisWhereUniqueInput
    data: XOR<SharedAnalysisUpdateWithoutRoastInput, SharedAnalysisUncheckedUpdateWithoutRoastInput>
  }

  export type SharedAnalysisUpdateManyWithWhereWithoutRoastInput = {
    where: SharedAnalysisScalarWhereInput
    data: XOR<SharedAnalysisUpdateManyMutationInput, SharedAnalysisUncheckedUpdateManyWithoutRoastInput>
  }

  export type GeneratedCoverLetterUpsertWithWhereUniqueWithoutRoastInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    update: XOR<GeneratedCoverLetterUpdateWithoutRoastInput, GeneratedCoverLetterUncheckedUpdateWithoutRoastInput>
    create: XOR<GeneratedCoverLetterCreateWithoutRoastInput, GeneratedCoverLetterUncheckedCreateWithoutRoastInput>
  }

  export type GeneratedCoverLetterUpdateWithWhereUniqueWithoutRoastInput = {
    where: GeneratedCoverLetterWhereUniqueInput
    data: XOR<GeneratedCoverLetterUpdateWithoutRoastInput, GeneratedCoverLetterUncheckedUpdateWithoutRoastInput>
  }

  export type GeneratedCoverLetterUpdateManyWithWhereWithoutRoastInput = {
    where: GeneratedCoverLetterScalarWhereInput
    data: XOR<GeneratedCoverLetterUpdateManyMutationInput, GeneratedCoverLetterUncheckedUpdateManyWithoutRoastInput>
  }

  export type GeneratedResumeUpsertWithWhereUniqueWithoutRoastInput = {
    where: GeneratedResumeWhereUniqueInput
    update: XOR<GeneratedResumeUpdateWithoutRoastInput, GeneratedResumeUncheckedUpdateWithoutRoastInput>
    create: XOR<GeneratedResumeCreateWithoutRoastInput, GeneratedResumeUncheckedCreateWithoutRoastInput>
  }

  export type GeneratedResumeUpdateWithWhereUniqueWithoutRoastInput = {
    where: GeneratedResumeWhereUniqueInput
    data: XOR<GeneratedResumeUpdateWithoutRoastInput, GeneratedResumeUncheckedUpdateWithoutRoastInput>
  }

  export type GeneratedResumeUpdateManyWithWhereWithoutRoastInput = {
    where: GeneratedResumeScalarWhereInput
    data: XOR<GeneratedResumeUpdateManyMutationInput, GeneratedResumeUncheckedUpdateManyWithoutRoastInput>
  }

  export type GeneratedInterviewPrepUpsertWithWhereUniqueWithoutRoastInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    update: XOR<GeneratedInterviewPrepUpdateWithoutRoastInput, GeneratedInterviewPrepUncheckedUpdateWithoutRoastInput>
    create: XOR<GeneratedInterviewPrepCreateWithoutRoastInput, GeneratedInterviewPrepUncheckedCreateWithoutRoastInput>
  }

  export type GeneratedInterviewPrepUpdateWithWhereUniqueWithoutRoastInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    data: XOR<GeneratedInterviewPrepUpdateWithoutRoastInput, GeneratedInterviewPrepUncheckedUpdateWithoutRoastInput>
  }

  export type GeneratedInterviewPrepUpdateManyWithWhereWithoutRoastInput = {
    where: GeneratedInterviewPrepScalarWhereInput
    data: XOR<GeneratedInterviewPrepUpdateManyMutationInput, GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastInput>
  }

  export type UserCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedCoverLettersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedCoverLettersInput, UserUncheckedCreateWithoutGeneratedCoverLettersInput>
  }

  export type ResumeCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutResumeInput
  }

  export type ResumeUncheckedCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    userId?: string | null
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutResumeInput
    extractedResumes?: ExtractedResumeUncheckedCreateNestedManyWithoutResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutResumeInput
  }

  export type ResumeCreateOrConnectWithoutGeneratedCoverLettersInput = {
    where: ResumeWhereUniqueInput
    create: XOR<ResumeCreateWithoutGeneratedCoverLettersInput, ResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
  }

  export type GeneratedRoastCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutGeneratedCoverLettersInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutGeneratedCoverLettersInput, GeneratedRoastUncheckedCreateWithoutGeneratedCoverLettersInput>
  }

  export type ExtractedResumeCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutGeneratedCoverLettersInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutGeneratedCoverLettersInput, ExtractedResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
  }

  export type ExtractedJobDescriptionCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateWithoutGeneratedCoverLettersInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionCreateOrConnectWithoutGeneratedCoverLettersInput = {
    where: ExtractedJobDescriptionWhereUniqueInput
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedCoverLettersInput>
  }

  export type LlmCallCreateWithoutGeneratedCoverLetterInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutGeneratedCoverLetterInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutGeneratedCoverLetterInput, LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput>
  }

  export type LlmCallCreateManyGeneratedCoverLetterInputEnvelope = {
    data: LlmCallCreateManyGeneratedCoverLetterInput | LlmCallCreateManyGeneratedCoverLetterInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGeneratedCoverLettersInput = {
    update: XOR<UserUpdateWithoutGeneratedCoverLettersInput, UserUncheckedUpdateWithoutGeneratedCoverLettersInput>
    create: XOR<UserCreateWithoutGeneratedCoverLettersInput, UserUncheckedCreateWithoutGeneratedCoverLettersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedCoverLettersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedCoverLettersInput, UserUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type UserUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ResumeUpsertWithoutGeneratedCoverLettersInput = {
    update: XOR<ResumeUpdateWithoutGeneratedCoverLettersInput, ResumeUncheckedUpdateWithoutGeneratedCoverLettersInput>
    create: XOR<ResumeCreateWithoutGeneratedCoverLettersInput, ResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
    where?: ResumeWhereInput
  }

  export type ResumeUpdateToOneWithWhereWithoutGeneratedCoverLettersInput = {
    where?: ResumeWhereInput
    data: XOR<ResumeUpdateWithoutGeneratedCoverLettersInput, ResumeUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type ResumeUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUncheckedUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type GeneratedRoastUpsertWithoutGeneratedCoverLettersInput = {
    update: XOR<GeneratedRoastUpdateWithoutGeneratedCoverLettersInput, GeneratedRoastUncheckedUpdateWithoutGeneratedCoverLettersInput>
    create: XOR<GeneratedRoastCreateWithoutGeneratedCoverLettersInput, GeneratedRoastUncheckedCreateWithoutGeneratedCoverLettersInput>
    where?: GeneratedRoastWhereInput
  }

  export type GeneratedRoastUpdateToOneWithWhereWithoutGeneratedCoverLettersInput = {
    where?: GeneratedRoastWhereInput
    data: XOR<GeneratedRoastUpdateWithoutGeneratedCoverLettersInput, GeneratedRoastUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type GeneratedRoastUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type ExtractedResumeUpsertWithoutGeneratedCoverLettersInput = {
    update: XOR<ExtractedResumeUpdateWithoutGeneratedCoverLettersInput, ExtractedResumeUncheckedUpdateWithoutGeneratedCoverLettersInput>
    create: XOR<ExtractedResumeCreateWithoutGeneratedCoverLettersInput, ExtractedResumeUncheckedCreateWithoutGeneratedCoverLettersInput>
    where?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeUpdateToOneWithWhereWithoutGeneratedCoverLettersInput = {
    where?: ExtractedResumeWhereInput
    data: XOR<ExtractedResumeUpdateWithoutGeneratedCoverLettersInput, ExtractedResumeUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type ExtractedResumeUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedJobDescriptionUpsertWithoutGeneratedCoverLettersInput = {
    update: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedCoverLettersInput>
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedCoverLettersInput>
    where?: ExtractedJobDescriptionWhereInput
  }

  export type ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedCoverLettersInput = {
    where?: ExtractedJobDescriptionWhereInput
    data: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedCoverLettersInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedCoverLettersInput>
  }

  export type ExtractedJobDescriptionUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedCoverLettersInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type LlmCallUpsertWithWhereUniqueWithoutGeneratedCoverLetterInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutGeneratedCoverLetterInput, LlmCallUncheckedUpdateWithoutGeneratedCoverLetterInput>
    create: XOR<LlmCallCreateWithoutGeneratedCoverLetterInput, LlmCallUncheckedCreateWithoutGeneratedCoverLetterInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutGeneratedCoverLetterInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutGeneratedCoverLetterInput, LlmCallUncheckedUpdateWithoutGeneratedCoverLetterInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutGeneratedCoverLetterInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterInput>
  }

  export type UserCreateWithoutGeneratedResumesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedResumesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedResumesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedResumesInput, UserUncheckedCreateWithoutGeneratedResumesInput>
  }

  export type GeneratedRoastCreateWithoutGeneratedResumesInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutGeneratedResumesInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutGeneratedResumesInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutGeneratedResumesInput, GeneratedRoastUncheckedCreateWithoutGeneratedResumesInput>
  }

  export type ExtractedResumeCreateWithoutGeneratedResumesInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutGeneratedResumesInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutGeneratedResumesInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutGeneratedResumesInput, ExtractedResumeUncheckedCreateWithoutGeneratedResumesInput>
  }

  export type ExtractedJobDescriptionCreateWithoutGeneratedResumesInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateWithoutGeneratedResumesInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionCreateOrConnectWithoutGeneratedResumesInput = {
    where: ExtractedJobDescriptionWhereUniqueInput
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedResumesInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedResumesInput>
  }

  export type LlmCallCreateWithoutGeneratedResumeInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedInterviewPrep?: GeneratedInterviewPrepCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutGeneratedResumeInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutGeneratedResumeInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutGeneratedResumeInput, LlmCallUncheckedCreateWithoutGeneratedResumeInput>
  }

  export type LlmCallCreateManyGeneratedResumeInputEnvelope = {
    data: LlmCallCreateManyGeneratedResumeInput | LlmCallCreateManyGeneratedResumeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGeneratedResumesInput = {
    update: XOR<UserUpdateWithoutGeneratedResumesInput, UserUncheckedUpdateWithoutGeneratedResumesInput>
    create: XOR<UserCreateWithoutGeneratedResumesInput, UserUncheckedCreateWithoutGeneratedResumesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedResumesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedResumesInput, UserUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type UserUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedRoastUpsertWithoutGeneratedResumesInput = {
    update: XOR<GeneratedRoastUpdateWithoutGeneratedResumesInput, GeneratedRoastUncheckedUpdateWithoutGeneratedResumesInput>
    create: XOR<GeneratedRoastCreateWithoutGeneratedResumesInput, GeneratedRoastUncheckedCreateWithoutGeneratedResumesInput>
    where?: GeneratedRoastWhereInput
  }

  export type GeneratedRoastUpdateToOneWithWhereWithoutGeneratedResumesInput = {
    where?: GeneratedRoastWhereInput
    data: XOR<GeneratedRoastUpdateWithoutGeneratedResumesInput, GeneratedRoastUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type GeneratedRoastUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type ExtractedResumeUpsertWithoutGeneratedResumesInput = {
    update: XOR<ExtractedResumeUpdateWithoutGeneratedResumesInput, ExtractedResumeUncheckedUpdateWithoutGeneratedResumesInput>
    create: XOR<ExtractedResumeCreateWithoutGeneratedResumesInput, ExtractedResumeUncheckedCreateWithoutGeneratedResumesInput>
    where?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeUpdateToOneWithWhereWithoutGeneratedResumesInput = {
    where?: ExtractedResumeWhereInput
    data: XOR<ExtractedResumeUpdateWithoutGeneratedResumesInput, ExtractedResumeUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type ExtractedResumeUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedJobDescriptionUpsertWithoutGeneratedResumesInput = {
    update: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedResumesInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedResumesInput>
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedResumesInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedResumesInput>
    where?: ExtractedJobDescriptionWhereInput
  }

  export type ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedResumesInput = {
    where?: ExtractedJobDescriptionWhereInput
    data: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedResumesInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedResumesInput>
  }

  export type ExtractedJobDescriptionUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedResumesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type LlmCallUpsertWithWhereUniqueWithoutGeneratedResumeInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutGeneratedResumeInput, LlmCallUncheckedUpdateWithoutGeneratedResumeInput>
    create: XOR<LlmCallCreateWithoutGeneratedResumeInput, LlmCallUncheckedCreateWithoutGeneratedResumeInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutGeneratedResumeInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutGeneratedResumeInput, LlmCallUncheckedUpdateWithoutGeneratedResumeInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutGeneratedResumeInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutGeneratedResumeInput>
  }

  export type UserCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutGeneratedInterviewPrepsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGeneratedInterviewPrepsInput, UserUncheckedCreateWithoutGeneratedInterviewPrepsInput>
  }

  export type GeneratedRoastCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutGeneratedInterviewPrepsInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutGeneratedInterviewPrepsInput, GeneratedRoastUncheckedCreateWithoutGeneratedInterviewPrepsInput>
  }

  export type ExtractedResumeCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    resume: ResumeCreateNestedOneWithoutExtractedResumesInput
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeUncheckedCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    resumeId: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedResumeInput
    summarizedResumes?: SummarizedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedResumeInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedResumeInput
  }

  export type ExtractedResumeCreateOrConnectWithoutGeneratedInterviewPrepsInput = {
    where: ExtractedResumeWhereUniqueInput
    create: XOR<ExtractedResumeCreateWithoutGeneratedInterviewPrepsInput, ExtractedResumeUncheckedCreateWithoutGeneratedInterviewPrepsInput>
  }

  export type ExtractedJobDescriptionCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionUncheckedCreateWithoutGeneratedInterviewPrepsInput = {
    id?: string
    contentHash: string
    originalText: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutExtractedJobInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutExtractedJobInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutExtractedJobInput
  }

  export type ExtractedJobDescriptionCreateOrConnectWithoutGeneratedInterviewPrepsInput = {
    where: ExtractedJobDescriptionWhereUniqueInput
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedInterviewPrepsInput>
  }

  export type LlmCallCreateWithoutGeneratedInterviewPrepInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    user?: UserCreateNestedOneWithoutLlmCallsInput
    resume?: ResumeCreateNestedOneWithoutLlmCallsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutLlmCallsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutLlmCallsInput
    generatedRoast?: GeneratedRoastCreateNestedOneWithoutLlmCallsInput
    generatedCoverLetter?: GeneratedCoverLetterCreateNestedOneWithoutLlmCallsInput
    generatedResume?: GeneratedResumeCreateNestedOneWithoutLlmCallsInput
    messages?: LlmMessageCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    messages?: LlmMessageUncheckedCreateNestedManyWithoutLlmCallInput
  }

  export type LlmCallCreateOrConnectWithoutGeneratedInterviewPrepInput = {
    where: LlmCallWhereUniqueInput
    create: XOR<LlmCallCreateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput>
  }

  export type LlmCallCreateManyGeneratedInterviewPrepInputEnvelope = {
    data: LlmCallCreateManyGeneratedInterviewPrepInput | LlmCallCreateManyGeneratedInterviewPrepInput[]
    skipDuplicates?: boolean
  }

  export type InterviewEvaluationCreateWithoutInterviewPrepInput = {
    id?: string
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutInterviewEvaluationsInput
  }

  export type InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput = {
    id?: string
    userId?: string | null
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
  }

  export type InterviewEvaluationCreateOrConnectWithoutInterviewPrepInput = {
    where: InterviewEvaluationWhereUniqueInput
    create: XOR<InterviewEvaluationCreateWithoutInterviewPrepInput, InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput>
  }

  export type InterviewEvaluationCreateManyInterviewPrepInputEnvelope = {
    data: InterviewEvaluationCreateManyInterviewPrepInput | InterviewEvaluationCreateManyInterviewPrepInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutGeneratedInterviewPrepsInput = {
    update: XOR<UserUpdateWithoutGeneratedInterviewPrepsInput, UserUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
    create: XOR<UserCreateWithoutGeneratedInterviewPrepsInput, UserUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGeneratedInterviewPrepsInput, UserUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type UserUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedRoastUpsertWithoutGeneratedInterviewPrepsInput = {
    update: XOR<GeneratedRoastUpdateWithoutGeneratedInterviewPrepsInput, GeneratedRoastUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
    create: XOR<GeneratedRoastCreateWithoutGeneratedInterviewPrepsInput, GeneratedRoastUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    where?: GeneratedRoastWhereInput
  }

  export type GeneratedRoastUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput = {
    where?: GeneratedRoastWhereInput
    data: XOR<GeneratedRoastUpdateWithoutGeneratedInterviewPrepsInput, GeneratedRoastUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type GeneratedRoastUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type ExtractedResumeUpsertWithoutGeneratedInterviewPrepsInput = {
    update: XOR<ExtractedResumeUpdateWithoutGeneratedInterviewPrepsInput, ExtractedResumeUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
    create: XOR<ExtractedResumeCreateWithoutGeneratedInterviewPrepsInput, ExtractedResumeUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    where?: ExtractedResumeWhereInput
  }

  export type ExtractedResumeUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput = {
    where?: ExtractedResumeWhereInput
    data: XOR<ExtractedResumeUpdateWithoutGeneratedInterviewPrepsInput, ExtractedResumeUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type ExtractedResumeUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneRequiredWithoutExtractedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedJobDescriptionUpsertWithoutGeneratedInterviewPrepsInput = {
    update: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
    create: XOR<ExtractedJobDescriptionCreateWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUncheckedCreateWithoutGeneratedInterviewPrepsInput>
    where?: ExtractedJobDescriptionWhereInput
  }

  export type ExtractedJobDescriptionUpdateToOneWithWhereWithoutGeneratedInterviewPrepsInput = {
    where?: ExtractedJobDescriptionWhereInput
    data: XOR<ExtractedJobDescriptionUpdateWithoutGeneratedInterviewPrepsInput, ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedInterviewPrepsInput>
  }

  export type ExtractedJobDescriptionUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedJobNestedInput
  }

  export type ExtractedJobDescriptionUncheckedUpdateWithoutGeneratedInterviewPrepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    originalText?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedJobNestedInput
    summarizedJobDescriptions?: SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedJobNestedInput
  }

  export type LlmCallUpsertWithWhereUniqueWithoutGeneratedInterviewPrepInput = {
    where: LlmCallWhereUniqueInput
    update: XOR<LlmCallUpdateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedUpdateWithoutGeneratedInterviewPrepInput>
    create: XOR<LlmCallCreateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedCreateWithoutGeneratedInterviewPrepInput>
  }

  export type LlmCallUpdateWithWhereUniqueWithoutGeneratedInterviewPrepInput = {
    where: LlmCallWhereUniqueInput
    data: XOR<LlmCallUpdateWithoutGeneratedInterviewPrepInput, LlmCallUncheckedUpdateWithoutGeneratedInterviewPrepInput>
  }

  export type LlmCallUpdateManyWithWhereWithoutGeneratedInterviewPrepInput = {
    where: LlmCallScalarWhereInput
    data: XOR<LlmCallUpdateManyMutationInput, LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepInput>
  }

  export type InterviewEvaluationUpsertWithWhereUniqueWithoutInterviewPrepInput = {
    where: InterviewEvaluationWhereUniqueInput
    update: XOR<InterviewEvaluationUpdateWithoutInterviewPrepInput, InterviewEvaluationUncheckedUpdateWithoutInterviewPrepInput>
    create: XOR<InterviewEvaluationCreateWithoutInterviewPrepInput, InterviewEvaluationUncheckedCreateWithoutInterviewPrepInput>
  }

  export type InterviewEvaluationUpdateWithWhereUniqueWithoutInterviewPrepInput = {
    where: InterviewEvaluationWhereUniqueInput
    data: XOR<InterviewEvaluationUpdateWithoutInterviewPrepInput, InterviewEvaluationUncheckedUpdateWithoutInterviewPrepInput>
  }

  export type InterviewEvaluationUpdateManyWithWhereWithoutInterviewPrepInput = {
    where: InterviewEvaluationScalarWhereInput
    data: XOR<InterviewEvaluationUpdateManyMutationInput, InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepInput>
  }

  export type UserCreateWithoutInterviewEvaluationsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewEvaluationsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewEvaluationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewEvaluationsInput, UserUncheckedCreateWithoutInterviewEvaluationsInput>
  }

  export type GeneratedInterviewPrepCreateWithoutEvaluationsInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedInterviewPrepsInput
    roast?: GeneratedRoastCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedInterviewPrepsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedInterviewPrepsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedInterviewPrepInput
  }

  export type GeneratedInterviewPrepUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedInterviewPrepInput
  }

  export type GeneratedInterviewPrepCreateOrConnectWithoutEvaluationsInput = {
    where: GeneratedInterviewPrepWhereUniqueInput
    create: XOR<GeneratedInterviewPrepCreateWithoutEvaluationsInput, GeneratedInterviewPrepUncheckedCreateWithoutEvaluationsInput>
  }

  export type UserUpsertWithoutInterviewEvaluationsInput = {
    update: XOR<UserUpdateWithoutInterviewEvaluationsInput, UserUncheckedUpdateWithoutInterviewEvaluationsInput>
    create: XOR<UserCreateWithoutInterviewEvaluationsInput, UserUncheckedCreateWithoutInterviewEvaluationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterviewEvaluationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterviewEvaluationsInput, UserUncheckedUpdateWithoutInterviewEvaluationsInput>
  }

  export type UserUpdateWithoutInterviewEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedInterviewPrepUpsertWithoutEvaluationsInput = {
    update: XOR<GeneratedInterviewPrepUpdateWithoutEvaluationsInput, GeneratedInterviewPrepUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<GeneratedInterviewPrepCreateWithoutEvaluationsInput, GeneratedInterviewPrepUncheckedCreateWithoutEvaluationsInput>
    where?: GeneratedInterviewPrepWhereInput
  }

  export type GeneratedInterviewPrepUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: GeneratedInterviewPrepWhereInput
    data: XOR<GeneratedInterviewPrepUpdateWithoutEvaluationsInput, GeneratedInterviewPrepUncheckedUpdateWithoutEvaluationsInput>
  }

  export type GeneratedInterviewPrepUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput
  }

  export type UserCreateWithoutSharedAnalysesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedAnalysesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedAnalysesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedAnalysesInput, UserUncheckedCreateWithoutSharedAnalysesInput>
  }

  export type GeneratedRoastCreateWithoutSharedAnalysesInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutGeneratedRoastsInput
    resume?: ResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedResume?: ExtractedResumeCreateNestedOneWithoutGeneratedRoastsInput
    extractedJob?: ExtractedJobDescriptionCreateNestedOneWithoutGeneratedRoastsInput
    llmCalls?: LlmCallCreateNestedManyWithoutGeneratedRoastInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastUncheckedCreateWithoutSharedAnalysesInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutGeneratedRoastInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutRoastInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutRoastInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutRoastInput
  }

  export type GeneratedRoastCreateOrConnectWithoutSharedAnalysesInput = {
    where: GeneratedRoastWhereUniqueInput
    create: XOR<GeneratedRoastCreateWithoutSharedAnalysesInput, GeneratedRoastUncheckedCreateWithoutSharedAnalysesInput>
  }

  export type UserUpsertWithoutSharedAnalysesInput = {
    update: XOR<UserUpdateWithoutSharedAnalysesInput, UserUncheckedUpdateWithoutSharedAnalysesInput>
    create: XOR<UserCreateWithoutSharedAnalysesInput, UserUncheckedCreateWithoutSharedAnalysesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedAnalysesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedAnalysesInput, UserUncheckedUpdateWithoutSharedAnalysesInput>
  }

  export type UserUpdateWithoutSharedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GeneratedRoastUpsertWithoutSharedAnalysesInput = {
    update: XOR<GeneratedRoastUpdateWithoutSharedAnalysesInput, GeneratedRoastUncheckedUpdateWithoutSharedAnalysesInput>
    create: XOR<GeneratedRoastCreateWithoutSharedAnalysesInput, GeneratedRoastUncheckedCreateWithoutSharedAnalysesInput>
    where?: GeneratedRoastWhereInput
  }

  export type GeneratedRoastUpdateToOneWithWhereWithoutSharedAnalysesInput = {
    where?: GeneratedRoastWhereInput
    data: XOR<GeneratedRoastUpdateWithoutSharedAnalysesInput, GeneratedRoastUncheckedUpdateWithoutSharedAnalysesInput>
  }

  export type GeneratedRoastUpdateWithoutSharedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutSharedAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutChatbotInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutChatbotInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutChatbotInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatbotInput, UserUncheckedCreateWithoutChatbotInput>
  }

  export type UserUpsertWithoutChatbotInput = {
    update: XOR<UserUpdateWithoutChatbotInput, UserUncheckedUpdateWithoutChatbotInput>
    create: XOR<UserCreateWithoutChatbotInput, UserUncheckedCreateWithoutChatbotInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatbotInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatbotInput, UserUncheckedUpdateWithoutChatbotInput>
  }

  export type UserUpdateWithoutChatbotInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutChatbotInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallCreateNestedManyWithoutUserInput
    resumes?: ResumeCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    chatbot?: ChatbotCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    email: string
    name?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    hashedPassword?: string | null
    subscriptionTier?: $Enums.SubscriptionTier
    subscriptionId?: string | null
    customerId?: string | null
    subscriptionEndsAt?: Date | string | null
    monthlyRoasts?: number
    totalRoasts?: number
    bonusCredits?: number
    lastRoastReset?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    llmCalls?: LlmCallUncheckedCreateNestedManyWithoutUserInput
    resumes?: ResumeUncheckedCreateNestedManyWithoutUserInput
    generatedRoasts?: GeneratedRoastUncheckedCreateNestedManyWithoutUserInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedCreateNestedManyWithoutUserInput
    generatedResumes?: GeneratedResumeUncheckedCreateNestedManyWithoutUserInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedCreateNestedManyWithoutUserInput
    interviewEvaluations?: InterviewEvaluationUncheckedCreateNestedManyWithoutUserInput
    sharedAnalyses?: SharedAnalysisUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    chatbot?: ChatbotUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type ConversationMessageCreateWithoutConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model?: string | null
    template?: string | null
    tokensUsed?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: number | null
    hasLatexCode?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model?: string | null
    template?: string | null
    tokensUsed?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: number | null
    hasLatexCode?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageCreateOrConnectWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMessageCreateManyConversationInputEnvelope = {
    data: ConversationMessageCreateManyConversationInput | ConversationMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUpdateManyWithoutUserNestedInput
    resumes?: ResumeUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: EnumSubscriptionTierFieldUpdateOperationsInput | $Enums.SubscriptionTier
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monthlyRoasts?: IntFieldUpdateOperationsInput | number
    totalRoasts?: IntFieldUpdateOperationsInput | number
    bonusCredits?: IntFieldUpdateOperationsInput | number
    lastRoastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    llmCalls?: LlmCallUncheckedUpdateManyWithoutUserNestedInput
    resumes?: ResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutUserNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutUserNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutUserNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutUserNestedInput
    interviewEvaluations?: InterviewEvaluationUncheckedUpdateManyWithoutUserNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    chatbot?: ChatbotUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ConversationMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    update: XOR<ConversationMessageUpdateWithoutConversationInput, ConversationMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    data: XOR<ConversationMessageUpdateWithoutConversationInput, ConversationMessageUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationMessageUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationMessageScalarWhereInput
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationMessageScalarWhereInput = {
    AND?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
    OR?: ConversationMessageScalarWhereInput[]
    NOT?: ConversationMessageScalarWhereInput | ConversationMessageScalarWhereInput[]
    id?: StringFilter<"ConversationMessage"> | string
    conversationId?: StringFilter<"ConversationMessage"> | string
    role?: EnumMessageRoleFilter<"ConversationMessage"> | $Enums.MessageRole
    content?: StringFilter<"ConversationMessage"> | string
    messageIndex?: IntFilter<"ConversationMessage"> | number
    model?: StringNullableFilter<"ConversationMessage"> | string | null
    template?: StringNullableFilter<"ConversationMessage"> | string | null
    tokensUsed?: IntNullableFilter<"ConversationMessage"> | number | null
    costUsd?: DecimalNullableFilter<"ConversationMessage"> | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: IntNullableFilter<"ConversationMessage"> | number | null
    hasLatexCode?: BoolFilter<"ConversationMessage"> | boolean
    metadata?: JsonNullableFilter<"ConversationMessage">
    createdAt?: DateTimeFilter<"ConversationMessage"> | Date | string
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type LlmCallCreateManyUserInput = {
    id?: string
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ResumeCreateManyUserInput = {
    id?: string
    filename: string
    fileHash: string
    mimeType: string
    images?: ResumeCreateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedRoastCreateManyUserInput = {
    id?: string
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterCreateManyUserInput = {
    id?: string
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedResumeCreateManyUserInput = {
    id?: string
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
  }

  export type GeneratedInterviewPrepCreateManyUserInput = {
    id?: string
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type InterviewEvaluationCreateManyUserInput = {
    id?: string
    interviewPrepId: string
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
  }

  export type SharedAnalysisCreateManyUserInput = {
    id: string
    roastId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.InvoiceStatus
    billingPeriodStart: Date | string
    billingPeriodEnd: Date | string
    stripeInvoiceId?: string | null
    stripePaymentId?: string | null
    itemCount: number
    generatedAt?: Date | string
    paidAt?: Date | string | null
  }

  export type ChatbotCreateManyUserInput = {
    id?: string
    anonymousId?: string | null
    conversationId: string
    message: string
    role: string
    llmMessageId?: string | null
    createdAt?: Date | string
  }

  export type VerificationTokenCreateManyUserInput = {
    id?: string
    token: string
    type: $Enums.VerificationTokenType
    expiresAt: Date | string
    createdAt?: Date | string
    usedAt?: Date | string | null
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    title: string
    lastMessageAt: Date | string
    messageCount?: number
    selectedTemplate?: string | null
    selectedModel?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmCallUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResumeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutResumeNestedInput
    extractedResumes?: ExtractedResumeUncheckedUpdateManyWithoutResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutResumeNestedInput
  }

  export type ResumeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    fileHash?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    images?: ResumeUpdateimagesInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedRoastUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resume?: ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roast?: GeneratedRoastUpdateOneWithoutGeneratedResumesNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedResumesNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roast?: GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interviewPrep?: GeneratedInterviewPrepUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type InterviewEvaluationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewPrepId?: StringFieldUpdateOperationsInput | string
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    interviewPrepId?: StringFieldUpdateOperationsInput | string
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAnalysisUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roast?: GeneratedRoastUpdateOneRequiredWithoutSharedAnalysesNestedInput
  }

  export type SharedAnalysisUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roastId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAnalysisUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roastId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    billingPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    billingPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    stripeInvoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    itemCount?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatbotUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatbotUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    anonymousId?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    llmMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumVerificationTokenTypeFieldUpdateOperationsInput | $Enums.VerificationTokenType
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    lastMessageAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageCount?: IntFieldUpdateOperationsInput | number
    selectedTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    selectedModel?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmMessageCreateManyLlmCallInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    inputTokens?: number | null
    outputTokens?: number | null
    totalTokens?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string
    processingTimeMs?: number | null
    finishReason?: string | null
    temperature?: Decimal | DecimalJsLike | number | string | null
    maxTokens?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LlmMessageUpdateWithoutLlmCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmMessageUncheckedUpdateWithoutLlmCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmMessageUncheckedUpdateManyWithoutLlmCallInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    inputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    outputTokens?: NullableIntFieldUpdateOperationsInput | number | null
    totalTokens?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    finishReason?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmCallCreateManyResumeInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ExtractedResumeCreateManyResumeInput = {
    id?: string
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedRoastCreateManyResumeInput = {
    id?: string
    userId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterCreateManyResumeInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LlmCallUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExtractedResumeUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutExtractedResumeNestedInput
    summarizedResumes?: SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedRoasts?: GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeNestedInput
  }

  export type ExtractedResumeUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedRoastUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedCoverLettersNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmCallCreateManyExtractedResumeInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SummarizedResumeCreateManyExtractedResumeInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedRoastCreateManyExtractedResumeInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterCreateManyExtractedResumeInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedResumeCreateManyExtractedResumeInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
  }

  export type GeneratedInterviewPrepCreateManyExtractedResumeInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type LlmCallUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SummarizedResumeUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedResumeUncheckedUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedResumeUncheckedUpdateManyWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedRoastUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedCoverLettersNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedResumesNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedResumesNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmCallCreateManyExtractedJobInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SummarizedJobDescriptionCreateManyExtractedJobInput = {
    id?: string
    contentHash: string
    summary: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedRoastCreateManyExtractedJobInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    overallScore?: number | null
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterCreateManyExtractedJobInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedResumeCreateManyExtractedJobInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
  }

  export type GeneratedInterviewPrepCreateManyExtractedJobInput = {
    id?: string
    userId?: string | null
    roastId?: string | null
    extractedResumeId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type LlmCallUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SummarizedJobDescriptionUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedJobDescriptionUncheckedUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SummarizedJobDescriptionUncheckedUpdateManyWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    summary?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedRoastUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedRoastsNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedRoastsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedRoastsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedRoastNestedInput
    sharedAnalyses?: SharedAnalysisUncheckedUpdateManyWithoutRoastNestedInput
    generatedCoverLetters?: GeneratedCoverLetterUncheckedUpdateManyWithoutRoastNestedInput
    generatedResumes?: GeneratedResumeUncheckedUpdateManyWithoutRoastNestedInput
    generatedInterviewPreps?: GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastNestedInput
  }

  export type GeneratedRoastUncheckedUpdateManyWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    overallScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedCoverLettersNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedResumesNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedResumesNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    roast?: GeneratedRoastUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutExtractedJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    roastId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmCallCreateManyGeneratedRoastInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SharedAnalysisCreateManyRoastInput = {
    id: string
    userId: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type GeneratedCoverLetterCreateManyRoastInput = {
    id?: string
    userId?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    content: string
    tone?: string
    modelName?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type GeneratedResumeCreateManyRoastInput = {
    id?: string
    userId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    templateId: string
    contentHash: string
    content: string
    data: JsonNullValueInput | InputJsonValue
    atsScore?: number | null
    keywordsMatched?: GeneratedResumeCreatekeywordsMatchedInput | string[]
    createdAt?: Date | string
  }

  export type GeneratedInterviewPrepCreateManyRoastInput = {
    id?: string
    userId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    contentHash: string
    data: JsonNullValueInput | InputJsonValue
    difficulty?: string
    category?: string
    modelName?: string | null
    createdAt?: Date | string
  }

  export type LlmCallUpdateWithoutGeneratedRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutGeneratedRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedAnalysisUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedAnalysesNestedInput
  }

  export type SharedAnalysisUncheckedUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedAnalysisUncheckedUpdateManyWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    viewCount?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedCoverLetterUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedCoverLettersNestedInput
    resume?: ResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedCoverLettersNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedCoverLettersNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterNestedInput
  }

  export type GeneratedCoverLetterUncheckedUpdateManyWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    tone?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedResumeUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedResumesNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedResumesNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedResumesNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedResumeNestedInput
  }

  export type GeneratedResumeUncheckedUpdateManyWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    templateId?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    atsScore?: NullableIntFieldUpdateOperationsInput | number | null
    keywordsMatched?: GeneratedResumeUpdatekeywordsMatchedInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneratedInterviewPrepUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutGeneratedInterviewPrepsNestedInput
    llmCalls?: LlmCallUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    llmCalls?: LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepNestedInput
    evaluations?: InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepNestedInput
  }

  export type GeneratedInterviewPrepUncheckedUpdateManyWithoutRoastInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    contentHash?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    modelName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LlmCallCreateManyGeneratedCoverLetterInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedResumeId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LlmCallUpdateWithoutGeneratedCoverLetterInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutGeneratedCoverLetterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedCoverLetterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LlmCallCreateManyGeneratedResumeInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedInterviewPrepId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type LlmCallUpdateWithoutGeneratedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedInterviewPrep?: GeneratedInterviewPrepUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutGeneratedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedResumeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedInterviewPrepId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LlmCallCreateManyGeneratedInterviewPrepInput = {
    id?: string
    userId?: string | null
    provider: string
    model: string
    operationType: string
    totalInputTokens?: number
    totalOutputTokens?: number
    totalTokens?: number
    totalCostUsd?: Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: number | null
    status?: $Enums.LlmCallStatus
    errorMessage?: string | null
    resumeId?: string | null
    extractedResumeId?: string | null
    extractedJobId?: string | null
    generatedRoastId?: string | null
    generatedCoverLetterId?: string | null
    generatedResumeId?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type InterviewEvaluationCreateManyInterviewPrepInput = {
    id?: string
    userId?: string | null
    evaluationType: string
    data: JsonNullValueInput | InputJsonValue
    questionsCount: number
    overallScore: number
    createdAt?: Date | string
  }

  export type LlmCallUpdateWithoutGeneratedInterviewPrepInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneWithoutLlmCallsNestedInput
    resume?: ResumeUpdateOneWithoutLlmCallsNestedInput
    extractedResume?: ExtractedResumeUpdateOneWithoutLlmCallsNestedInput
    extractedJob?: ExtractedJobDescriptionUpdateOneWithoutLlmCallsNestedInput
    generatedRoast?: GeneratedRoastUpdateOneWithoutLlmCallsNestedInput
    generatedCoverLetter?: GeneratedCoverLetterUpdateOneWithoutLlmCallsNestedInput
    generatedResume?: GeneratedResumeUpdateOneWithoutLlmCallsNestedInput
    messages?: LlmMessageUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateWithoutGeneratedInterviewPrepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: LlmMessageUncheckedUpdateManyWithoutLlmCallNestedInput
  }

  export type LlmCallUncheckedUpdateManyWithoutGeneratedInterviewPrepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    operationType?: StringFieldUpdateOperationsInput | string
    totalInputTokens?: IntFieldUpdateOperationsInput | number
    totalOutputTokens?: IntFieldUpdateOperationsInput | number
    totalTokens?: IntFieldUpdateOperationsInput | number
    totalCostUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalProcessingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumLlmCallStatusFieldUpdateOperationsInput | $Enums.LlmCallStatus
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    resumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    extractedJobId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedRoastId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedCoverLetterId?: NullableStringFieldUpdateOperationsInput | string | null
    generatedResumeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewEvaluationUpdateWithoutInterviewPrepInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutInterviewEvaluationsNestedInput
  }

  export type InterviewEvaluationUncheckedUpdateWithoutInterviewPrepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewEvaluationUncheckedUpdateManyWithoutInterviewPrepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationType?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    questionsCount?: IntFieldUpdateOperationsInput | number
    overallScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageCreateManyConversationInput = {
    id?: string
    role: $Enums.MessageRole
    content: string
    messageIndex: number
    model?: string | null
    template?: string | null
    tokensUsed?: number | null
    costUsd?: Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: number | null
    hasLatexCode?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ConversationMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMessageRoleFieldUpdateOperationsInput | $Enums.MessageRole
    content?: StringFieldUpdateOperationsInput | string
    messageIndex?: IntFieldUpdateOperationsInput | number
    model?: NullableStringFieldUpdateOperationsInput | string | null
    template?: NullableStringFieldUpdateOperationsInput | string | null
    tokensUsed?: NullableIntFieldUpdateOperationsInput | number | null
    costUsd?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    processingTimeMs?: NullableIntFieldUpdateOperationsInput | number | null
    hasLatexCode?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}